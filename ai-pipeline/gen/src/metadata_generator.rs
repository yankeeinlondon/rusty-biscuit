//! Metadata code generator.
//!
//! Generates a static lookup table (`metadata_generated.rs`) containing
//! model metadata fetched from the Parsera API at build time.

use std::collections::HashMap;

use crate::parsera::ParseraModel;

/// Generates the metadata lookup table code.
pub struct MetadataGenerator {
    /// Model ID -> Parsera metadata
    entries: HashMap<String, Option<ParseraModel>>,
}

impl MetadataGenerator {
    /// Creates a new metadata generator.
    pub fn new() -> Self {
        Self {
            entries: HashMap::new(),
        }
    }

    /// Registers a model ID with optional Parsera metadata.
    ///
    /// Models without metadata will still be included in the lookup table
    /// with `None` values for graceful fallback.
    pub fn register(&mut self, model_id: String, metadata: Option<ParseraModel>) {
        self.entries.insert(model_id, metadata);
    }

    /// Generates the Rust source code for the metadata lookup table.
    pub fn generate(&self) -> String {
        let mut code = String::new();

        // File header
        code.push_str("//! Generated model metadata lookup table.\n");
        code.push_str("//!\n");
        code.push_str("//! This file is auto-generated by `gen-models`. Do not edit manually.\n");
        code.push_str("//! Re-run `gen-models` to regenerate.\n\n");

        // Imports
        code.push_str("use std::collections::HashMap;\n");
        code.push_str("use std::sync::LazyLock;\n\n");
        code.push_str("#[allow(unused_imports)]\n");
        code.push_str("use crate::models::model_metadata::{ModelMetadata, ModelModalities, Modality};\n\n");

        // Static lookup table
        let capacity = self.entries.len();
        code.push_str("/// Static lookup table mapping model IDs to their metadata.\n");
        code.push_str("pub static MODEL_METADATA: LazyLock<HashMap<&'static str, ModelMetadata>> = LazyLock::new(|| {\n");
        code.push_str(&format!(
            "    let mut m = HashMap::with_capacity({capacity});\n"
        ));

        // Sort entries for deterministic output
        let mut sorted_entries: Vec<_> = self.entries.iter().collect();
        sorted_entries.sort_by_key(|(k, _)| k.as_str());

        for (model_id, metadata) in sorted_entries {
            if let Some(meta) = metadata {
                code.push_str(&self.generate_entry(model_id, meta));
            }
        }

        code.push_str("    m\n");
        code.push_str("});\n");

        code
    }

    /// Generates a single entry for the lookup table.
    fn generate_entry(&self, model_id: &str, meta: &ParseraModel) -> String {
        let mut entry = format!("    m.insert(\"{model_id}\", ModelMetadata {{\n");

        // display_name
        entry.push_str(&format!(
            "        display_name: Some(\"{}\".to_string()),\n",
            escape_string(&meta.name)
        ));

        // family
        if let Some(family) = &meta.family {
            entry.push_str(&format!(
                "        family: Some(\"{}\".to_string()),\n",
                escape_string(family)
            ));
        } else {
            entry.push_str("        family: None,\n");
        }

        // context_window
        if let Some(ctx) = meta.context_window {
            entry.push_str(&format!("        context_window: Some({ctx}),\n"));
        } else {
            entry.push_str("        context_window: None,\n");
        }

        // max_output_tokens
        if let Some(max_out) = meta.max_output_tokens {
            entry.push_str(&format!("        max_output_tokens: Some({max_out}),\n"));
        } else {
            entry.push_str("        max_output_tokens: None,\n");
        }

        // modalities
        if let Some(mods) = &meta.modalities {
            entry.push_str("        modalities: Some(ModelModalities {\n");
            entry.push_str(&format!(
                "            input: vec![{}],\n",
                mods.input
                    .iter()
                    .filter_map(|m| modality_variant(m))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));
            entry.push_str(&format!(
                "            output: vec![{}],\n",
                mods.output
                    .iter()
                    .filter_map(|m| modality_variant(m))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));
            entry.push_str("        }),\n");
        } else {
            entry.push_str("        modalities: None,\n");
        }

        // capabilities
        if let Some(caps) = &meta.capabilities {
            if caps.is_empty() {
                entry.push_str("        capabilities: vec![],\n");
            } else {
                entry.push_str("        capabilities: vec![\n");
                for cap in caps {
                    entry.push_str(&format!(
                        "            \"{}\".to_string(),\n",
                        escape_string(cap)
                    ));
                }
                entry.push_str("        ],\n");
            }
        } else {
            entry.push_str("        capabilities: vec![],\n");
        }

        entry.push_str("    });\n");
        entry
    }
}

impl Default for MetadataGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Converts a modality string to a Modality enum variant.
fn modality_variant(s: &str) -> Option<&'static str> {
    match s.to_lowercase().as_str() {
        "text" => Some("Modality::Text"),
        "image" => Some("Modality::Image"),
        "audio" => Some("Modality::Audio"),
        "video" => Some("Modality::Video"),
        "embeddings" | "embedding" => Some("Modality::Embeddings"),
        _ => None,
    }
}

/// Escapes a string for use in generated Rust code.
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parsera::ParseraModalities;

    #[test]
    fn test_empty_generator() {
        let gen = MetadataGenerator::new();
        let code = gen.generate();

        assert!(code.contains("MODEL_METADATA"));
        assert!(code.contains("HashMap::with_capacity(0)"));
    }

    #[test]
    fn test_single_entry() {
        let mut gen = MetadataGenerator::new();

        gen.register(
            "gpt-4o".to_string(),
            Some(ParseraModel {
                id: "gpt-4o".to_string(),
                name: "GPT-4o".to_string(),
                provider: "openai".to_string(),
                family: Some("gpt-4o".to_string()),
                context_window: Some(128000),
                max_output_tokens: Some(16384),
                modalities: Some(ParseraModalities {
                    input: vec!["text".to_string(), "image".to_string()],
                    output: vec!["text".to_string()],
                }),
                capabilities: Some(vec![
                    "function_calling".to_string(),
                    "structured_output".to_string(),
                ]),
            }),
        );

        let code = gen.generate();

        assert!(code.contains("\"gpt-4o\""));
        assert!(code.contains("display_name: Some(\"GPT-4o\".to_string())"));
        assert!(code.contains("context_window: Some(128000)"));
        assert!(code.contains("Modality::Text"));
        assert!(code.contains("Modality::Image"));
        assert!(code.contains("function_calling"));
    }

    #[test]
    fn test_entry_without_metadata() {
        let mut gen = MetadataGenerator::new();
        gen.register("unknown-model".to_string(), None);

        let code = gen.generate();

        // Entry with None should not appear in the lookup table
        assert!(!code.contains("\"unknown-model\""));
    }

    #[test]
    fn test_escape_string() {
        assert_eq!(escape_string("hello"), "hello");
        assert_eq!(escape_string("hello\"world"), "hello\\\"world");
        assert_eq!(escape_string("line1\nline2"), "line1\\nline2");
    }

    #[test]
    fn test_modality_variant() {
        assert_eq!(modality_variant("text"), Some("Modality::Text"));
        assert_eq!(modality_variant("TEXT"), Some("Modality::Text"));
        assert_eq!(modality_variant("image"), Some("Modality::Image"));
        assert_eq!(modality_variant("embeddings"), Some("Modality::Embeddings"));
        assert_eq!(modality_variant("embedding"), Some("Modality::Embeddings"));
        assert_eq!(modality_variant("unknown"), None);
    }
}
