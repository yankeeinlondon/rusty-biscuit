The `usvg` crate is a part of the `resvg` ecosystem. Its primary role is to "simplify" complex SVG files—removing CSS, resolving inheritance, and converting shapes into basic paths—so that other libraries can easily render or manipulate them.

Here are the three libraries most commonly used in conjunction with `usvg`.

---

### 1. resvg

`resvg` is the high-level rendering engine designed specifically to work with `usvg`.

* **Why they are used together:** `usvg` handles the logic of parsing and simplifying the SVG into a clean "Tree" structure, but it does not have any drawing capabilities. `resvg` takes that tree and handles the heavy lifting of rasterization (turning vectors into pixels).
* **How they are used:** You parse an SVG string/file using `usvg::Tree`, and then pass a reference of that tree to the `resvg::render` function.

**Code Example:**

````rust
use usvg::{Tree, Options};
use resvg::{render, tiny_skia};

fn main() {
    let svg_data = std::fs::read("input.svg").unwrap();
    let opt = Options::default();
    
    // 1. usvg parses and simplifies the SVG
    let tree = Tree::from_data(&svg_data, &opt).unwrap();
    
    // 2. Prepare a pixmap (buffer) to draw into
    let mut pixmap = tiny_skia::Pixmap::new(500, 500).unwrap();
    
    // 3. resvg renders the usvg tree onto the pixmap
    resvg::render(&tree, usvg::Transform::default(), &mut pixmap.as_mut());
    
    pixmap.save_png("output.png").unwrap();
}
````

---

### 2. tiny-skia

`tiny-skia` is a tiny, software-only 2D drawing library. It is the default backend for `resvg`.

* **Why they are used together:** While `resvg` is the "middleman" that understands how to draw an SVG tree, `tiny-skia` provides the actual `Pixmap` (pixel buffer) and the low-level drawing primitives (fills, strokes, gradients) that the SVG requires.
* **How they are used:** You use `tiny-skia` to create the image surface and to save the final result to a file (like PNG). If you want to perform custom post-processing (like drawing a border around the SVG or compositing it with other images), you use `tiny-skia` directly on the same buffer.

**Code Example:**

````rust
use tiny_skia::{Pixmap, Paint, Color, Rect};

// Assuming 'tree' was generated by usvg (see previous example)
let mut pixmap = Pixmap::new(800, 600).unwrap();

// Draw a background color using tiny-skia directly
let mut paint = Paint::default();
paint.set_color_rgba8(255, 200, 200, 255);
pixmap.fill_rect(Rect::from_xywh(0.0, 0.0, 800.0, 600.0).unwrap(), &paint, tiny_skia::Transform::identity(), None);

// Use resvg to draw the SVG on top of that background
resvg::render(&tree, usvg::Transform::from_scale(2.0, 2.0), &mut pixmap.as_mut());
````

---

### 3. vello

`vello` is a high-performance, GPU-accelerated 2D graphics engine (part of the Linebender project).

* **Why they are used together:** While `resvg` is great for CPU rendering, developers who need extreme performance or are building modern GUI applications (like those using the `Xilem` framework) use `vello`. `vello` does not have its own SVG parser; instead, it uses `usvg` to process the SVG and then converts the `usvg` nodes into its own GPU-friendly scene graph.
* **How they are used:** You parse the SVG with `usvg`, then use a bridge crate (often `vello_svg`) to traverse the `usvg` tree and append its paths to a `vello::Scene`.

**Code Example:**

````rust
use usvg::Tree;
use vello::{Scene, SceneBuilder};
use vello_svg::append_path_tree;

fn main() {
    let svg_data = std::fs::read("vector_art.svg").unwrap();
    let tree = Tree::from_data(&svg_data, &usvg::Options::default()).unwrap();

    // Create a Vello scene
    let mut scene = Scene::new();
    let mut builder = SceneBuilder::for_scene(&mut scene);

    // Convert usvg tree into Vello commands
    append_path_tree(&mut builder, &tree);
    
    // The 'scene' can now be rendered by the Vello GPU renderer
}
````

### Summary table

|Library|Role|Why use with `usvg`?|
|:------|:---|:-------------------|
|**resvg**|Renderer|The standard way to turn a `usvg` tree into a bitmap.|
|**tiny-skia**|2D Graphics Engine|Provides the pixel buffer and drawing surface for CPU-based rendering.|
|**vello**|GPU Renderer|Allows for high-speed, hardware-accelerated SVG rendering.|