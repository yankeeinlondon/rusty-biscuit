# Utility Functions Implementation Plan

**Created:** 2025-12-29
**Status:** Implemented
**Completed:** 2025-12-29

## Review Summary

**Reviews Completed:** 2025-12-29

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. **CRITICAL:** `inject_enum()` must use AST-based enum removal (not regex) and atomic file writes with tempfile
2. **CRITICAL:** Add `ResearchType` enum instead of String for type safety in `ResearchHealth`
3. **CRITICAL:** Redesign `ModelProvider` to use struct-based pattern instead of 50+ variant enum
4. **MAJOR:** Add test infrastructure (wiremock, tempfile, fixtures) to dev-dependencies
5. **MAJOR:** Specify detailed rate limiting implementation (exponential backoff: 1s→30s, 2.0x multiplier, 3 retries)
6. **MAJOR:** Add serde derives to all data structures for CLI output and caching
7. **MAJOR:** Clarify `get_model()` return type with enum wrapper for different provider clients
8. **MINOR:** Add criterion benchmarks, schema versioning, and comprehensive rustdoc examples

**Resolved Concerns:**
- Enum injection safety → AST manipulation + atomic writes with tempfile
- Type safety → ResearchType enum, ModelProvider struct design
- Testing infrastructure → wiremock/tempfile/fixtures added to dependencies
- Rate limiting → Detailed implementation with specific retry parameters
- Scalability → ModelProvider struct-based design supports dynamic model loading

## Executive Summary

This plan implements four critical utility functions across the dockhand monorepo:

**Shared Library (3 functions):**
1. `generate_provider_list()` - Dynamic LLM provider/model discovery via official APIs
2. `inject_enum()` - Safe Rust code injection with syn validation
3. `get_model()` - Centralized model selection with fallback stacking

**Research Library (1 function):**
4. `research_health()` - DRY validation consolidating scattered health checks

These utilities establish foundational abstractions for LLM access and validation patterns used throughout the monorepo.

---

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | `generate_provider_list()` fetches models from OpenAI, Anthropic, Hugging Face, and other provider APIs | High | Rust Developer |
| FR-2 | `generate_provider_list()` supports both JSON array and Rust enum output formats | High | Rust Developer |
| FR-3 | `inject_enum()` validates Rust syntax pre/post injection using `syn` crate | High | Rust Developer |
| FR-4 | `inject_enum()` replaces existing enum definitions atomically (rollback on failure) | High | Rust Architect |
| FR-5 | `get_model()` provides centralized model selection with `ModelKind` categories (fast/normal/smart) | High | Rust Developer |
| FR-6 | `get_model()` implements fallback stacking (try multiple models if primary fails) | Medium | Rust Developer |
| FR-7 | `research_health()` consolidates all scattered validation checks into single function | High | Rust Developer |
| FR-8 | `research_health()` returns structured health report with missing files, invalid structure flags | High | Schema Architect |
| FR-9 | Replace scattered validation calls with `research_health()` in create/list/link flows | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Provider API calls handle rate limits gracefully | 429 retry with exponential backoff | Rust Developer |
| NFR-2 | `inject_enum()` preserves original file on syntax errors | 100% rollback on failure | Rust Architect |
| NFR-3 | Model selection logged to stderr for observability | Every `get_model()` call | Rust Developer |
| NFR-4 | Provider list cached locally to reduce API calls | 24hr TTL | Rust Developer |
| NFR-5 | All utilities use `thiserror` for error handling | Consistent error types | Rust Developer |
| NFR-6 | `research_health()` runs in <100ms for typical topic | Performance target | Rust Developer |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    Shared Library                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  generate_provider_list()                            │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Provider API Clients                          │  │  │
│  │  │  • OpenAI (/v1/models)                         │  │  │
│  │  │  • Anthropic (hardcoded - no API)              │  │  │
│  │  │  • Hugging Face (/api/models)                  │  │  │
│  │  │  • AWS Bedrock, Google Vertex (optional)       │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Normalization & Deduplication                 │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Format Converter                              │  │  │
│  │  │  • JSON array → string literals                │  │  │
│  │  │  • JSON array → Rust enum variants             │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  inject_enum(name, enum_str, file_path)             │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  syn Pre-check (syntax validation)             │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Enum Replacement Logic                        │  │  │
│  │  │  • Find existing enum by name                  │  │  │
│  │  │  • Remove old definition                       │  │  │
│  │  │  • Inject new definition                       │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  syn Post-check + Rollback                     │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  get_model(kind, desc)                               │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  ModelKind → ModelStack mapping                │  │  │
│  │  │  • Fast    → [haiku-4.5, gemini-flash, ...]    │  │  │
│  │  │  • Normal  → [sonnet-4.5, gpt-5.2, ...]        │  │  │
│  │  │  • Smart   → [opus-4.5, o3, ...]               │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Fallback Stack Iterator                       │  │  │
│  │  │  • Try primary model                           │  │  │
│  │  │  • On failure, try next in stack               │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  rig Client<T> Builder                         │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Research Library - Validation Module           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  research_health(type, topic)                        │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  Filesystem Checks                             │  │  │
│  │  │  • Missing Phase 1 prompts (overview.md, etc.) │  │  │
│  │  │  • Missing Phase 2 outputs (skill, deep_dive)  │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  SKILL.md Frontmatter Validation               │  │  │
│  │  │  (reuse existing parse_and_validate_...)       │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────┐  │  │
│  │  │  ResearchHealth Construction                   │  │  │
│  │  │  • Aggregate all issues                        │  │  │
│  │  │  • Set ok flag (true if no issues)             │  │  │
│  │  └────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  Replace scattered checks:                                  │
│  • lib.rs:2110 → research_health().missing_underlying      │
│  • lib.rs:2119 → research_health().missing_deliverables    │
│  • lib.rs:1793, 2728 → research_health().skill_structure_  │
│  •                      valid                               │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow

**1. Provider List Generation:**
```
generate_provider_list(format)
  → Fetch from OpenAI API (/v1/models)
  → Fetch from Anthropic (hardcoded list - no public API)
  → Fetch from Hugging Face API (/api/models filtered)
  → Normalize (lowercase provider, dedupe)
  → Format conversion (JSON | Rust enum)
  → Return string
```

**2. Enum Injection:**
```
inject_enum(name, enum_str, file_path)
  → Read existing file (if exists)
  → syn::parse_file() pre-check
  → Find enum by name in AST
  → Remove old enum, inject new enum
  → syn::parse_file() post-check
  → Write to file (or rollback on error)
```

**3. Model Selection:**
```
get_model(ModelKind::Fast, Some("scrape web content"))
  → Map ModelKind → ModelStack (e.g., [haiku, gemini-flash])
  → For each model in stack:
      → Try rig client builder
      → If success, log to stderr and return
      → If failure, continue to next
  → If all fail, return NoValidModel error
```

**4. Research Health Check:**
```
research_health(ResearchType::Library, "pulldown-cmark")
  → Check filesystem for missing prompts (overview.md, use_cases.md, ...)
  → Check filesystem for missing outputs (skill/SKILL.md, deep_dive.md, ...)
  → Validate SKILL.md frontmatter (if exists)
  → Return ResearchHealth { ok, missing_underlying, missing_deliverables, skill_structure_valid }
```

---

## Phases

### Phase 1: Shared Library - Core Provider Discovery

**Principal Owner:** Rust Developer

**Goal:** Implement `generate_provider_list()` with multi-provider API integration, normalization, and format conversion.

**Dependencies:** None

**Blast Radius:** `cargo test --lib` (new module, isolated)

**Deliverables:**
- File: `shared/src/providers/mod.rs` (module entry point)
- File: `shared/src/providers/discovery.rs` (API clients + normalization)
- File: `shared/src/providers/types.rs` (ProviderListFormat enum, LlmEntry struct)
- File: `shared/src/providers/cache.rs` (optional 24hr cache to reduce API calls)
- Updated: `shared/src/lib.rs` - export `providers` module
- Updated: `shared/Cargo.toml` - no new deps needed (reqwest, serde_json already present)

**Technical Details:**

**Data Structures:**
```rust
// shared/src/providers/types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LlmEntry {
    pub provider: String,
    pub model: String,
}

#[derive(Debug, Clone, Copy)]
pub enum ProviderListFormat {
    StringLiterals,  // JSON array: ["openai/gpt-5.2", ...]
    RustEnum,        // Rust enum variants: Openai_Gpt_5_2, ...
}
```

**API Integration Approach (from developer notes):**

1. **OpenAI:** `GET https://api.openai.com/v1/models` with `Authorization: Bearer $OPENAI_API_KEY`
   - Parse response: `{ "data": [{ "id": "gpt-5.2" }, ...] }`
   - Map to: `{ provider: "openai", model: "gpt-5.2" }`

2. **Anthropic:** No public model list API - hardcode current models:
   - `claude-opus-4.5`, `claude-sonnet-4.5`, `claude-haiku-4.5`
   - Future: Check if Anthropic publishes an API endpoint

3. **Hugging Face:** `GET https://huggingface.co/api/models` with `Authorization: Bearer $HUGGINGFACE_TOKEN`
   - Filter by tag (e.g., `text-generation`)
   - Parse response: `[{ "modelId": "meta-llama/Llama-3.3-70B-Instruct" }, ...]`

4. **Google Gemini:** Hardcode for now (no easy public API):
   - `gemini-3-flash-preview`, `gemini-5-pro`, etc.

5. **OpenRouter:** Optional - aggregator that could provide comprehensive list

**Normalization Strategy:**
```rust
fn normalize_provider_name(name: &str) -> String {
    name.to_lowercase().replace(" ", "_").replace("-", "_")
}

fn to_enum_variant(provider: &str, model: &str) -> String {
    // "openai" + "gpt-5.2" → "Openai_Gpt_5_2"
    format!("{}_{}",
        capitalize_first(&normalize_provider_name(provider)),
        model.replace(".", "_").replace("-", "_"))
}
```

**Format Conversion:**
```rust
pub async fn generate_provider_list(
    format: Option<ProviderListFormat>
) -> Result<String, ProviderError> {
    let entries = fetch_all_providers().await?;

    match format.unwrap_or(ProviderListFormat::StringLiterals) {
        ProviderListFormat::StringLiterals => {
            let literals: Vec<String> = entries.iter()
                .map(|e| format!("{}/{}", e.provider, e.model))
                .collect();
            Ok(serde_json::to_string_pretty(&literals)?)
        },
        ProviderListFormat::RustEnum => {
            let mut enum_str = String::from("pub enum ModelProvider {\n");
            for entry in entries {
                let variant = to_enum_variant(&entry.provider, &entry.model);
                enum_str.push_str(&format!("    {},\n", variant));
            }
            enum_str.push_str("}\n");
            Ok(enum_str)
        }
    }
}
```

**Error Handling:**
```rust
#[derive(Debug, Error)]
pub enum ProviderError {
    #[error("HTTP request failed: {0}")]
    HttpError(#[from] reqwest::Error),

    #[error("Rate limit exceeded for provider {provider}")]
    RateLimitExceeded { provider: String },

    #[error("API authentication failed for {provider}")]
    AuthenticationFailed { provider: String },

    #[error("JSON serialization failed: {0}")]
    SerializationError(#[from] serde_json::Error),
}
```

**Rate Limiting (Detailed Implementation):**
```rust
const INITIAL_RETRY_DELAY: Duration = Duration::from_secs(1);
const MAX_RETRY_DELAY: Duration = Duration::from_secs(30);
const RETRY_MULTIPLIER: f64 = 2.0;
const MAX_RETRIES: u32 = 3;
const REQUEST_TIMEOUT: Duration = Duration::from_secs(30);

async fn fetch_with_retry<F, Fut, T>(
    fetch_fn: F,
    provider_name: &str
) -> Result<T, ProviderError>
where
    F: Fn() -> Fut,
    Fut: Future<Output = Result<T, ProviderError>>,
{
    let mut delay = INITIAL_RETRY_DELAY;

    for attempt in 0..=MAX_RETRIES {
        match tokio::time::timeout(REQUEST_TIMEOUT, fetch_fn()).await {
            Ok(Ok(result)) => return Ok(result),
            Ok(Err(e)) if is_rate_limit_error(&e) && attempt < MAX_RETRIES => {
                warn!("Rate limit hit for {}, retry {} after {:?}", provider_name, attempt + 1, delay);
                tokio::time::sleep(delay).await;
                delay = std::cmp::min(
                    Duration::from_secs_f64(delay.as_secs_f64() * RETRY_MULTIPLIER),
                    MAX_RETRY_DELAY
                );
            },
            Ok(Err(e)) => return Err(e),
            Err(_) => return Err(ProviderError::Timeout { provider: provider_name.to_string() }),
        }
    }

    Err(ProviderError::RateLimitExceeded { provider: provider_name.to_string() })
}
```

**Concurrent Request Coalescing:**
Use mutex + double-checked cache to prevent simultaneous API calls:
```rust
use tokio::sync::Mutex;
use once_cell::sync::Lazy;

static FETCH_LOCK: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

pub async fn fetch_all_providers() -> Result<Vec<LlmEntry>, ProviderError> {
    // Double-checked locking pattern
    if let Some(cached) = check_cache()? {
        return Ok(cached);
    }

    let _guard = FETCH_LOCK.lock().await;

    // Check cache again after acquiring lock
    if let Some(cached) = check_cache()? {
        return Ok(cached);
    }

    // Fetch from all providers concurrently
    let (openai, anthropic, huggingface) = tokio::try_join!(
        fetch_with_retry(|| fetch_openai_models(), "openai"),
        fetch_anthropic_models(),  // Hardcoded, no retry needed
        fetch_with_retry(|| fetch_huggingface_models(), "huggingface"),
    )?;

    let mut all_entries = Vec::new();
    all_entries.extend(openai);
    all_entries.extend(anthropic);
    all_entries.extend(huggingface);

    let normalized = normalize_and_dedupe(all_entries);
    write_cache(&normalized)?;

    Ok(normalized)
}
```

- If provider fails after retries, continue with others (don't fail entire function)
- Use `tokio::try_join!` for concurrent provider fetching
- Add response size limit (10MB) to prevent resource exhaustion

**Acceptance Criteria:**
- [ ] File `shared/src/providers/mod.rs` exists
- [ ] File `shared/src/providers/discovery.rs` exists with >400 lines
- [ ] File `shared/src/providers/types.rs` exists with `LlmEntry` struct and `ProviderListFormat` enum
- [ ] `grep "pub async fn generate_provider_list" shared/src/providers/discovery.rs` succeeds
- [ ] Fetches models from at least OpenAI, Anthropic (hardcoded), Hugging Face
- [ ] Returns JSON array format when `StringLiterals` specified
- [ ] Returns Rust enum text when `RustEnum` specified
- [ ] Handles API failures gracefully (continues with other providers)
- [ ] `cargo test providers` runs 15+ tests covering:
   - Successful API fetches (mocked)
   - Rate limit handling
   - Normalization (lowercase, deduplication)
   - Format conversion (JSON vs enum)
- [ ] All new tests pass

---

### Phase 2: Shared Library - Safe Code Injection with syn

**Principal Owner:** Rust Developer (implementation) + Rust Architect (safety review)

**Goal:** Implement `inject_enum()` with pre/post syntax validation using `syn` crate.

**Dependencies:** Phase 1 complete (will be used together)

**Blast Radius:** `cargo test --lib` (new isolated module)

**Deliverables:**
- File: `shared/src/codegen/mod.rs` (module entry point)
- File: `shared/src/codegen/inject.rs` (enum injection logic)
- File: `shared/src/codegen/validation.rs` (syn-based syntax validation)
- Updated: `shared/src/lib.rs` - export `codegen` module
- Updated: `shared/Cargo.toml` - add `syn = { version = "2.0", features = ["full", "parsing"] }`

**Technical Details:**

**Algorithm (with Atomic Writes):**
```rust
use tempfile::NamedTempFile;
use std::path::Path;

pub async fn inject_enum(
    name: &str,
    new_enum: &str,
    file_path: &str
) -> Result<(), CodegenError> {
    let path = Path::new(file_path);

    // 1. Read existing file (or create if doesn't exist)
    let original_content = if path.exists() {
        fs::read_to_string(path)?
    } else {
        String::new()
    };

    // 2. Pre-check syntax validation (only if file exists)
    if !original_content.is_empty() {
        validate_syntax(&original_content)?;
    }

    // 3. Remove old enum definition (if exists)
    let content_without_old = remove_enum_definition(&original_content, name)?;

    // 4. Inject new enum
    let new_content = inject_enum_definition(&content_without_old, new_enum)?;

    // 5. Post-check syntax validation
    validate_syntax(&new_content)?;

    // 6. Atomic write using temporary file + rename
    let parent_dir = path.parent().unwrap_or(Path::new("."));
    let mut temp_file = NamedTempFile::new_in(parent_dir)?;
    fs::write(temp_file.path(), &new_content)?;

    // POSIX atomic rename - original file is only replaced if all validations passed
    temp_file.persist(path)?;

    Ok(())
}
```

**Safety Guarantees:**
- Original file never modified until ALL validations pass
- `NamedTempFile::persist()` uses atomic rename on POSIX systems
- If process crashes during validation, original file remains unchanged
- No partial writes or race conditions

**Syntax Validation with syn:**
```rust
// shared/src/codegen/validation.rs
use syn::parse_file;

pub fn validate_syntax(content: &str) -> Result<(), CodegenError> {
    parse_file(content)
        .map(|_| ())
        .map_err(|e| CodegenError::SyntaxError {
            message: e.to_string(),
        })
}
```

**Enum Removal Strategy (AST-Based Only):**
```rust
use syn::{File, Item};
use quote::ToTokens;

fn remove_enum_definition(content: &str, enum_name: &str) -> Result<String, CodegenError> {
    if content.is_empty() {
        return Ok(String::new());
    }

    let mut ast: File = syn::parse_str(content)
        .map_err(|e| CodegenError::SyntaxError {
            message: format!("Failed to parse file: {}", e)
        })?;

    // Remove enum with matching name
    ast.items.retain(|item| {
        !matches!(item, Item::Enum(e) if e.ident == enum_name)
    });

    // Reconstruct file using quote
    Ok(ast.into_token_stream().to_string())
}
```

**Note:** Regex-based approach rejected by reviewers due to:
- Fails on nested braces (e.g., `enum Foo { Bar { x: u32 } }`)
- Fails on doc comments containing `}` characters
- Fails on attributes and complex enum definitions
- AST-based approach is production-safe and handles all Rust syntax correctly

**Injection Strategy:**
Simply append to end of file (or insert at specific location if needed):
```rust
fn inject_enum_definition(content: &str, new_enum: &str) -> Result<String, CodegenError> {
    Ok(format!("{}\n\n{}\n", content.trim(), new_enum.trim()))
}
```

**Error Handling:**
```rust
#[derive(Debug, Error)]
pub enum CodegenError {
    #[error("Syntax error in Rust file: {message}")]
    SyntaxError { message: String },

    #[error("File I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Enum not found: {name}")]
    EnumNotFound { name: String },
}
```

**Rollback Safety:**
If post-check fails, original file is NOT modified (we only write at the very end).

**Acceptance Criteria:**
- [ ] File `shared/src/codegen/mod.rs` exists
- [ ] File `shared/src/codegen/inject.rs` exists with >200 lines
- [ ] File `shared/src/codegen/validation.rs` exists with `validate_syntax()` function
- [ ] Dependency `syn = { version = "2.0", features = ["full", "parsing"] }` in Cargo.toml
- [ ] `grep "pub async fn inject_enum" shared/src/codegen/inject.rs` succeeds
- [ ] Pre-check validates syntax before modification
- [ ] Post-check validates syntax after injection
- [ ] Original file preserved if post-check fails (no write occurs)
- [ ] Can create new file if doesn't exist
- [ ] Can replace existing enum definition
- [ ] `cargo test codegen` runs 12+ tests covering:
   - Successful injection (new file)
   - Successful replacement (existing enum)
   - Pre-check failure (invalid syntax in original)
   - Post-check failure (invalid enum provided)
   - Rollback behavior
- [ ] All new tests pass

---

### Phase 3: Shared Library - Centralized Model Selection

**Principal Owner:** Rust Developer

**Goal:** Implement `get_model()` with ModelKind categories, fallback stacking, and stderr logging.

**Dependencies:** None (independent of Phase 1-2, but conceptually related)

**Blast Radius:** `cargo test --lib model` (new module)

**Deliverables:**
- File: `shared/src/model/mod.rs` (module entry point)
- File: `shared/src/model/selection.rs` (get_model implementation)
- File: `shared/src/model/types.rs` (ModelKind, ModelProvider enums, ModelStack struct)
- Updated: `shared/src/lib.rs` - export `model` module

**Technical Details:**

**Data Structures (Struct-Based Design):**
```rust
// shared/src/model/types.rs

/// Provider/model combination (struct-based for scalability)
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ModelProvider {
    pub provider: String,  // "anthropic", "openai", "gemini", etc.
    pub model: String,     // "claude-sonnet-4.5", "gpt-5.2", etc.
}

impl ModelProvider {
    /// Create a new model provider
    pub fn new(provider: impl Into<String>, model: impl Into<String>) -> Self {
        Self {
            provider: provider.into(),
            model: model.into(),
        }
    }

    /// Common models as constants for convenience
    pub const CLAUDE_OPUS_4_5: Self = Self {
        provider: String::from("anthropic"),
        model: String::from("claude-opus-4-5-20250929"),
    };

    pub const CLAUDE_SONNET_4_5: Self = Self {
        provider: String::from("anthropic"),
        model: String::from("claude-sonnet-4-5-20250929"),
    };

    pub const CLAUDE_HAIKU_4_5: Self = Self {
        provider: String::from("anthropic"),
        model: String::from("claude-haiku-4-5-20250929"),
    };

    pub const GPT_5_2: Self = Self {
        provider: String::from("openai"),
        model: String::from("gpt-5.2"),
    };

    pub const O3: Self = Self {
        provider: String::from("openai"),
        model: String::from("o3"),
    };

    pub const GEMINI_FLASH_3: Self = Self {
        provider: String::from("gemini"),
        model: String::from("gemini-3-flash-preview"),
    };

    pub fn to_rig_identifier(&self) -> (&str, &str) {
        (&self.provider, &self.model)
    }
}

/// Model quality tiers
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModelQuality {
    /// Fast, cheap models (haiku, gemini-flash)
    Fast,
    /// Balanced models (sonnet, gpt-5.2)
    Normal,
    /// Most capable models (opus, o3)
    Smart,
}

/// Model selection categories
#[derive(Debug, Clone)]
pub enum ModelKind {
    /// Quality tier (Fast/Normal/Smart)
    Quality(ModelQuality),

    /// Use case specific
    UseCase {
        task: TaskKind,
        quality: Option<ModelQuality>,
    },

    /// Explicit model with fallback
    TryExplicit {
        explicit_first: ModelProvider,
        fallback: ModelQuality,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TaskKind {
    Summarize,
    Scrape,
    Consolidate,
}

/// Ordered list of models to try (with fallback)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelStack(pub Vec<ModelProvider>);

impl ModelStack {
    pub fn fast() -> Self {
        Self(vec![
            ModelProvider::CLAUDE_HAIKU_4_5,
            ModelProvider::GEMINI_FLASH_3,
        ])
    }

    pub fn normal() -> Self {
        Self(vec![
            ModelProvider::CLAUDE_SONNET_4_5,
            ModelProvider::GPT_5_2,
        ])
    }

    pub fn smart() -> Self {
        Self(vec![
            ModelProvider::CLAUDE_OPUS_4_5,
            ModelProvider::O3,
        ])
    }

    pub fn for_quality(quality: ModelQuality) -> Self {
        match quality {
            ModelQuality::Fast => Self::fast(),
            ModelQuality::Normal => Self::normal(),
            ModelQuality::Smart => Self::smart(),
        }
    }

    pub fn for_task(task: TaskKind, quality: Option<ModelQuality>) -> Self {
        let default_quality = match task {
            TaskKind::Scrape => ModelQuality::Fast,
            TaskKind::Summarize => ModelQuality::Normal,
            TaskKind::Consolidate => ModelQuality::Smart,
        };

        Self::for_quality(quality.unwrap_or(default_quality))
    }
}

/// Wrapper for different rig client types
#[derive(Debug)]
pub enum LlmClient {
    Anthropic(rig_core::providers::anthropic::Client),
    OpenAI(rig_core::providers::openai::Client),
    Gemini(rig_core::providers::gemini::Client),
}
```

**Model Selection Implementation:**
```rust
// shared/src/model/selection.rs
use tracing::{info, warn};

#[derive(Debug, Error)]
pub enum ModelError {
    #[error("No valid model available in stack. Attempted: {attempted:?}")]
    NoValidModel {
        attempted: Vec<(String, String)>,  // (provider, reason)
    },

    #[error("Client initialization failed for {provider}: {reason}")]
    ClientInitFailed {
        provider: String,
        reason: String,
    },
}

pub fn get_model(
    kind: ModelKind,
    desc: Option<&str>
) -> Result<LlmClient, ModelError> {
    let stack = match kind {
        ModelKind::Quality(quality) => ModelStack::for_quality(quality),
        ModelKind::UseCase { task, quality } => ModelStack::for_task(task, quality),
        ModelKind::TryExplicit { explicit_first, fallback } => {
            let mut stack = ModelStack(vec![explicit_first]);
            stack.0.extend(ModelStack::for_quality(fallback).0);
            stack
        }
    };

    let mut attempted = Vec::new();

    for model_provider in stack.0 {
        match try_build_client(&model_provider) {
            Ok(client) => {
                let (provider, model) = model_provider.to_rig_identifier();
                if let Some(description) = desc {
                    eprintln!("- using the {} from {} to {}", model, provider, description);
                }
                return Ok(client);
            },
            Err(e) => {
                warn!("Failed to initialize {} {}: {}",
                    model_provider.provider, model_provider.model, e);
                attempted.push((
                    format!("{}/{}", model_provider.provider, model_provider.model),
                    e.to_string()
                ));
                continue;
            }
        }
    }

    Err(ModelError::NoValidModel { attempted })
}

fn try_build_client(provider: &ModelProvider) -> Result<LlmClient, ModelError> {
    let (provider_name, model_id) = provider.to_rig_identifier();

    // Use rig-core client builders
    match provider_name {
        "anthropic" => {
            let client = rig_core::providers::anthropic::Client::from_env()
                .map_err(|e| ModelError::ClientInitFailed {
                    provider: "anthropic".to_string(),
                    reason: e.to_string(),
                })?;
            Ok(LlmClient::Anthropic(client))
        },
        "openai" => {
            let client = rig_core::providers::openai::Client::from_env()
                .map_err(|e| ModelError::ClientInitFailed {
                    provider: "openai".to_string(),
                    reason: e.to_string(),
                })?;
            Ok(LlmClient::OpenAI(client))
        },
        "gemini" => {
            let client = rig_core::providers::gemini::Client::from_env()
                .map_err(|e| ModelError::ClientInitFailed {
                    provider: "gemini".to_string(),
                    reason: e.to_string(),
                })?;
            Ok(LlmClient::Gemini(client))
        },
        _ => Err(ModelError::ClientInitFailed {
            provider: provider_name.to_string(),
            reason: format!("Unsupported provider: {}", provider_name),
        }),
    }
}
```

**Acceptance Criteria:**
- [ ] File `shared/src/model/mod.rs` exists
- [ ] File `shared/src/model/selection.rs` exists with >250 lines
- [ ] File `shared/src/model/types.rs` exists with `ModelKind`, `ModelProvider`, `ModelStack` definitions
- [ ] `grep "pub fn get_model" shared/src/model/selection.rs` succeeds
- [ ] ModelKind enum has Fast, Normal, Smart, Summarize, Scrape, Consolidate, TryExplicit variants
- [ ] ModelStack defines ordered fallback lists for each category
- [ ] `get_model()` tries models in stack order until one succeeds
- [ ] Logs to stderr when desc parameter provided: "- using the {model} from {provider} to {desc}"
- [ ] Returns NoValidModel error if all models in stack fail
- [ ] `cargo test model` runs 10+ tests covering:
   - Successful model selection (Fast, Normal, Smart)
   - Fallback behavior (primary fails, secondary succeeds)
   - NoValidModel error (all fail)
   - Stderr logging verification
   - TryExplicit variant
- [ ] All new tests pass

---

### Phase 4: Research Library - Centralized Health Validation

**Principal Owner:** Rust Developer + Schema Architect (data modeling)

**Goal:** Implement `research_health()` function consolidating all scattered validation checks.

**Dependencies:** None (refactoring existing validation)

**Blast Radius:** `cargo test --lib validation` (expanding existing validation module)

**Deliverables:**
- File: `research/lib/src/validation/health.rs` (new - research_health implementation)
- Updated: `research/lib/src/validation/mod.rs` - export health module
- Updated: `research/lib/src/validation/frontmatter.rs` - reuse existing validation

**Technical Details:**

**Data Structures (with ResearchType enum):**
```rust
// research/lib/src/validation/health.rs
use super::frontmatter::parse_and_validate_frontmatter;
use crate::list::types::ResearchOutput;
use std::path::{Path, PathBuf};
use std::str::FromStr;

/// Research topic type (type-safe enum)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ResearchType {
    Library,
    Tool,
    Software,
    Framework,
}

impl ResearchType {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Library => "library",
            Self::Tool => "tool",
            Self::Software => "software",
            Self::Framework => "framework",
        }
    }
}

impl FromStr for ResearchType {
    type Err = ValidationError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "library" => Ok(Self::Library),
            "tool" => Ok(Self::Tool),
            "software" => Ok(Self::Software),
            "framework" => Ok(Self::Framework),
            _ => Err(ValidationError::InvalidResearchType(s.to_string())),
        }
    }
}

impl std::fmt::Display for ResearchType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ResearchHealth {
    pub research_type: ResearchType,
    pub topic: String,

    /// All underlying data and final deliverables are complete and valid
    pub ok: bool,

    /// Missing Phase 1 files (overview.md, use_cases.md, etc.)
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub missing_underlying: Vec<String>,

    /// Missing Phase 2 outputs (skill, deep_dive, brief)
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub missing_deliverables: Vec<ResearchOutput>,

    /// SKILL.md frontmatter is valid (if skill exists)
    pub skill_structure_valid: bool,

    /// Schema version for future evolution
    #[serde(default = "default_version")]
    pub version: u8,
}

fn default_version() -> u8 {
    1
}

#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("Research topic not found at path: {path}")]
    TopicNotFound { path: PathBuf },

    #[error("Invalid research type: '{0}'. Valid types: library, tool, software, framework")]
    InvalidResearchType(String),

    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),
}
```

**Implementation Strategy:**

**Consolidate existing checks:**
1. `check_missing_standard_prompts()` (lib.rs:182) → `missing_underlying` field
2. `check_missing_outputs()` (lib.rs:221) → `missing_deliverables` field
3. `parse_and_validate_frontmatter()` (validation/frontmatter.rs:160) → `skill_structure_valid` field

```rust
pub fn research_health(
    research_type: ResearchType,
    topic: &str
) -> Result<ResearchHealth, ValidationError> {
    // Determine base path (from research/lib/src/lib.rs:119-136 pattern)
    let base_path = get_research_base_path()?;
    let topic_path = base_path.join(research_type.as_str()).join(topic);

    if !topic_path.exists() {
        return Err(ValidationError::TopicNotFound {
            path: topic_path
        });
    }

    // Check Phase 1 prompts
    let missing_underlying = check_missing_prompts(&topic_path);

    // Check Phase 2 outputs
    let missing_deliverables = check_missing_outputs(&topic_path);

    // Validate SKILL.md frontmatter (if exists)
    let skill_structure_valid = validate_skill_frontmatter(&topic_path);

    // Determine overall health
    let ok = missing_underlying.is_empty()
        && missing_deliverables.is_empty()
        && skill_structure_valid;

    Ok(ResearchHealth {
        research_type,
        topic: topic.to_string(),
        ok,
        missing_underlying,
        missing_deliverables,
        skill_structure_valid,
        version: 1,
    })
}

// Reuse existing logic from lib.rs:182-197
fn check_missing_prompts(topic_path: &Path) -> Vec<String> {
    const STANDARD_PROMPTS: &[(&str, &str)] = &[
        ("Overview", "overview.md"),
        ("Similar Libraries", "similar_libraries.md"),
        ("Integration Partners", "integration_partners.md"),
        ("Use Cases", "use_cases.md"),
        ("Changelog", "changelog.md"),
        ("Additional Context", "context.md"),
    ];

    STANDARD_PROMPTS.iter()
        .filter(|(_, filename)| !topic_path.join(filename).exists())
        .map(|(name, _)| name.to_string())
        .collect()
}

// Reuse existing logic from lib.rs:221-235
fn check_missing_outputs(topic_path: &Path) -> Vec<ResearchOutput> {
    let mut missing = Vec::new();

    if !topic_path.join("deep_dive.md").exists() {
        missing.push(ResearchOutput::DeepDive);
    }
    if !topic_path.join("brief.md").exists() {
        missing.push(ResearchOutput::Brief);
    }
    if !topic_path.join("skill/SKILL.md").exists() {
        missing.push(ResearchOutput::Skill);
    }

    missing
}

// Reuse existing validation/frontmatter.rs logic
fn validate_skill_frontmatter(topic_path: &Path) -> bool {
    let skill_path = topic_path.join("skill/SKILL.md");
    if !skill_path.exists() {
        return false;  // No skill file = invalid structure
    }

    match fs::read_to_string(&skill_path) {
        Ok(content) => {
            parse_and_validate_frontmatter(&content).is_ok()
        },
        Err(_) => false,
    }
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/validation/health.rs` exists with >300 lines
- [ ] `grep "pub fn research_health" research/lib/src/validation/health.rs` succeeds
- [ ] ResearchHealth struct has all fields from spec (ok, missing_underlying, missing_deliverables, skill_structure_valid)
- [ ] Reuses existing `parse_and_validate_frontmatter()` logic
- [ ] Consolidates Phase 1 prompt checks (from lib.rs:182)
- [ ] Consolidates Phase 2 output checks (from lib.rs:221)
- [ ] Returns TopicNotFound error if path doesn't exist
- [ ] `cargo test validation::health` runs 8+ tests covering:
   - Healthy topic (all files present, valid frontmatter)
   - Missing Phase 1 prompts
   - Missing Phase 2 outputs
   - Invalid SKILL.md frontmatter
   - Non-existent topic
- [ ] All new tests pass

---

### Phase 5: Research Library - Replace Scattered Validation Calls

**Principal Owner:** Rust Developer

**Goal:** Replace all scattered validation checks with calls to `research_health()`.

**Dependencies:** Phase 4 complete

**Blast Radius:** `cargo test` (full test suite - affects multiple flows)

**Deliverables:**
- Updated: `research/lib/src/lib.rs` - replace scattered checks with `research_health()` calls
- Removed (or marked deprecated): `check_missing_standard_prompts()` (lib.rs:182)
- Removed (or marked deprecated): `check_missing_outputs()` (lib.rs:221)

**Technical Details:**

**Call Sites to Replace:**

1. **Line 2110** - "research library" flow:
```rust
// BEFORE
let missing_prompts = check_missing_standard_prompts(&output_dir).await;

// AFTER
let health = research_health(&research_type, &topic)?;
let missing_prompts = health.missing_underlying;
```

2. **Line 2119** - "research library" flow:
```rust
// BEFORE
let missing_outputs = check_missing_outputs(&output_dir).await;

// AFTER
// Already have health from above
let missing_outputs = health.missing_deliverables;
```

3. **Line 1793, 2728** - SKILL.md frontmatter validation after generation:
```rust
// BEFORE
let (frontmatter, body) = parse_and_validate_frontmatter(&skill_content)?;

// AFTER (still use direct call for detailed error messages during generation)
// Keep parse_and_validate_frontmatter for generation flows
// Use research_health for listing/linking flows
```

4. **"research list" flow** - uses `TopicInfo.has_issues()`:
```rust
// BEFORE (list/discovery.rs)
let topic_info = TopicInfo {
    missing_underlying: check_prompts(...),
    missing_output: check_outputs(...),
    // ...
};

// AFTER
let health = research_health(&topic_type, &topic_name)?;
let topic_info = TopicInfo {
    missing_underlying: health.missing_underlying,
    missing_output: health.missing_deliverables,
    // ...
};
```

5. **"research link" flow** - validation before creating symlink:
```rust
// Add health check before linking
let health = research_health(&research_type, &topic)?;
if !health.ok {
    warn!("Topic has validation issues: {:?}", health);
}
```

**Deprecation Strategy:**
- Mark `check_missing_standard_prompts()` and `check_missing_outputs()` as `#[deprecated]`
- Add deprecation notice pointing to `research_health()`
- Remove in future version after confirming all call sites migrated

**Acceptance Criteria:**
- [ ] All usages of `check_missing_standard_prompts()` replaced with `research_health().missing_underlying`
- [ ] All usages of `check_missing_outputs()` replaced with `research_health().missing_deliverables`
- [ ] `research list` flow uses `research_health()`
- [ ] `research link` flow validates with `research_health()` before linking
- [ ] `research library` flow (create) uses `research_health()` for validation
- [ ] Old functions marked `#[deprecated(note = "Use research_health() instead")]`
- [ ] `cargo test` (full suite) passes
- [ ] Manual testing:
   - `research list` displays health issues correctly
   - `research library` detects missing files
   - `research link` validates before linking
- [ ] All tests pass

---

## Cross-Cutting Concerns

### Testing Strategy

**Unit Tests:**
- Each module has `#[cfg(test)] mod tests` blocks
- Mock HTTP responses for provider API tests (use `wiremock` or similar)
- Test error conditions (rate limits, auth failures, syntax errors)

**Integration Tests:**
- `tests/provider_integration.rs` - test real API calls (optional, requires API keys)
- `tests/codegen_integration.rs` - test full inject_enum workflow on sample files
- `tests/model_selection_integration.rs` - test get_model with rig client building
- `tests/research_health_integration.rs` - test on actual research topics in fixtures

**Property-Based Tests (proptest):**
- Provider normalization (any input → valid enum variant)
- Enum injection (preserves valid syntax)

**Doc Tests:**
- Public API examples in rustdoc comments
- `generate_provider_list()`, `inject_enum()`, `get_model()`, `research_health()` usage examples

### Security Considerations

**Provider API Keys:**
- Read from environment variables only (`.env` via `dotenvy`)
- Never log API keys
- Handle missing keys gracefully (return AuthenticationFailed error)

**Code Injection Safety:**
- `inject_enum()` validates syntax before and after modification
- Rollback on syntax errors (original file untouched)
- Only injects enums (no arbitrary code execution)

**HTTP Security:**
- Use HTTPS for all provider API calls
- Validate response content-type and size
- Implement request timeouts (30s)

### Performance Considerations

**Provider API Caching:**
- Cache provider list for 24 hours to reduce API calls
- Store in `$HOME/.cache/dockhand/provider_list.json`
- Invalidate on user request or TTL expiration

**syn Parsing Performance:**
- `syn::parse_file()` is fast for typical files (<1ms for <5000 lines)
- For large files (>10k lines), consider streaming parsing

**research_health Performance:**
- Filesystem checks only (no network I/O)
- Target <100ms for typical topic (6 prompt files + 3 output files)
- Use `walkdir` for efficient directory traversal

**Model Selection:**
- `get_model()` is synchronous and fast (<1ms)
- Client initialization may be slow (env var reads, network setup)
- Log initialization time for debugging

### Observability

**Tracing:**
```rust
#[instrument(skip(format))]
pub async fn generate_provider_list(format: Option<ProviderListFormat>) -> Result<String> {
    info!("Fetching provider list");
    // ...
}

#[instrument(fields(name = %name, file = %file_path))]
pub async fn inject_enum(name: &str, new_enum: &str, file_path: &str) -> Result<()> {
    info!("Injecting enum");
    // ...
}

#[instrument(fields(kind = ?kind, desc = ?desc))]
pub fn get_model(kind: ModelKind, desc: Option<&str>) -> Result<Client> {
    info!("Selecting model");
    // ...
}

#[instrument(fields(type = %research_type, topic = %topic))]
pub fn research_health(research_type: &str, topic: &str) -> Result<ResearchHealth> {
    debug!("Checking research health");
    // ...
}
```

**Stderr Logging:**
- `get_model()` logs model selection to stderr (as per spec)
- Use `eprintln!()` for user-visible messages
- Use `tracing` for structured debugging

### Error Handling Strategy

**Shared Library:**
- `ProviderError` - provider API failures, rate limits, auth
- `CodegenError` - syntax errors, I/O errors, enum not found
- `ModelError` - no valid model, client init failed

**Research Library:**
- `ValidationError` - topic not found, invalid type, I/O errors
- Reuse existing `FrontmatterError` for SKILL.md validation

**Error Context:**
- Use `#[error("...")]` attributes with context
- Use `#[from]` for automatic conversion
- Preserve error sources with `#[source]` (for debugging)

---

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1, Phase 2, Phase 3, Phase 4 | Independent modules, no dependencies |
| Group B | Phase 5 | Depends on Phase 4 (research_health implementation) |

**Implementation Strategy:**
- Phases 1-4 can be developed simultaneously by different developers
- Phase 5 (integration) requires Phase 4 completion
- Testing can occur in parallel for each phase

**Timeline Optimization:**
```
Group A (parallel): Phase 1, 2, 3, 4 ─────────────┐
                                                  │
Group B (sequential):                              └──► Phase 5
```

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Provider API changes | Medium | Version API endpoints, add tests for schema changes, fallback to hardcoded lists |
| Rate limiting on provider APIs | Medium | Implement exponential backoff, cache results for 24hrs, allow manual refresh |
| syn parsing fails on edge cases | Low | Comprehensive tests with real Rust files, fallback to regex-based approach for MVP |
| research_health performance on large repos | Low | Benchmark with 100+ topics, optimize filesystem traversal if needed |
| Breaking existing validation logic | High | Extensive integration tests, manual testing before merging Phase 5 |
| rig-core API changes | Medium | Pin version in Cargo.toml, update when stable |

---

## Open Questions

- [x] **Q1:** Should `generate_provider_list()` support caching? If so, where should cache be stored?
  - **RESOLVED:** Yes, `$HOME/.cache/dockhand/provider_list.json` with 24hr TTL
  - Use double-checked locking with mutex to prevent concurrent API calls

- [x] **Q2:** Should Anthropic models be hardcoded or is there a public API we can use?
  - **RESOLVED:** Hardcode for now (no public API available), revisit when API becomes available

- [x] **Q3:** Should `inject_enum()` use full AST manipulation (quote crate) or regex-based replacement?
  - **RESOLVED:** MUST use full AST manipulation with `syn` + `quote` (reviewer consensus)
  - Regex approach rejected due to safety concerns (nested braces, doc comments, attributes)

- [x] **Q4:** Should `get_model()` return `rig_core::Client<T>` or a custom wrapper?
  - **RESOLVED:** Return `LlmClient` enum wrapper to handle different provider types
  - `enum LlmClient { Anthropic(Client), OpenAI(Client), Gemini(Client) }`

- [x] **Q5:** Should `research_health()` be async (for future network checks) or sync (filesystem only)?
  - **RESOLVED:** Sync for now (filesystem only), signature can be updated later if needed

- [x] **Q6:** Should old validation functions (`check_missing_standard_prompts`, etc.) be removed or deprecated?
  - **RESOLVED:** Deprecate first with `#[deprecated]` attribute, remove in next major version

- [x] **Q7:** Should `ModelProvider` be a 50+ variant enum or struct-based?
  - **RESOLVED:** Struct-based design with const helpers for common models (reviewer consensus)
  - Enables dynamic model loading and scales better than large enums

- [x] **Q8:** Should `ResearchHealth.research_type` be String or enum?
  - **RESOLVED:** Type-safe `ResearchType` enum with Library/Tool/Software/Framework variants
  - Implements `FromStr` for CLI parsing, `Display` for output

### New Questions from Review

- [ ] **Q9:** Should `inject_enum()` support optional rustfmt post-processing for consistent formatting?
  - **Proposed:** Not in MVP, add as optional feature if users request it

- [ ] **Q10:** Should model selection include telemetry/metrics collection for fallback frequency?
  - **Proposed:** Not in MVP, add as optional feature flag if needed for production debugging

- [ ] **Q11:** Should `research_health()` implement caching based on mtime for large repositories?
  - **Proposed:** Not in MVP, benchmark with 100+ topics first, add if <100ms target not met

---

## Dependencies

### Shared Library - New Dependencies

```toml
[dependencies]
# Phase 2 - Code injection (AST manipulation + atomic writes)
syn = { version = "2.0", features = ["full", "parsing"] }
quote = "1.0"
tempfile = "3.8"

# Phase 1 - Concurrent request coalescing
once_cell = "1.19"

# Already present:
rig-core = "0.27"
reqwest = { version = "0.12", features = ["json", "gzip"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
tokio = { version = "1.48", features = ["full"] }
tracing = "0.1"

[dev-dependencies]
# HTTP mocking for provider API tests
wiremock = "0.6"

# Performance benchmarking
criterion = { version = "0.5", features = ["html_reports"] }

# Property-based testing
proptest = "1.4"

# Already present:
tokio = { version = "1.48", features = ["full", "test-util"] }
```

### Research Library - New Dependencies

```toml
[dev-dependencies]
# Filesystem testing with temporary directories
tempfile = "3.8"

# Already present:
tokio = { version = "1.48.0", features = ["full", "tokio-macros"] }
```

All other required dependencies already present:
- `rig-core`, `thiserror`, `tokio`, `tracing`, `serde`, `serde_yaml`, `walkdir`

---

## Success Metrics

**Phase 1-3 (Shared Library):**
- [ ] `generate_provider_list()` fetches 50+ models from 3+ providers
- [ ] `inject_enum()` has 0% failure rate on syntax validation
- [ ] `get_model()` used in at least 5 call sites across research library

**Phase 4-5 (Research Library):**
- [ ] `research_health()` consolidates 4+ scattered validation functions
- [ ] Code reduction: Remove 100+ lines of duplicate validation logic
- [ ] Performance: `research_health()` completes in <100ms for typical topic

**Integration:**
- [ ] All existing tests pass after migration (Phase 5)
- [ ] Manual testing confirms "research list", "research link", "research library" flows work correctly
- [ ] Zero regressions in validation behavior

---

## Next Steps After Planning

1. **Review this plan** - Get feedback from sub-agents (Rust Developer, Rust Architect, Schema Architect)
2. **Clarify open questions** - User input needed on caching strategy, async vs sync
3. **Begin implementation:**
   - Parallel: Phase 1, 2, 3, 4
   - Sequential: Phase 5 (after Phase 4)
4. **Testing strategy:**
   - Unit tests per phase
   - Integration tests after Phase 5
   - Manual testing of all flows
5. **Documentation:**
   - Update shared/docs with usage examples
   - Update research/docs with new validation approach
