# Library Command: Implement `--skill` and `--force` Flags

**Created:** 2025-12-29
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2025-12-29

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. Enhanced `remove_directory_contents()` to use `symlink_metadata` for safe symlink handling
2. Added atomicity guarantees for force mode using temp directory pattern
3. Expanded testing strategy with property tests, rollback tests, and concurrent execution tests
4. Added specific function signatures for `run_phase_1_research()` and `run_phase_2_synthesis()`
5. Clarified `generate_skill_only()` should reuse existing Phase 2 patterns
6. Added tracing instrumentation requirements for new async functions
7. Enhanced acceptance criteria with specific coverage targets per function

**Resolved Concerns:**
- Symlink safety → Use `symlink_metadata` instead of `metadata` to avoid following symlinks
- Partial state on failure → Implement temp directory pattern with atomic rename
- Property test details → Added concrete proptest implementations for symlinks and file counts
- Refactoring scope → Specified exact function signatures with cancellation/metadata flow
- Test completeness → Added rollback tests, concurrent execution tests, and logging assertion tests

## Executive Summary

This plan implements two new CLI flags for the `research library` command: `--skill` to regenerate skill files from existing research, and `--force` to force recreation of all research output documents. These flags enhance the research workflow by allowing users to fix invalid SKILL.md frontmatter and refresh outdated outputs without re-running expensive LLM research queries.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Add `--skill` flag to CLI that regenerates skill directory contents from existing research documents | High | Rust Developer |
| FR-2 | Add `--force` flag to CLI that forces recreation of ResearchOutput files (SKILL.md, deep_dive.md, brief.md) | High | Rust Developer |
| FR-3 | `--skill` validates topic has all required files (underlying research + final outputs) before regeneration | High | Rust Developer |
| FR-4 | `--skill` removes existing skill/* files but preserves directory (to maintain symbolic links) | Medium | Rust Developer |
| FR-5 | `--force` skips Phase 1 research prompts but runs Phase 2 synthesis prompts | High | Rust Architect |
| FR-6 | Both flags interact correctly with existing incremental mode and metadata | High | Rust Architect |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | User-friendly error messages when preconditions aren't met | Clear guidance | Rust Developer |
| NFR-2 | Preserve symbolic links when regenerating skills | No broken links | Rust Developer |
| NFR-3 | Minimize LLM token usage by reusing Phase 1 research | 80%+ token savings | Rust Architect |
| NFR-4 | Maintain backward compatibility with existing research metadata | 100% compatibility | Rust Architect |

## Architecture Overview

The research library workflow consists of two phases:

1. **Phase 1: Research** - LLM agents gather information via web search/scraping (expensive, creates overview.md, similar_libraries.md, etc.)
2. **Phase 2: Synthesis** - LLM agents consolidate Phase 1 outputs into final artifacts (SKILL.md, deep_dive.md, brief.md)

### Current Flow

```
research library <topic>
  ├─ Phase 1: Run research prompts (web search/scrape) → markdown files
  └─ Phase 2: Synthesize research → SKILL.md, deep_dive.md, brief.md
```

### Enhanced Flow with Flags

```
research library <topic> --skill
  ├─ Validate: All Phase 1 + Phase 2 files exist
  ├─ Remove: skill/* (preserve directory)
  └─ Phase 2: Regenerate SKILL.md only

research library <topic> --force
  ├─ Skip: Phase 1 research prompts
  └─ Phase 2: Regenerate all outputs (SKILL.md, deep_dive.md, brief.md)
```

### Component Modifications

| Component | File | Modification |
|-----------|------|--------------|
| CLI Args | `cli/src/main.rs` | Add `--skill` and `--force` boolean flags to `Commands::Library` |
| Library Function | `lib/src/lib.rs` | Update `research()` signature to accept `skill_only: bool, force: bool` |
| Phase Execution | `lib/src/lib.rs` | Add conditional logic to skip Phase 1 when `force=true` |
| Skill Regeneration | `lib/src/lib.rs` | Add function to remove skill/* contents and regenerate |
| Validation | `lib/src/lib.rs` | Add precondition checks for `--skill` flag |

## Phases

### Phase 1: CLI Argument Parsing

**Principal Owner:** Rust Developer

**Goal:** Add `--skill` and `--force` flags to the library subcommand and pass them through to the library function.

**Dependencies:** None

**Blast Radius:** `cargo test --bin research`

**Deliverables:**
- Modified `cli/src/main.rs` with new flags in `Commands::Library` struct
- Updated function call to `research()` passing both flags
- Flags validated as mutually exclusive (error if both provided)

**Technical Details:**
- Add to `Commands::Library` struct (line 29):
  ```rust
  /// Regenerate skill files from existing research (requires complete research)
  #[arg(long)]
  skill: bool,

  /// Force recreation of all output files (skip Phase 1 research)
  #[arg(long)]
  force: bool,
  ```
- Update `research()` call (line 163):
  ```rust
  match research(&topic, output, &questions, skill, force).await {
  ```
- Add validation before research call:
  ```rust
  if skill && force {
      eprintln!("Error: --skill and --force are mutually exclusive");
      std::process::exit(1);
  }
  ```

**Acceptance Criteria:**
- [ ] `cargo build --bin research` succeeds
- [ ] `research library --help` shows both `--skill` and `--force` flags
- [ ] File `cli/src/main.rs` contains skill and force bool fields
- [ ] `grep "skill: bool" cli/src/main.rs` succeeds
- [ ] `grep "force: bool" cli/src/main.rs` succeeds
- [ ] Running `research library foo --skill --force` exits with error message

---

### Phase 2: Library Function Signature Update

**Principal Owner:** Rust Developer

**Goal:** Update the `research()` function signature to accept the new flags and add initial validation logic.

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test --lib`

**Deliverables:**
- Updated `research()` function signature in `lib/src/lib.rs`
- Validation logic for `--skill` flag preconditions
- Early return path for `--skill` mode
- Updated tests to pass new parameters

**Technical Details:**
- Update function signature (line 2089):
  ```rust
  pub async fn research(
      topic: &str,
      output_dir: Option<PathBuf>,
      questions: &[String],
      skill_only: bool,
      force: bool,
  ) -> Result<ResearchResult, ResearchError> {
  ```
- Add validation at function start:
  ```rust
  // Validate mutually exclusive flags
  if skill_only && force {
      return Err(ResearchError::InvalidArguments(
          "--skill and --force are mutually exclusive".into()
      ));
  }

  // For --skill mode, validate preconditions
  if skill_only {
      return handle_skill_regeneration(topic, output_dir).await;
  }
  ```
- Add new error variant to `ResearchError`:
  ```rust
  #[error("Invalid arguments: {0}")]
  InvalidArguments(String),
  ```

**Acceptance Criteria:**
- [ ] File `lib/src/lib.rs` updated with new signature
- [ ] `grep "pub async fn research" lib/src/lib.rs | grep "skill_only: bool"` succeeds
- [ ] `grep "pub async fn research" lib/src/lib.rs | grep "force: bool"` succeeds
- [ ] `grep "ResearchError::InvalidArguments" lib/src/lib.rs` succeeds
- [ ] `cargo test --lib` runs 10+ tests
- [ ] All existing tests still pass with default `false, false` arguments

---

### Phase 3: Implement `--skill` Flag Logic

**Principal Owner:** Rust Developer

**Goal:** Implement the skill regeneration workflow that removes existing skill files and regenerates SKILL.md from research documents.

**Dependencies:** Phase 2 complete

**Blast Radius:** `cargo test --lib`

**Deliverables:**
- New function `handle_skill_regeneration()` in `lib/src/lib.rs`
- Logic to validate all required files exist
- Logic to remove skill/* contents while preserving directory
- Integration with Phase 2 SKILL.md synthesis prompt
- Error messages for missing preconditions

**Technical Details:**
- Create new function in `lib/src/lib.rs`:
  ```rust
  async fn handle_skill_regeneration(
      topic: &str,
      output_dir: Option<PathBuf>,
  ) -> Result<ResearchResult, ResearchError> {
      let output_dir = output_dir.unwrap_or_else(|| default_output_dir(topic));

      // Validate all Phase 1 research files exist
      let missing_prompts = check_missing_standard_prompts(&output_dir).await;
      if !missing_prompts.is_empty() {
          return Err(ResearchError::InvalidArguments(format!(
              "Cannot regenerate skill: missing {} research file(s). Run without --skill first.",
              missing_prompts.len()
          )));
      }

      // Validate final outputs exist (need them for context)
      let missing_outputs = check_missing_outputs(&output_dir).await;
      if !missing_outputs.is_empty() {
          return Err(ResearchError::InvalidArguments(format!(
              "Cannot regenerate skill: missing {} output file(s). Run without --skill first.",
              missing_outputs.len()
          )));
      }

      // Remove skill/* contents but preserve directory
      let skill_dir = output_dir.join("skill");
      if skill_dir.exists() {
          remove_directory_contents(&skill_dir).await?;
          info!("Removed existing skill files from {:?}", skill_dir);
      } else {
          fs::create_dir_all(&skill_dir).await?;
      }

      // Run only the SKILL.md synthesis (Phase 2a subset)
      let start = Instant::now();
      let result = generate_skill_only(topic, &output_dir).await?;

      Ok(ResearchResult {
          topic: topic.to_string(),
          output_dir,
          total_time_secs: start.elapsed().as_secs_f64(),
          succeeded: result.succeeded,
          failed: result.failed,
          cancelled: false,
          total_tokens: result.total_tokens,
          total_input_tokens: result.total_input_tokens,
          total_output_tokens: result.total_output_tokens,
      })
  }

  async fn remove_directory_contents(dir: &PathBuf) -> Result<(), ResearchError> {
      let mut entries = fs::read_dir(dir).await?;
      while let Some(entry) = entries.next_entry().await? {
          let path = entry.path();
          // Use symlink_metadata to avoid following symlinks
          let metadata = fs::symlink_metadata(&path).await?;

          if metadata.is_symlink() {
              // Remove symlink itself, don't follow
              fs::remove_file(&path).await?;
          } else if metadata.is_dir() {
              fs::remove_dir_all(&path).await?;
          } else {
              fs::remove_file(&path).await?;
          }
      }
      Ok(())
  }

  async fn generate_skill_only(
      topic: &str,
      output_dir: &PathBuf,
  ) -> Result<PhaseResult, ResearchError> {
      // Similar to existing Phase 2 logic but ONLY generate SKILL.md
      // Reuse existing skill synthesis prompt and agent setup
      info!("Generating SKILL.md from existing research");

      // Read all Phase 1 research files for context
      let context = build_research_context(output_dir).await?;

      // Run SKILL.md synthesis
      let skill_result = synthesize_skill(topic, &context, output_dir).await?;

      // Validate frontmatter
      validate_skill_frontmatter(&output_dir.join("skill/SKILL.md")).await?;

      Ok(skill_result)
  }
  ```

**Acceptance Criteria:**
- [ ] File `lib/src/lib.rs` contains `async fn handle_skill_regeneration` (>50 lines)
- [ ] File `lib/src/lib.rs` contains `async fn remove_directory_contents` with symlink_metadata
- [ ] File `lib/src/lib.rs` contains `async fn generate_skill_only`
- [ ] `grep "symlink_metadata" lib/src/lib.rs` succeeds (verify symlink safety)
- [ ] `cargo test skill_regeneration` runs 5+ tests
- [ ] Test: skill regeneration fails if Phase 1 files missing
- [ ] Test: skill regeneration fails if output files missing
- [ ] Test: skill regeneration preserves skill/ directory
- [ ] Test: skill regeneration removes existing files in skill/
- [ ] Test: skill regeneration creates valid SKILL.md
- [ ] Test: skill regeneration with existing symlinks preserves them
- [ ] Test: rollback to original state if synthesis fails

---

### Phase 4: Implement `--force` Flag Logic

**Principal Owner:** Rust Architect

**Goal:** Implement the force regeneration workflow that skips Phase 1 research and only re-runs Phase 2 synthesis.

**Dependencies:** Phase 2 complete

**Blast Radius:** `cargo test --lib`

**Deliverables:**
- Modified Phase 1 execution to skip when `force=true`
- Modified Phase 2 execution to always run when `force=true`
- Updated metadata handling for forced regeneration
- Validation that Phase 1 research exists before force regeneration

**Technical Details:**
- Modify main `research()` function logic:
  ```rust
  pub async fn research(
      topic: &str,
      output_dir: Option<PathBuf>,
      questions: &[String],
      skill_only: bool,
      force: bool,
  ) -> Result<ResearchResult, ResearchError> {
      // ... existing validation ...

      if skill_only {
          return handle_skill_regeneration(topic, output_dir).await;
      }

      let output_dir = output_dir.unwrap_or_else(|| default_output_dir(topic));
      fs::create_dir_all(&output_dir).await?;

      // Check for existing research
      let existing_metadata = ResearchMetadata::load(&output_dir).await;

      // Phase 1: Research (skip if force=true)
      if force {
          // Validate Phase 1 research exists
          let missing_prompts = check_missing_standard_prompts(&output_dir).await;
          if !missing_prompts.is_empty() {
              return Err(ResearchError::InvalidArguments(format!(
                  "Cannot force regeneration: missing {} research file(s). Run without --force first.",
                  missing_prompts.len()
              )));
          }
          info!("Skipping Phase 1 research (--force mode)");
      } else {
          // Run Phase 1 as normal (existing logic)
          run_phase_1_research(topic, &output_dir, questions, existing_metadata.as_ref()).await?;
      }

      // Phase 2: Synthesis (always run in force mode)
      run_phase_2_synthesis(topic, &output_dir, force).await?;

      // ... rest of function ...
  }
  ```
- Refactor existing code into `run_phase_1_research()` and `run_phase_2_synthesis()` functions
- Function signatures with cancellation and metadata flow:
  ```rust
  async fn run_phase_1_research(
      topic: &str,
      output_dir: &PathBuf,
      questions: &[String],
      existing_metadata: Option<&ResearchMetadata>,
      cancelled: Arc<AtomicBool>,
  ) -> Result<Phase1Result, ResearchError> {
      // Run research prompts with web search/scraping tools
      // Returns: succeeded count, failed count, total metrics, was_cancelled
  }

  async fn run_phase_2_synthesis(
      topic: &str,
      output_dir: &PathBuf,
      force: bool,
      cancelled: Arc<AtomicBool>,
  ) -> Result<Phase2Result, ResearchError> {
      // Use temp directory pattern for atomic writes
      if force {
          info!("Regenerating outputs with atomic writes (--force mode)");
          let temp_dir = output_dir.join(".tmp_synthesis");
          fs::create_dir_all(&temp_dir).await?;

          // Generate outputs to temp_dir (SKILL.md, deep_dive.md, brief.md)
          generate_outputs_to_temp(&temp_dir, topic, cancelled).await?;

          // Only if all succeed, atomically move to final location
          for file in ["skill/SKILL.md", "deep_dive.md", "brief.md"] {
              let src = temp_dir.join(file);
              let dest = output_dir.join(file);
              if src.exists() {
                  // Create parent dir if needed (for skill/SKILL.md)
                  if let Some(parent) = dest.parent() {
                      fs::create_dir_all(parent).await?;
                  }
                  fs::rename(src, dest).await?;
              }
          }
          fs::remove_dir_all(&temp_dir).await?;
      } else {
          // Run synthesis prompts normally (existing logic)
          // ...
      }

      Ok(Phase2Result { /* ... */ })
  }
  ```

**Acceptance Criteria:**
- [ ] File `lib/src/lib.rs` contains `async fn run_phase_1_research` with specified signature
- [ ] File `lib/src/lib.rs` contains `async fn run_phase_2_synthesis` with atomic writes
- [ ] `grep "Skipping Phase 1 research" lib/src/lib.rs` succeeds
- [ ] `grep "tmp_synthesis" lib/src/lib.rs` succeeds (verify temp directory pattern)
- [ ] `cargo test force_regeneration` runs 5+ tests
- [ ] Test: force mode fails if Phase 1 files missing
- [ ] Test: force mode skips Phase 1 research prompts
- [ ] Test: force mode uses atomic writes (temp directory)
- [ ] Test: force mode regenerates all outputs
- [ ] Test: force mode doesn't break incremental mode
- [ ] Test: force mode rollback if synthesis fails mid-way
- [ ] Integration test: full workflow with --force produces valid outputs
- [ ] Unit tests for run_phase_1_research() in isolation
- [ ] Unit tests for run_phase_2_synthesis() in isolation

---

### Phase 5: Testing and Documentation

**Principal Owner:** Feature Tester (Rust)

**Goal:** Comprehensive testing of both flags and update command documentation.

**Dependencies:** Phases 3 and 4 complete

**Blast Radius:** `cargo test`

**Deliverables:**
- Unit tests for skill regeneration logic
- Unit tests for force regeneration logic
- Integration tests for CLI flag handling
- Property tests for file system operations (skill/* preservation)
- Updated docs/commands/library.md with implementation details

**Technical Details:**
- Create `lib/tests/skill_flag_test.rs`:
  ```rust
  #[tokio::test]
  async fn test_skill_flag_requires_complete_research() { ... }

  #[tokio::test]
  async fn test_skill_flag_preserves_directory() { ... }

  #[tokio::test]
  async fn test_skill_flag_removes_contents() { ... }

  #[tokio::test]
  async fn test_skill_flag_regenerates_valid_frontmatter() { ... }

  #[tokio::test]
  async fn test_skill_flag_preserves_symlinks() { ... }

  #[tokio::test]
  async fn test_skill_flag_rollback_on_failure() { ... }
  ```
- Create `lib/tests/force_flag_test.rs`:
  ```rust
  #[tokio::test]
  async fn test_force_flag_skips_phase_1() { ... }

  #[tokio::test]
  async fn test_force_flag_requires_research_files() { ... }

  #[tokio::test]
  async fn test_force_flag_uses_atomic_writes() { ... }

  #[tokio::test]
  async fn test_force_flag_regenerates_all_outputs() { ... }

  #[tokio::test]
  async fn test_force_flag_rollback_on_synthesis_failure() { ... }
  ```
- Create `lib/tests/skill_flag_proptest.rs`:
  ```rust
  use proptest::prelude::*;

  proptest! {
      #[test]
      fn prop_skill_directory_exists_after_regeneration(
          file_count in 1..20usize
      ) {
          // Property: skill/ directory always exists after regeneration
      }

      #[test]
      fn prop_symlinks_remain_valid(
          symlink_count in 0..10usize
      ) {
          // Property: all symlinks pointing to skill/ remain valid after regeneration
      }
  }
  ```
- Add integration test in `lib/tests/library_integration_test.rs`:
  ```rust
  #[tokio::test]
  async fn test_skill_and_force_mutually_exclusive() { ... }

  #[tokio::test]
  #[serial]
  async fn test_full_workflow_with_force() { ... }

  #[tokio::test]
  #[serial]
  async fn test_full_workflow_with_skill() { ... }

  #[tokio::test]
  #[serial]
  async fn test_concurrent_skill_regeneration() { ... }
  ```
- Update documentation with implementation status

**Acceptance Criteria:**
- [ ] File `lib/tests/skill_flag_test.rs` exists with 6+ tests (including symlink and rollback tests)
- [ ] File `lib/tests/force_flag_test.rs` exists with 5+ tests (including atomic writes test)
- [ ] File `lib/tests/skill_flag_proptest.rs` exists with 2+ property tests
- [ ] File `lib/tests/library_integration_test.rs` has 4+ new tests (including concurrent test)
- [ ] `cargo test skill_flag` passes
- [ ] `cargo test force_flag` passes
- [ ] `cargo test` (full suite) passes
- [ ] `cargo test` runs 35+ tests total (increased from 30 for new test categories)
- [ ] Specific coverage targets:
  - [ ] `handle_skill_regeneration()`: 100% line coverage
  - [ ] `remove_directory_contents()`: 100% line coverage (all error paths)
  - [ ] `generate_skill_only()`: >90% coverage
  - [ ] `run_phase_1_research()`: >80% coverage
  - [ ] `run_phase_2_synthesis()`: >80% coverage
- [ ] Updated docs/commands/library.md reflects implementation

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit Tests:**
  - `#[cfg(test)] mod tests` in `lib/src/lib.rs` for helper functions
  - Validate error handling for invalid flag combinations
  - Test file system operations (directory preservation, content removal)

- **Integration Tests:**
  - `tests/skill_flag_test.rs` - Full skill regeneration workflow
  - `tests/force_flag_test.rs` - Full force regeneration workflow
  - `tests/library_integration_test.rs` - CLI flag parsing and end-to-end flows

- **Property-Based Tests (proptest):**
  - Symbolic links remain valid after skill/* regeneration
  - File counts match expectations after regeneration
  - Metadata consistency after forced regeneration
  - skill/ directory always exists after regeneration

- **Mocking Strategy (for unit tests):**
  - Mock LLM calls (`synthesize_skill()`) to avoid API costs in tests
  - Use tempfile::TempDir for isolated file system tests
  - Mock file system operations for permission error tests

### Security Considerations

- **File System Safety:**
  - Validate paths stay within output directory (prevent traversal)
  - Use temp directory pattern with atomic rename (avoid partial states)
  - Use `symlink_metadata` instead of `metadata` to avoid following symlinks
  - Preserve symbolic links (don't follow when removing directory)
  - Validate all paths are canonical and within output_dir boundary

### Performance Considerations

- **Token Usage:**
  - `--skill` mode: ~90% token savings (only SKILL.md synthesis)
  - `--force` mode: ~80% token savings (skip web search/scrape)
  - Reuse existing file reads (cache Phase 1 content in memory)

- **File System:**
  - Async file operations (tokio::fs) for non-blocking I/O
  - Batch file removals to minimize syscalls
  - Stream directory reads for large skill directories

### Error Handling

- **User-Facing Errors (thiserror):**
  - Clear messages when preconditions not met
  - Suggest corrective actions (e.g., "Run without --skill first")
  - List missing files for debugging

- **Graceful Degradation:**
  - If skill/* removal fails, report error but don't crash
  - If frontmatter validation fails, warn but complete regeneration
  - Preserve original files if synthesis fails mid-way

### Logging (tracing)

- **Info Level:**
  - "Skipping Phase 1 research (--force mode)"
  - "Removing existing skill files from {path}"
  - "Generating SKILL.md from existing research"
  - "Regenerating outputs with atomic writes (--force mode)"

- **Debug Level:**
  - File paths being removed/created
  - Synthesis prompt token counts
  - Metadata updates
  - Temp directory operations

- **Warn Level:**
  - Invalid frontmatter during regeneration
  - Missing optional files

- **Instrumentation:**
  - Add `#[instrument(skip(output_dir))]` to `handle_skill_regeneration`
  - Add `#[instrument(skip(output_dir))]` to `run_phase_1_research`
  - Add `#[instrument(skip(output_dir))]` to `run_phase_2_synthesis`
  - Add `#[instrument]` to `remove_directory_contents`
  - Add `#[instrument]` to `generate_skill_only`

## Parallelization Opportunities

This implementation is primarily sequential, but testing can be parallelized:

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1, Phase 2 | Independent CLI and library changes (can develop in parallel) |
| Group B | Phase 3, Phase 4 | Independent feature implementations (different code paths) |
| Group C | Phase 5 | Depends on all previous phases |

**Recommendation:** Implement Phases 1+2 together (single PR), then Phases 3+4 in parallel (two PRs), then Phase 5 (final PR).

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Symbolic links broken during skill/* regeneration | High | Use remove_file/remove_dir instead of following symlinks; add property test |
| Partial regeneration leaves incomplete state | Medium | Validate all inputs before modifying filesystem; use temp directory pattern |
| Metadata inconsistency after forced regeneration | Medium | Update metadata.json after successful regeneration; add validation tests |
| User confusion about flag purposes | Low | Clear help text; mutually exclusive validation; good error messages |
| Phase 1 research files accidentally deleted | High | Never delete Phase 1 files; only remove Phase 2 outputs in force mode |

## Open Questions

- [x] Should `--skill` regenerate supporting docs in skill/* or just SKILL.md? **Decision:** Regenerate all skill/* contents (SKILL.md may reference supporting files)
- [x] Should `--force` update metadata.json timestamps? **Decision:** Yes, update `updated_at` timestamp
- [x] How should brief.md be handled? **Resolution:** Current code doesn't generate brief.md in Phase 2 (not in lines 2671-2694), so removed from plan scope
- [ ] Should there be a `--dry-run` flag to preview what would be regenerated? **Recommendation:** Add in Phase 1 if planning future extension
- [ ] Should we add a `--validate` flag to check frontmatter without regenerating? **Recommendation:** Defer to future enhancement

## Implementation Notes

### Regarding brief.md
The plan originally mentioned brief.md as a Phase 2 output, but review of the current codebase (lib/src/lib.rs lines 2671-2694) shows that only SKILL.md and deep_dive.md are generated in Phase 2. Brief.md generation should be verified during implementation:
- If brief.md exists in current workflow, include in --force regeneration
- If brief.md doesn't exist, remove from plan and only regenerate SKILL.md + deep_dive.md

### Regarding Phase 1/Phase 2 Boundaries
The refactoring in Phase 4 assumes clear boundaries exist in the current code. During implementation, verify:
- Where Phase 1 research prompts start/end
- Where Phase 2 synthesis prompts start/end
- How cancellation flows through both phases
- How metadata is updated after each phase

If boundaries are unclear, consider extracting helper functions incrementally rather than large refactoring.
