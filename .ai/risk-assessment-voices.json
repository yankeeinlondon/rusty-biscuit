[
  {
    "category": "dependency",
    "level": "high",
    "description": "Windows crate COM interfaces for SAPI are complex and require correct lifecycle management. Incorrect COM initialization/cleanup can cause resource leaks and crashes. RAII patterns must be perfect.",
    "affected_phases": ["3"],
    "mitigation": "Use windows-rs official examples as templates. Implement comprehensive tests on Windows environment. Create RAII wrapper struct for COM context. Add CI/CD testing on Windows runners.",
    "contingency": "Fall back to PowerShell-based SAPI access (PowerShell.exe as subprocess) instead of direct COM. This sacrifices performance but is safer and more portable."
  },
  {
    "category": "technical",
    "level": "high",
    "description": "SAPI registry paths differ between OneCore voices (Speech_OneCore) and standard SAPI5 voices (Speech). OneCore voices may not be accessible via standard COM interfaces without registry override. Incomplete enumeration risk.",
    "affected_phases": ["3"],
    "mitigation": "Enumerate from both registry paths separately: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech and HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech_OneCore. Document why dual paths are needed. Test on Windows with both types of voices installed.",
    "contingency": "Exclude OneCore voices from initial implementation. Focus only on standard SAPI5 voices (HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech). Add OneCore support in Phase 2."
  },
  {
    "category": "dependency",
    "level": "medium",
    "description": "gender_guesser crate may not be maintained or may have accuracy issues with non-English names. Inaccurate gender inference could frustrate users requesting gender-specific voices.",
    "affected_phases": ["1", "2", "3", "4", "6", "7"],
    "mitigation": "Evaluate gender_guesser accuracy before integration. Use explicit gender metadata first, fall back to gender_guesser. Create test fixtures with diverse names to validate accuracy.",
    "contingency": "Implement a simple hardcoded name-to-gender map for common voice names. Default to Unknown gender for edge cases. Users can override gender in voice config if incorrect."
  },
  {
    "category": "scope",
    "level": "high",
    "description": "eSpeak/echogarden/kokoro-tts voice outputs have varying formats (space-separated, blank-line separated, numbered lists). Parser failures for edge cases (unusual names, special characters) could silently drop voices.",
    "affected_phases": ["2", "4", "6"],
    "mitigation": "Create comprehensive parsers with detailed error logging. Add unit tests for each parser with sample CLI outputs. Implement defensive parsing with clear error messages. Test with real CLI output, not just examples.",
    "contingency": "Wrap external CLI calls with timeout and fallback defaults. If parsing fails, log warning and skip voice. Never panic or fail entire provider."
  },
  {
    "category": "technical",
    "level": "medium",
    "description": "gTTS requires network connectivity and Google may rate-limit or block requests. is_ready() must check internet connectivity, adding external dependency on network detection library or external ping service.",
    "affected_phases": ["4"],
    "mitigation": "Use reqwest::Client with timeout for connectivity check (HEAD request to reliable endpoint like 8.8.8.8 or Google DNS). Cache connectivity status for 5 minutes. Add fallback to offline-only providers if gTTS unavailable.",
    "contingency": "Skip gTTS from provider list if connectivity check fails. Document that gTTS requires network. Add --offline flag to so-you-say CLI to exclude cloud providers."
  },
  {
    "category": "dependency",
    "level": "medium",
    "description": "dirs crate version conflict: biscuit-speaks needs to set ~/.biscuit-speaks-cache, but workspace already uses dirs 5.0 (research, sniff) and 6.0 (queue). Adding new dependency could introduce version incompatibility.",
    "affected_phases": ["5"],
    "mitigation": "Use same dirs version across biscuit-speaks. If conflicting, add to workspace-level dependency override in root Cargo.toml. Test cache location works on macOS, Linux, Windows.",
    "contingency": "Use std::env::home_dir() fallback. Hardcode $HOME/.biscuit-speaks-cache path. This works but is less reliable than dirs crate."
  },
  {
    "category": "scope",
    "level": "medium",
    "description": "Cache invalidation has no auto-detection of new voices. If user installs new voices, cache must be explicitly busted with --force flag. Users may not know to use --force and get stale voice lists.",
    "affected_phases": ["5"],
    "mitigation": "Implement cache versioning: store timestamp of last scan. Auto-bust cache if provider binary mtime changed. Add CLI warning if cache is >24h old. Document --force flag prominently.",
    "contingency": "Don't implement cache versioning. Always require explicit --force. Accept that cache will be stale in some cases. Add prominent warning in docs that users must use --force after installing new voices."
  },
  {
    "category": "technical",
    "level": "high",
    "description": "Kokoro-tts outputs WAV files (not direct playback) and requires tempfile handling. Voice name parsing relies on strict prefix format (region+gender chars). Tempfile cleanup failures could fill disk with stale WAV files.",
    "affected_phases": ["6"],
    "mitigation": "Use tempfile::NamedTempFile with automatic cleanup (RAII). Test prefix parsing with malformed voice names. Add tests for tempfile cleanup in error scenarios. Implement fallback audio cleanup on panic.",
    "contingency": "Don't implement kokoro-tts speaker in Phase 1. Add in Phase 2 after tempfile infrastructure is stable. For now, skip kokoro in voice enumeration."
  },
  {
    "category": "scope",
    "level": "high",
    "description": "Eight providers to implement with different quirks (7 existing + Kokoro) creates large testing surface. Each provider has different voice metadata availability and quality inference logic. Testing gaps could leave providers silently broken.",
    "affected_phases": ["1", "2", "3", "4", "5", "6", "7"],
    "mitigation": "Create exhaustive test fixtures for each provider with sample CLI outputs. Implement provider-specific integration tests. Test voice enumeration on each supported OS (macOS for say, Linux for espeak, Windows for SAPI). Use CI matrix.",
    "contingency": "Defer providers to separate phases. Phase 1: say + eSpeak. Phase 2: ElevenLabs + echogarden. Phase 3: SAPI + gTTS. Phase 4: Kokoro. Spread implementation work over 4 phases."
  },
  {
    "category": "technical",
    "level": "medium",
    "description": "Language code mapping differs across providers: LCID hex (Windows SAPI), BCP-47 (echogarden), prefixes (kokoro). Inconsistent language code handling could cause voice matching failures when user specifies language.",
    "affected_phases": ["3", "5", "6"],
    "mitigation": "Normalize all language codes to BCP-47 format internally. Create conversion functions LCID → BCP-47, kokoro prefix → BCP-47, etc. Add tests for language code round-tripping.",
    "contingency": "Store raw provider language codes in Voice struct. Convert to BCP-47 only when needed for matching. Accept that language matching may be imperfect across providers."
  },
  {
    "category": "rollback",
    "level": "high",
    "description": "Trait expansion (TtsExecutor adds is_ready(), list_voices(), info(), available_voices(), download_voice()) breaks existing provider implementations. All 2+ existing providers must be updated or code won't compile.",
    "affected_phases": ["1"],
    "mitigation": "Implement trait changes as new optional methods with default implementations using `default()` pattern. Update existing say.rs and elevenlabs.rs providers incrementally. Keep tests passing at each step.",
    "contingency": "Create new trait TtsVoiceExecutor separate from TtsExecutor. Implement on new providers. Keep TtsExecutor unchanged for backward compatibility. Migrate old providers in separate PR."
  },
  {
    "category": "scope",
    "level": "medium",
    "description": "DownloadableVoice trait implementation requires enum per provider (Kokoro, echogarden voices are downloadable; say, eSpeak are not). Handling None case with NoDownloadableVoice enum complicates API.",
    "affected_phases": ["1", "2", "6"],
    "mitigation": "Use Option<Box<dyn DownloadableVoice>> pattern. For providers without downloads, return None. Document which providers support downloads. Add tests for download_voice() call on non-downloadable provider.",
    "contingency": "Make download_voice() optional method in trait with default panic(). Document which providers support it. Users call only on providers they know support downloads."
  },
  {
    "category": "technical",
    "level": "medium",
    "description": "Quality inference heuristics (say: Enhanced=Good, eSpeak=Low, echogarden: kokoro=Excellent, vits-high=Good) are subjective. Users may disagree with quality assignments, creating support burden.",
    "affected_phases": ["1", "2", "4", "5", "6"],
    "mitigation": "Document quality assignment logic in code comments. Make quality configurable via provider options. Add CLI flag to override quality for testing. Collect user feedback on accuracy.",
    "contingency": "Assign Unknown quality to all voices initially. Let users manually rate voices. Build crowdsourced quality map over time. Accept that quality is subjective."
  },
  {
    "category": "dependency",
    "level": "low",
    "description": "serde/serde_json already present in workspace (shared lib). No new dependency. Cache serialization will use existing stack.",
    "affected_phases": ["5"],
    "mitigation": "No action needed. Use existing serde for HostTtsCapabilities serialization.",
    "contingency": "N/A - low risk, existing dependency"
  },
  {
    "category": "technical",
    "level": "medium",
    "description": "CLI external programs (say, espeak, gtts-cli, echogarden, kokoro-tts) may not be in PATH or may have different names/paths on different systems. Executable discovery must be robust.",
    "affected_phases": ["1", "2", "3", "4", "5", "6"],
    "mitigation": "Use `which` crate (already in biscuit-speaks) to find executables. Check common alternative names (espeak-ng, espeak; gtts-cli, gtts). Add detailed error messages showing search paths.",
    "contingency": "Hard-code common paths (/usr/bin/, /opt/, C:\\Program Files\\). Fall back to PATH search. Document where each provider should be installed."
  },
  {
    "category": "scope",
    "level": "medium",
    "description": "Voice struct fields (name, gender, quality, languages) must be immutable once created. If voice detection logic changes, old cached voices become stale. Cache versioning overhead.",
    "affected_phases": ["5"],
    "mitigation": "Add schema_version field to HostTtsCapabilities cache. Increment version when Voice struct changes. Auto-bust cache on version mismatch. Document cache format.",
    "contingency": "Don't version cache. Always use --force on upgrade. Accept that users may see stale voices after updates."
  },
  {
    "category": "technical",
    "level": "low",
    "description": "macOS Say voice names can contain spaces and parentheses (e.g., 'Aman (English (India))'). Parser must handle unusual voice names correctly without truncation.",
    "affected_phases": ["1"],
    "mitigation": "Parse say -v '?' output by splitting on ' # ' marker first (separates metadata from sample text). Then extract locale from right side of metadata. Treat everything left of locale as voice name.",
    "contingency": "Use regex with lookahead instead of simple split. More robust against edge cases."
  },
  {
    "category": "scope",
    "level": "high",
    "description": "Integration test gaps: Can't test Windows SAPI on macOS/Linux. Can't test say on Linux. Cross-platform provider testing requires multiple OS environments. CI matrix complexity.",
    "affected_phases": ["1", "2", "3", "4", "5", "6"],
    "mitigation": "Set up GitHub Actions CI matrix with macos-latest, ubuntu-latest, windows-latest. Skip platform-specific tests on unsupported OS. Use conditional compilation with #[cfg(target_os = ...)]. Mock subprocess for portable tests.",
    "contingency": "Accept that some providers can't be tested on all platforms. Document tested platforms per provider. Manual QA on each platform before release."
  },
  {
    "category": "technical",
    "level": "medium",
    "description": "ElevenLabs provider already exists but may not implement new trait methods (is_ready, list_voices, etc.). Updating it to match new trait could break existing Speak usage.",
    "affected_phases": ["1"],
    "mitigation": "Audit existing ElevenLabs provider before trait expansion. Add list_voices() to return hardcoded voice list from ElevenLabs API. Test that existing speak() still works after updates.",
    "contingency": "Create wrapper TtsExecutor2 trait with new methods. Keep TtsExecutor unchanged. Implement adapters to convert between traits. Migrate in separate PR."
  }
]
