# Playa Audio Providers Implementation Plan

**Date:** 2026-01-26
**Status:** Done
**Scope:** Implement playback support for all 8 unimplemented audio providers

## Current State

The `playa` library defines 11 audio providers but only 3 have playback implementations:

| Provider | Status | Binary |
|----------|--------|--------|
| mpv | ✅ Implemented | `mpv` |
| FFplay | ✅ Implemented | `ffplay` |
| aplay (ALSA) | ✅ Implemented | `aplay` |
| VLC | ❌ Not implemented | `cvlc` |
| MPlayer | ❌ Not implemented | `mplayer` |
| GStreamer | ❌ Not implemented | `gst-play-1.0` |
| SoX | ❌ Not implemented | `play` |
| mpg123 | ❌ Not implemented | `mpg123` |
| ogg123 | ❌ Not implemented | `ogg123` |
| paplay | ❌ Not implemented | `paplay` |
| pw-play | ❌ Not implemented | `pw-play` |

**Files to modify:**
- `playa/lib/src/player.rs` - Enhance selection algorithm with capability scoring
- `playa/lib/src/playback.rs` - Add playback implementations with volume/speed support
- `playa/lib/src/types.rs` - Add `PlaybackOptions` struct
- `playa/lib/src/audio.rs` - Add `play_with_options()` method and capability-aware selection
- `playa/lib/src/error.rs` - Add `NoPlayerWithCapabilities` error variant
- `playa/cli/src/main.rs` - Add CLI switches (`--fast`, `--slow`, `--quiet`, `--loud`, `--speed`, `--volume`)

---

## Provider Selection Algorithm

### Current Behavior

The current `player_score()` function in `player.rs` ranks players by:
1. Stream input support (1 point if true)
2. Number of supported formats
3. Number of supported codecs

This results in full-featured players (mpv, FFplay, VLC) ranking highest, but ignores volume/speed control capabilities.

### Enhanced Selection Criteria

Players should be prioritized based on **controllability** in addition to compatibility:

| Capability | Points | Rationale |
|------------|:------:|-----------|
| Supports required codec | Required | Filter, not score |
| Supports required format | Required | Filter, not score |
| Speed control | +4 | Highest value for TTS use cases |
| Volume control | +3 | Common requirement |
| Stream input | +2 | Enables piping without disk I/O |
| Format breadth | +1 per format | Flexibility bonus |

### Capability Matrix

| Player | Speed | Volume | Stream In | Priority Tier |
|--------|:-----:|:------:|:---------:|:-------------:|
| mpv | ✅ (+4) | ✅ (+3) | ✅ (+2) | **Tier 1** (9+) |
| FFplay | ✅ (+4) | ✅ (+3) | ✅ (+2) | **Tier 1** (9+) |
| SoX | ✅ (+4) | ✅ (+3) | ✅ (+2) | **Tier 1** (9+) |
| VLC | ❌ | ✅ (+3) | ✅ (+2) | **Tier 2** (5-8) |
| MPlayer | ❌ | ✅ (+3) | ✅ (+2) | **Tier 2** (5-8) |
| GStreamer | ❌ | ✅ (+3) | ✅ (+2) | **Tier 2** (5-8) |
| paplay | ❌ | ✅ (+3) | ❌ | **Tier 3** (1-4) |
| pw-play | ❌ | ✅ (+3) | ❌ | **Tier 3** (1-4) |
| mpg123 | ❌ | ❌ | ✅ (+2) | **Tier 3** (1-4) |
| ogg123 | ❌ | ❌ | ✅ (+2) | **Tier 3** (1-4) |
| aplay | ❌ | ❌ | ❌ | **Tier 4** (0) |

### Data Model Changes

Add capability flags to the `Player` struct in `player.rs`:

```rust
/// Extended metadata for audio players beyond what Sniff provides.
#[derive(Debug, Clone, Copy)]
pub struct Player {
    /// The player identifier.
    pub id: AudioPlayer,
    /// Reference to Sniff's program enum for detection.
    pub sniff_program: HeadlessAudio,
    /// Codecs this player can decode.
    pub supported_codecs: &'static [Codec],
    /// File containers this player can read.
    pub supported_formats: &'static [AudioFileFormat],
    /// Can accept audio from stdin or URLs.
    pub takes_stream_input: bool,
    /// Can output audio over network (e.g., Icecast).
    pub supplies_stream_output: bool,
    /// Whether the player is open source.
    pub is_open_source: bool,
    /// CPU/memory usage classification.
    pub resource_usage: ResourceUsage,
    // NEW FIELDS
    /// Supports playback speed/tempo control via CLI.
    pub supports_speed_control: bool,
    /// Supports volume control via CLI.
    pub supports_volume_control: bool,
}
```

### Updated Scoring Function

Replace `player_score()` with capability-aware scoring:

```rust
/// Score a player based on capabilities.
/// Higher scores = more capable players.
/// Returns (capability_score, format_count, codec_count) for comparison.
fn player_score(player: AudioPlayer) -> (u8, usize, usize) {
    let Some(metadata) = PLAYER_LOOKUP.get(&player) else {
        return (0, 0, 0);
    };

    let mut capability_score: u8 = 0;

    // Speed control is most valuable (TTS use case)
    if metadata.supports_speed_control {
        capability_score += 4;
    }

    // Volume control is commonly needed
    if metadata.supports_volume_control {
        capability_score += 3;
    }

    // Stream input enables efficient piping
    if metadata.takes_stream_input {
        capability_score += 2;
    }

    let format_count = metadata.supported_formats.len();
    let codec_count = metadata.supported_codecs.len();

    (capability_score, format_count, codec_count)
}
```

### Selection Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    Player Selection                          │
├─────────────────────────────────────────────────────────────┤
│  1. Filter: Supports required file format?                   │
│     └─ No  → Exclude                                         │
│     └─ Yes → Continue                                        │
│                                                              │
│  2. Filter: Supports required codec (if specified)?          │
│     └─ No  → Exclude                                         │
│     └─ Yes → Continue                                        │
│                                                              │
│  3. Filter: Is installed on system?                          │
│     └─ No  → Exclude                                         │
│     └─ Yes → Add to candidates                               │
│                                                              │
│  4. Score candidates:                                        │
│     └─ +4 for speed control                                  │
│     └─ +3 for volume control                                 │
│     └─ +2 for stream input                                   │
│     └─ Tiebreaker: format count, codec count, definition order│
│                                                              │
│  5. Return sorted list (highest score first)                 │
└─────────────────────────────────────────────────────────────┘
```

### Expected Selection Results

For MP3 playback with all players installed:

| Rank | Player | Score | Rationale |
|:----:|--------|:-----:|-----------|
| 1 | mpv | 9 | Speed + Volume + Stream + 7 formats |
| 2 | FFplay | 9 | Speed + Volume + Stream + 7 formats |
| 3 | SoX | 9 | Speed + Volume + Stream + 4 formats |
| 4 | VLC | 5 | Volume + Stream + 7 formats |
| 5 | MPlayer | 5 | Volume + Stream + 7 formats |
| 6 | GStreamer | 5 | Volume + Stream + 7 formats |
| 7 | mpg123 | 2 | Stream only + 1 format |

For WAV playback with Linux audio subsystem:

| Rank | Player | Score | Rationale |
|:----:|--------|:-----:|-----------|
| 1 | mpv | 9 | Speed + Volume + Stream |
| 2 | FFplay | 9 | Speed + Volume + Stream |
| 3 | SoX | 9 | Speed + Volume + Stream |
| 4 | paplay | 3 | Volume only |
| 5 | pw-play | 3 | Volume only |
| 6 | aplay | 0 | No controllability |

---

## Implementation Details

### Phase 1: Core Media Players (High Priority)

These are full-featured, cross-platform players with broad codec support.

#### 1.1 VLC (cvlc)

**CLI Pattern:**
```bash
cvlc --quiet --play-and-exit <source>
```

**Implementation:**
```rust
AudioPlayer::Vlc => {
    command
        .arg("--quiet")
        .arg("--play-and-exit");
    source.apply(&mut command);
}
```

**Notes:**
- `--quiet` suppresses all status output
- `--play-and-exit` ensures process terminates after playback
- Stdin support: `cvlc fd://0` or `cvlc -` (limited, no seeking)

**Testing:**
- [ ] File playback (WAV, MP3, FLAC, OGG)
- [ ] URL playback
- [ ] Verify quiet mode (no console output)
- [ ] Verify auto-exit behavior

---

#### 1.2 MPlayer

**CLI Pattern:**
```bash
mplayer -really-quiet <source>
```

**Implementation:**
```rust
AudioPlayer::MPlayer => {
    command.arg("-really-quiet");
    source.apply(&mut command);
}
```

**Notes:**
- `-really-quiet` is more aggressive than `-quiet`
- Auto-exits by default after playback
- Stdin support: `mplayer -` (disables keyboard input)

**Testing:**
- [ ] File playback (WAV, MP3, FLAC, OGG)
- [ ] URL playback
- [ ] Verify no console output
- [ ] Verify auto-exit behavior

---

#### 1.3 GStreamer (gst-play-1.0)

**CLI Pattern:**
```bash
gst-play-1.0 --quiet <source>
```

**Implementation:**
```rust
AudioPlayer::GstreamerGstPlay => {
    command.arg("--quiet");
    source.apply(&mut command);
}
```

**Notes:**
- `--quiet` or `-q` suppresses output except errors
- Auto-exits by default
- Has `--volume=VOLUME` option (0.0 to 1.0) for future volume control
- Binary may be `gst-play-1.0` or `gst-play` depending on installation

**Testing:**
- [ ] File playback (WAV, MP3, FLAC, OGG)
- [ ] URL playback
- [ ] Verify quiet mode
- [ ] Test with both binary names

---

### Phase 2: Lightweight Specialized Players

These are smaller, format-specific players ideal for resource-constrained environments.

#### 2.1 SoX (play)

**CLI Pattern:**
```bash
play -q <source>
```

**Implementation:**
```rust
AudioPlayer::Sox => {
    command.arg("-q");
    source.apply(&mut command);
}
```

**Notes:**
- `-q` or `--no-show-progress` suppresses progress output
- Auto-exits by default
- Has `-v VOLUME` for amplitude scaling (future volume control)
- Supports `speed` effect for tempo control (would require different invocation)
- Stdin support: `play -`

**Testing:**
- [ ] File playback (WAV, FLAC, OGG, MP3)
- [ ] Verify quiet mode
- [ ] Verify auto-exit behavior

---

#### 2.2 mpg123

**CLI Pattern:**
```bash
mpg123 -q <source>
```

**Implementation:**
```rust
AudioPlayer::Mpg123 => {
    command.arg("-q");
    source.apply(&mut command);
}
```

**Notes:**
- `-q` suppresses diagnostic messages
- Auto-exits by default
- MP3-only player (lightweight)
- No volume/speed CLI options

**Testing:**
- [ ] MP3 file playback
- [ ] URL playback (MP3 streams)
- [ ] Verify quiet mode

---

#### 2.3 ogg123

**CLI Pattern:**
```bash
ogg123 -q <source>
```

**Implementation:**
```rust
AudioPlayer::Ogg123 => {
    command.arg("-q");
    source.apply(&mut command);
}
```

**Notes:**
- `-q` or `--quiet` suppresses all messages
- Auto-exits by default
- **Does NOT support stdin** (known bug/limitation)
- Supports OGG container with Vorbis, Opus, FLAC codecs

**Testing:**
- [ ] OGG file playback (Vorbis, Opus, FLAC)
- [ ] Verify quiet mode
- [ ] Verify stdin is NOT supported (document limitation)

---

### Phase 3: Linux Audio Subsystem Players

These interact directly with Linux audio subsystems and are typically file-only.

#### 3.1 paplay (PulseAudio)

**CLI Pattern:**
```bash
paplay <source>
```

**Implementation:**
```rust
AudioPlayer::PulseaudioPaplay => {
    // paplay has minimal output by default, no quiet flag needed
    source.apply(&mut command);
}
```

**Notes:**
- Minimal output by default (no quiet flag documented)
- Auto-exits by default
- Has `--volume=VOLUME` option (0-65536, where 65536=100%)
- Stdin support: reads from stdin if no file specified
- PCM/WAV only

**Testing:**
- [ ] WAV file playback
- [ ] Verify auto-exit behavior
- [ ] Test on PulseAudio system

---

#### 3.2 pw-play (PipeWire)

**CLI Pattern:**
```bash
pw-play <source>
```

**Implementation:**
```rust
AudioPlayer::Pipewire => {
    // pw-play has minimal output by default
    source.apply(&mut command);
}
```

**Notes:**
- `pw-play` is shorthand for `pw-cat --playback`
- Minimal output by default
- Auto-exits by default
- Has `--volume=VOLUME` option (0.0 to 1.0+)
- Stdin support requires format specification (`--format`, `--channels`, `--rate`)
- WAV and FLAC support

**Testing:**
- [ ] WAV file playback
- [ ] FLAC file playback
- [ ] Verify auto-exit behavior
- [ ] Test on PipeWire system

---

## Implementation Order

Recommended implementation order based on **capability tier** and platform coverage:

| Order | Provider | Tier | Rationale |
|:-----:|----------|:----:|-----------|
| 1 | SoX | 1 | Speed + Volume + Stream, lightweight |
| 2 | VLC | 2 | Volume + Stream, broadest codec support |
| 3 | MPlayer | 2 | Volume + Stream, cross-platform, mature |
| 4 | GStreamer | 2 | Volume + Stream, pipeline flexibility |
| 5 | paplay | 3 | Volume only, Linux PulseAudio integration |
| 6 | pw-play | 3 | Volume only, Linux PipeWire (modern) |
| 7 | mpg123 | 3 | Stream only, MP3 specialist |
| 8 | ogg123 | 3 | Stream only, OGG specialist |

**Note:** mpv, FFplay, and aplay are already implemented. The order above prioritizes implementing players that add the most capability value first.

---

## Code Changes

### Change 1: `playa/lib/src/player.rs` - Data Model & Scoring

#### 1a. Update `Player` struct

Add two new fields after `resource_usage`:

```rust
pub struct Player {
    // ... existing fields ...
    pub resource_usage: ResourceUsage,
    /// Supports playback speed/tempo control via CLI.
    pub supports_speed_control: bool,
    /// Supports volume control via CLI.
    pub supports_volume_control: bool,
}
```

#### 1b. Update `PLAYER_LOOKUP` entries

Add capability flags to each player definition:

```rust
// Tier 1: Full controllability (speed + volume + stream)
map.insert(
    AudioPlayer::Mpv,
    Player {
        // ... existing fields ...
        supports_speed_control: true,   // --speed=N
        supports_volume_control: true,  // --volume=N
    },
);

map.insert(
    AudioPlayer::FfPlay,
    Player {
        // ... existing fields ...
        supports_speed_control: true,   // -af atempo=N
        supports_volume_control: true,  // -volume N
    },
);

map.insert(
    AudioPlayer::Sox,
    Player {
        // ... existing fields ...
        supports_speed_control: true,   // speed effect
        supports_volume_control: true,  // -v N
    },
);

// Tier 2: Volume + stream (no speed)
map.insert(
    AudioPlayer::Vlc,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: true,  // --gain=N (or --volume via config)
    },
);

map.insert(
    AudioPlayer::MPlayer,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: true,  // -softvol -volume N
    },
);

map.insert(
    AudioPlayer::GstreamerGstPlay,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: true,  // --volume=N
    },
);

// Tier 3: Volume only (Linux audio subsystems)
map.insert(
    AudioPlayer::PulseaudioPaplay,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: true,  // --volume=N
    },
);

map.insert(
    AudioPlayer::Pipewire,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: true,  // --volume=N
    },
);

// Tier 3: Stream only (no volume/speed)
map.insert(
    AudioPlayer::Mpg123,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: false,
    },
);

map.insert(
    AudioPlayer::Ogg123,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: false,
    },
);

// Tier 4: No controllability
map.insert(
    AudioPlayer::AlsaAplay,
    Player {
        // ... existing fields ...
        supports_speed_control: false,
        supports_volume_control: false,
    },
);
```

#### 1c. Replace `player_score()` function

```rust
/// Score a player based on capabilities.
/// Higher scores = more capable players (prioritize controllability).
/// Returns (capability_score, format_count, codec_count) for comparison.
fn player_score(player: AudioPlayer) -> (u8, usize, usize) {
    let Some(metadata) = PLAYER_LOOKUP.get(&player) else {
        return (0, 0, 0);
    };

    let mut capability_score: u8 = 0;

    // Speed control is most valuable (TTS use case)
    if metadata.supports_speed_control {
        capability_score += 4;
    }

    // Volume control is commonly needed
    if metadata.supports_volume_control {
        capability_score += 3;
    }

    // Stream input enables efficient piping
    if metadata.takes_stream_input {
        capability_score += 2;
    }

    let format_count = metadata.supported_formats.len();
    let codec_count = metadata.supported_codecs.len();

    (capability_score, format_count, codec_count)
}
```

#### 1d. Add helper methods to `Player`

```rust
impl Player {
    // ... existing methods ...

    /// Check if the player supports speed control.
    pub fn supports_speed(&self) -> bool {
        self.supports_speed_control
    }

    /// Check if the player supports volume control.
    pub fn supports_volume(&self) -> bool {
        self.supports_volume_control
    }

    /// Calculate capability score for ranking.
    pub fn capability_score(&self) -> u8 {
        let mut score: u8 = 0;
        if self.supports_speed_control {
            score += 4;
        }
        if self.supports_volume_control {
            score += 3;
        }
        if self.takes_stream_input {
            score += 2;
        }
        score
    }
}
```

#### 1e. Update tests

```rust
#[test]
fn player_score_prioritizes_controllability() {
    // Tier 1 players should score highest
    let mpv_score = player_score(AudioPlayer::Mpv);
    let sox_score = player_score(AudioPlayer::Sox);
    let vlc_score = player_score(AudioPlayer::Vlc);
    let aplay_score = player_score(AudioPlayer::AlsaAplay);

    // mpv and sox have speed+volume+stream = 9 base
    assert!(mpv_score.0 >= 9);
    assert!(sox_score.0 >= 9);

    // VLC has volume+stream = 5 base
    assert!(vlc_score.0 >= 5);
    assert!(vlc_score.0 < mpv_score.0);

    // aplay has nothing = 0 base
    assert_eq!(aplay_score.0, 0);
}

#[test]
fn match_players_prefers_controllable_players() {
    let format = AudioFormat::new(AudioFileFormat::Wav, Some(Codec::Pcm));
    let players = match_players(format);

    // Players with speed+volume should come before those without
    let mpv_pos = players.iter().position(|p| *p == AudioPlayer::Mpv);
    let aplay_pos = players.iter().position(|p| *p == AudioPlayer::AlsaAplay);

    assert!(mpv_pos.unwrap() < aplay_pos.unwrap());
}
```

---

### Change 2: `playa/lib/src/playback.rs` - Playback Implementations

Update signature to accept options and apply volume/speed arguments:

```rust
fn build_player_command(
    player: AudioPlayer,
    metadata: &crate::player::Player,
    source: &ResolvedSource,
    options: &PlaybackOptions,
) -> Result<Command, PlaybackError> {
    let mut command = Command::new(metadata.binary_name());

    match player {
        // Tier 1: Full controllability (speed + volume + stream)
        AudioPlayer::Mpv => {
            command
                .arg("--no-video")
                .arg("--no-terminal")
                .arg("--really-quiet");
            if let Some(vol) = options.volume {
                command.arg(format!("--volume={}", (vol * 100.0) as i32));
            }
            if let Some(speed) = options.speed {
                command.arg(format!("--speed={}", speed));
            }
            source.apply(&mut command);
        }
        AudioPlayer::FfPlay => {
            command
                .arg("-nodisp")
                .arg("-autoexit")
                .arg("-loglevel")
                .arg("quiet");
            if let Some(vol) = options.volume {
                command.arg("-volume").arg(((vol * 100.0) as i32).to_string());
            }
            if let Some(speed) = options.speed {
                // FFplay uses audio filter for tempo; clamp to 0.5-2.0
                let clamped = speed.clamp(0.5, 2.0);
                command.arg("-af").arg(format!("atempo={}", clamped));
            }
            source.apply(&mut command);
        }
        AudioPlayer::Sox => {
            command.arg("-q");
            if let Some(vol) = options.volume {
                command.arg("-v").arg(vol.to_string());
            }
            source.apply(&mut command);
            // Speed effect must come AFTER the source file
            if let Some(speed) = options.speed {
                command.arg("speed").arg(speed.to_string());
            }
        }

        // Tier 2: Volume + stream (no speed control)
        AudioPlayer::Vlc => {
            command
                .arg("--quiet")
                .arg("--play-and-exit");
            if let Some(vol) = options.volume {
                command.arg(format!("--gain={}", vol * 2.0)); // 0.0-2.0 range
            }
            source.apply(&mut command);
        }
        AudioPlayer::MPlayer => {
            command.arg("-really-quiet");
            if let Some(vol) = options.volume {
                command.arg("-softvol");
                command.arg("-volume").arg(((vol * 100.0) as i32).to_string());
            }
            source.apply(&mut command);
        }
        AudioPlayer::GstreamerGstPlay => {
            command.arg("--quiet");
            if let Some(vol) = options.volume {
                command.arg(format!("--volume={}", vol));
            }
            source.apply(&mut command);
        }

        // Tier 3: Volume only (Linux audio subsystems)
        AudioPlayer::PulseaudioPaplay => {
            if let Some(vol) = options.volume {
                command.arg(format!("--volume={}", (vol * 65536.0) as u32));
            }
            source.apply(&mut command);
        }
        AudioPlayer::Pipewire => {
            if let Some(vol) = options.volume {
                command.arg(format!("--volume={}", vol));
            }
            source.apply(&mut command);
        }

        // Tier 3: Stream only (no volume/speed control)
        AudioPlayer::Mpg123 => {
            command.arg("-q");
            // Note: volume/speed options ignored (not supported)
            source.apply(&mut command);
        }
        AudioPlayer::Ogg123 => {
            command.arg("-q");
            // Note: volume/speed options ignored (not supported)
            source.apply(&mut command);
        }

        // Tier 4: No controllability
        AudioPlayer::AlsaAplay => {
            command.arg("-q");
            // Note: volume/speed options ignored (not supported)
            source.apply(&mut command);
        }
    }

    Ok(command)
}
```

---

## Testing Strategy

### Unit Tests

Add tests to `playa/lib/src/playback.rs` or a separate test module:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn build_command_vlc_has_correct_args() {
        let metadata = PLAYER_LOOKUP.get(&AudioPlayer::Vlc).unwrap();
        let source = ResolvedSource::Path(PathBuf::from("/tmp/test.mp3"));
        let command = build_player_command(AudioPlayer::Vlc, metadata, &source).unwrap();

        let args: Vec<_> = command.get_args().collect();
        assert!(args.contains(&OsStr::new("--quiet")));
        assert!(args.contains(&OsStr::new("--play-and-exit")));
    }

    // Similar tests for each player...
}
```

### Integration Tests

Create `playa/lib/tests/playback_integration.rs`:

1. **Skip if binary not available** - Use `which` or check PATH
2. **Use short audio fixtures** - 1-second silent WAV/MP3 files
3. **Verify process exits** - Ensure no zombie processes
4. **Verify no output** - Check stdout/stderr are empty

### Manual Testing Matrix

| Player | macOS | Linux | Windows | Notes |
|--------|:-----:|:-----:|:-------:|-------|
| VLC | ✓ | ✓ | ✓ | Install via brew/apt/choco |
| MPlayer | ✓ | ✓ | ~ | Windows support limited |
| GStreamer | ✓ | ✓ | ~ | Requires gst-plugins |
| SoX | ✓ | ✓ | ✓ | Install via brew/apt/choco |
| mpg123 | ✓ | ✓ | ✓ | Cross-platform |
| ogg123 | ✓ | ✓ | ~ | Part of vorbis-tools |
| paplay | ✗ | ✓ | ✗ | PulseAudio only |
| pw-play | ✗ | ✓ | ✗ | PipeWire only |
| aplay | ✗ | ✓ | ✗ | ALSA only |

---

---

## Volume & Speed Control

This is a core feature, not a future enhancement. The playa library and CLI will support volume and speed adjustments when the selected player supports them.

### CLI Switches

The `playa` CLI will expose these user-friendly switches:

| Switch | Effect | Mapped Value |
|--------|--------|--------------|
| `--fast` | 1.25x playback speed | `speed: Some(1.25)` |
| `--slow` | 0.75x playback speed | `speed: Some(0.75)` |
| `--quiet` | 50% volume | `volume: Some(0.5)` |
| `--loud` | 150% volume | `volume: Some(1.5)` |
| `--speed <N>` | Custom speed multiplier | `speed: Some(N)` |
| `--volume <N>` | Custom volume (0.0-2.0) | `volume: Some(N)` |

**Conflict handling:**
- `--fast` and `--slow` are mutually exclusive
- `--quiet` and `--loud` are mutually exclusive
- Explicit `--speed`/`--volume` override the presets

### PlaybackOptions Struct

Add to `playa/lib/src/types.rs`:

```rust
/// Options for controlling audio playback.
#[derive(Debug, Clone, Copy, Default)]
pub struct PlaybackOptions {
    /// Volume level (0.0 = silent, 1.0 = normal, >1.0 = amplified).
    /// Only applied if selected player supports volume control.
    pub volume: Option<f32>,

    /// Playback speed multiplier (1.0 = normal, <1.0 = slower, >1.0 = faster).
    /// Only applied if selected player supports speed control.
    pub speed: Option<f32>,
}

impl PlaybackOptions {
    /// Create options with default values (no adjustments).
    pub const fn new() -> Self {
        Self {
            volume: None,
            speed: None,
        }
    }

    /// Set volume level.
    pub const fn with_volume(mut self, volume: f32) -> Self {
        self.volume = Some(volume);
        self
    }

    /// Set playback speed.
    pub const fn with_speed(mut self, speed: f32) -> Self {
        self.speed = Some(speed);
        self
    }

    /// Check if any options require speed control capability.
    pub const fn requires_speed_control(&self) -> bool {
        self.speed.is_some()
    }

    /// Check if any options require volume control capability.
    pub const fn requires_volume_control(&self) -> bool {
        self.volume.is_some()
    }
}
```

### Library API Changes

Update `playa/lib/src/audio.rs` to support options:

```rust
impl Audio {
    // ... existing methods ...

    /// Play with default options.
    pub fn play(&self) -> Result<(), PlaybackError> {
        self.play_with_options(PlaybackOptions::default())
    }

    /// Play with custom volume/speed options.
    pub fn play_with_options(&self, options: PlaybackOptions) -> Result<(), PlaybackError> {
        let player = self.select_player_for_options(&options)?;
        playa_with_player_and_options(player, self.data.clone(), options)
    }

    /// Select a player that supports the requested options.
    fn select_player_for_options(&self, options: &PlaybackOptions) -> Result<AudioPlayer, PlaybackError> {
        let candidates = match_available_players(self.format)
            .into_iter()
            .filter(|player| {
                let Some(meta) = PLAYER_LOOKUP.get(player) else {
                    return false;
                };
                let speed_ok = !options.requires_speed_control() || meta.supports_speed_control;
                let volume_ok = !options.requires_volume_control() || meta.supports_volume_control;
                speed_ok && volume_ok
            })
            .collect::<Vec<_>>();

        candidates.first().copied().ok_or_else(|| {
            if options.requires_speed_control() && options.requires_volume_control() {
                PlaybackError::NoPlayerWithCapabilities {
                    format: self.format,
                    needs_speed: true,
                    needs_volume: true,
                }
            } else if options.requires_speed_control() {
                PlaybackError::NoPlayerWithCapabilities {
                    format: self.format,
                    needs_speed: true,
                    needs_volume: false,
                }
            } else {
                PlaybackError::NoPlayerWithCapabilities {
                    format: self.format,
                    needs_speed: false,
                    needs_volume: true,
                }
            }
        })
    }
}
```

### CLI Changes

Update `playa/cli/src/main.rs`:

```rust
#[derive(Parser)]
#[command(name = "playa")]
#[command(about = "Play audio using the host's installed players", long_about = None)]
struct Cli {
    /// Show a table of player metadata
    #[arg(long)]
    meta: bool,

    /// Play at 1.25x speed
    #[arg(long, conflicts_with = "slow")]
    fast: bool,

    /// Play at 0.75x speed
    #[arg(long, conflicts_with = "fast")]
    slow: bool,

    /// Play at 50% volume
    #[arg(long, conflicts_with = "loud")]
    quiet: bool,

    /// Play at 150% volume
    #[arg(long, conflicts_with = "quiet")]
    loud: bool,

    /// Custom playback speed (0.5 to 2.0)
    #[arg(long, value_name = "MULTIPLIER", conflicts_with_all = ["fast", "slow"])]
    speed: Option<f32>,

    /// Custom volume level (0.0 to 2.0)
    #[arg(long, value_name = "LEVEL", conflicts_with_all = ["quiet", "loud"])]
    volume: Option<f32>,

    /// Audio file to play
    #[arg(
        value_name = "AUDIO_FILE",
        value_hint = ValueHint::FilePath,
        required_unless_present = "meta"
    )]
    audio_file: Option<PathBuf>,
}

impl Cli {
    fn playback_options(&self) -> PlaybackOptions {
        let speed = if let Some(s) = self.speed {
            Some(s)
        } else if self.fast {
            Some(1.25)
        } else if self.slow {
            Some(0.75)
        } else {
            None
        };

        let volume = if let Some(v) = self.volume {
            Some(v)
        } else if self.quiet {
            Some(0.5)
        } else if self.loud {
            Some(1.5)
        } else {
            None
        };

        PlaybackOptions { volume, speed }
    }
}

fn main() {
    let cli = Cli::parse();

    // ... meta handling ...

    let audio = Audio::from_path(path).unwrap();
    let options = cli.playback_options();

    if let Err(error) = audio.play_with_options(options) {
        eprintln!("Playback failed: {error}");
        std::process::exit(1);
    }
}
```

### Volume Control by Player

Volume CLI arguments (normalized from 0.0-1.0 input):

| Player | Argument | Input→Native | Notes |
|--------|----------|--------------|-------|
| mpv | `--volume=N` | `vol * 100` → 0-100+ | Percentage |
| FFplay | `-volume N` | `vol * 100` → 0-100 | Percentage |
| SoX | `-v N` | `vol` → 0.0+ | Amplitude multiplier (direct) |
| VLC | `--gain=N` | `vol * 2` → 0.0-2.0 | Gain multiplier |
| MPlayer | `-softvol -volume N` | `vol * 100` → 0-100 | Requires softvol flag |
| GStreamer | `--volume=N` | `vol` → 0.0-1.0+ | Linear (direct) |
| paplay | `--volume=N` | `vol * 65536` → 0-65536+ | 65536 = 100% |
| pw-play | `--volume=N` | `vol` → 0.0-1.0+ | Linear (direct) |

### Speed Control by Player

Speed CLI arguments (normalized from multiplier input):

| Player | Argument | Notes |
|--------|----------|-------|
| mpv | `--speed=N` | Direct multiplier |
| FFplay | `-af atempo=N` | Clamped 0.5-2.0; chain filters for wider range |
| SoX | `speed N` (effect) | Appended after source as effect |

**Implementation note for SoX:**
```rust
AudioPlayer::Sox => {
    command.arg("-q");
    if let Some(vol) = options.volume {
        command.arg("-v").arg(vol.to_string());
    }
    source.apply(&mut command);
    // Speed must come AFTER the source file as an effect
    if let Some(speed) = options.speed {
        command.arg("speed").arg(speed.to_string());
    }
}
```

### Error Handling

Add new error variant to `playa/lib/src/error.rs`:

```rust
#[derive(Debug, thiserror::Error)]
pub enum PlaybackError {
    // ... existing variants ...

    /// No installed player supports the required capabilities.
    #[error("no player supports {format:?} with{} speed control{} volume control",
        if *.needs_speed { "" } else { "out" },
        if *.needs_volume { " and" } else { " or" }
    )]
    NoPlayerWithCapabilities {
        format: AudioFormat,
        needs_speed: bool,
        needs_volume: bool,
    },
}
```

---

## Future Enhancements

### Stdin Streaming

For TTS pipelines that want to avoid disk I/O:

| Player | Stdin Support | Notes |
|--------|:-------------:|-------|
| mpv | ✅ | `mpv -` |
| FFplay | ✅ | `ffplay -` |
| VLC | ⚠️ | `cvlc fd://0` (no seeking) |
| MPlayer | ✅ | `mplayer -` |
| SoX | ✅ | `play -` |
| mpg123 | ⚠️ | Remote control mode |
| ogg123 | ❌ | Known limitation |
| paplay | ✅ | Default if no file |
| pw-play | ⚠️ | Requires format args |
| aplay | ✅ | Default if no file |

---

## Documentation Updates

After implementation:

1. **Update `playa/README.md`** - Add "Implemented" column or note to Audio Providers table
2. **Update `playa/lib/README.md`** - Document which players are available per platform
3. **Add troubleshooting guide** - Common issues (missing codecs, binary not found)

---

## Acceptance Criteria

### Provider Implementation
- [ ] All 8 providers implemented in `build_player_command`
- [ ] No `UnsupportedPlayer` errors for any defined provider
- [ ] Unit tests for each player's CLI arguments

### Selection Algorithm
- [ ] `Player` struct extended with `supports_speed_control` and `supports_volume_control` fields
- [ ] All 11 `PLAYER_LOOKUP` entries updated with capability flags
- [ ] `player_score()` function updated to prioritize speed (+4), volume (+3), stream (+2)
- [ ] Unit tests verify Tier 1 players (mpv, FFplay, SoX) rank above Tier 2-4 players
- [ ] Unit tests verify selection order for MP3 and WAV formats

### Volume & Speed Control
- [ ] `PlaybackOptions` struct added to `playa/lib/src/types.rs`
- [ ] `Audio::play_with_options()` method implemented
- [ ] Player selection filters by required capabilities when options are set
- [ ] `NoPlayerWithCapabilities` error variant added
- [ ] Volume arguments correctly normalized for each player
- [ ] Speed arguments correctly applied for Tier 1 players (mpv, FFplay, SoX)
- [ ] SoX speed effect correctly placed after source file

### CLI Switches
- [ ] `--fast` flag sets speed to 1.25x
- [ ] `--slow` flag sets speed to 0.75x
- [ ] `--quiet` flag sets volume to 50%
- [ ] `--loud` flag sets volume to 150%
- [ ] `--speed <N>` accepts custom speed multiplier
- [ ] `--volume <N>` accepts custom volume level
- [ ] Conflicts enforced: `--fast`/`--slow` mutually exclusive
- [ ] Conflicts enforced: `--quiet`/`--loud` mutually exclusive
- [ ] Explicit values override presets

### Quality
- [ ] Integration tests pass on Linux (CI)
- [ ] Manual testing completed on macOS and Linux
- [ ] README updated to reflect implementation status
- [ ] `cargo clippy` passes with no warnings
- [ ] `cargo test -p playa-lib` passes

---

## References

- [VLC command-line help](https://wiki.videolan.org/VLC_command-line_help/)
- [MPlayer manual](http://www.mplayerhq.hu/DOCS/man/en/mplayer.1.html)
- [GStreamer gst-play-1.0](https://manpages.ubuntu.com/manpages/bionic/man1/gst-play-1.0.1.html)
- [SoX manual](https://linux.die.net/man/1/sox)
- [mpg123 manual](https://linux.die.net/man/1/mpg123)
- [ogg123 manual](https://man.archlinux.org/man/ogg123.1.en)
- [paplay manual](https://manpages.debian.org/testing/pulseaudio-utils/paplay.1.en.html)
- [pw-cat manual](https://docs.pipewire.org/page_man_pw-cat_1.html)
- [aplay manual](https://linux.die.net/man/1/aplay)
