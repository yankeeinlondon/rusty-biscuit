# Fix `research list` Command Issues

**Created:** 2025-12-29
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Fix six issues in the `research` command suite including five critical bugs in the `list` command's output formatting and argument handling, plus adding an AI-powered utility function for generating meaningful filenames. Issues include broken `-v` shorthand flag, incorrect display of descriptions in non-verbose mode, malformed type badges, missing language icons, markdown syntax in terminal output, and generic `question_N.md` filenames for custom prompts.

## Review Summary

**Reviews Completed:** 2025-12-29

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Request Revision ‚Üí Approved after incorporating test strategy improvements

**Key Changes from Review:**

1. **Phase 5 Redesigned** - Originally deferred as out of scope for `list` command, now redesigned as a reusable utility function `chooseFilename(prompt)` that can be called by any command that needs to create custom prompt files. User requested this be included in the plan.

2. **Enhanced Test Strategy** - Added comprehensive ANSI escape code verification tests, test helper functions for stripping escape codes, and explicit test fixture updates with `library_info.language` metadata.

3. **Improved Struct Design (Phase 4)** - Added `#[serde(default)]` to new `library_info` field for graceful degradation when deserializing old JSON without this field.

4. **Sequential Implementation** - Changed parallelization strategy: Phases 1, 2, 6 cannot run in parallel since they all modify `format.rs`. Recommended sequential order to avoid merge conflicts.

5. **Test Migration Strategy (Phase 6)** - Identified specific test lines (297, 308, 327, 591, 667-668, 747 in format.rs) that check for markdown syntax and must be updated to verify ANSI escape sequences instead.

6. **Backward Compatibility** - Added explicit tests ensuring JSON deserialization works without `language` field, and TopicInfo construction doesn't require new fields.

**Resolved Concerns:**

- **Clap Argument Shadowing** ‚Üí Confirmed this is the correct approach per clap 4.x design. Added test to ensure `-v` and `--verbose` produce identical output.
- **Language Icon Allocation** ‚Üí Optimized `format_language_icon()` to avoid unnecessary String allocations for emoji cases.
- **Type Badge Test Updates** ‚Üí Identified existing tests checking for brackets that need updating (lines 620, 634, 677 in format.rs).
- **Gemini Dependency Bloat** ‚Üí Eliminated by deferring Phase 5 entirely.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Fix `-v`/`--verbose` flag handling via argument shadowing | High | Rust Developer |
| FR-2 | Hide topic descriptions when `--verbose` is NOT used | High | Rust Developer |
| FR-3 | Fix type indicator formatting (remove brackets, add padding with background) | High | Rust Developer |
| FR-4 | Add language icons after type indicator in all modes | High | Rust Developer |
| FR-5 | Create `chooseFilename(prompt)` utility function using Gemini Flash for meaningful kebab-case filenames | High | Rust Developer |
| FR-6 | Replace markdown syntax with terminal escape codes in verbose sub-bullets | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Maintain backwards compatibility with existing JSON output | No breaking changes | Rust Developer |
| NFR-2 | Preserve existing test coverage | All existing tests pass | Feature Tester (Rust) |
| NFR-3 | Add new tests for fixed behaviors | >90% coverage of changes | Feature Tester (Rust) |
| NFR-4 | Minimize external dependencies | Only add Gemini API client if needed | Rust Architect |

## Architecture Overview

The `research list` command is implemented across three layers:

1. **CLI Layer** (`research/cli/src/main.rs`): Argument parsing using `clap` crate
2. **Library Layer** (`research/lib/src/lib.rs`): Orchestrates discovery, filtering, formatting
3. **Module Layer** (`research/lib/src/list/`): Specialized modules for discovery, filtering, formatting

### Current Component Interaction

```
CLI (clap)
    ‚Üì (filters, types, verbose, json)
Library::list()
    ‚Üì discover_topics()
    ‚Üì apply_filters()
    ‚Üì format_terminal() / format_json()
    ‚Üì
STDOUT
```

### Key Files

- `research/cli/src/main.rs` - CLI argument definitions
- `research/lib/src/lib.rs` - Main list() function
- `research/lib/src/list/discovery.rs` - Topic discovery and metadata parsing
- `research/lib/src/list/format.rs` - Terminal and JSON formatting
- `research/lib/src/list/types.rs` - TopicInfo, ResearchOutput structs

## Phases

### Phase 1: Fix `-v`/`--verbose` Argument Shadowing

**Principal Owner:** Rust Developer

**Goal:** Make `-v` shorthand work for the `--verbose` flag at command level while preserving global `-v` for logging verbosity.

**Dependencies:** None

**Blast Radius:** `cargo test --lib list` + manual testing with `-v` flag

**Technical Details:**

The issue is that clap's global `-v` flag (for logging) is conflicting with the command-level `--verbose` flag. The solution is to use **argument shadowing** where the command redefines `-v` to override the global definition.

**Current Code** (`research/cli/src/main.rs:53-55`):
```rust
/// Show detailed metadata for each topic (sub-bullets with issues)
#[arg(long)]
verbose: bool,
```

**Fixed Code** (add short flag with shadowing):
```rust
/// Show detailed metadata for each topic (sub-bullets with issues)
#[arg(short = 'v', long)]
verbose: bool,
```

**Clap Behavior:**
- Global `-v` is defined at struct level (lines 14-16)
- When `List` command adds `-v` short flag, it shadows the global `-v`
- Within the `list` subcommand context, `-v` maps to `verbose: bool`
- Outside subcommands, `-v` still maps to global verbosity

**Files to Modify:**
1. `research/cli/src/main.rs` - Add `short = 'v'` to List::verbose field

**Acceptance Criteria:**
- [ ] `research list -v` shows verbose output (sub-bullets)
- [ ] `research list --verbose` shows verbose output (sub-bullets)
- [ ] `research list` (no flag) shows non-verbose output (no sub-bullets)
- [ ] Global `-v` still controls RUST_LOG when used outside subcommands
- [ ] Existing test `cargo test --lib list` passes

---

### Phase 2: Hide Descriptions in Non-Verbose Mode

**Principal Owner:** Rust Developer

**Goal:** Only display topic descriptions (from `metadata.json` `brief` field) when `--verbose` flag is present.

**Dependencies:** None (can run parallel with Phase 1)

**Blast Radius:** `cargo test --lib list::format`

**Technical Details:**

Currently, `format_main_line()` in `research/lib/src/list/format.rs` always appends the description with ` : {description}` if present. This should only happen in verbose mode.

**Current Code** (`research/lib/src/list/format.rs:139-188`):
```rust
fn format_main_line(topic: &TopicInfo, show_type: bool, verbose: bool) -> String {
    // ... build line with name, type badge ...

    // BUG: This always adds description if present
    if let Some(desc) = &topic.description {
        line.push_str(&format!(" : {}", desc.italic()));
    }

    // ... add icons in non-verbose mode ...
}
```

**Fixed Code:**
```rust
fn format_main_line(topic: &TopicInfo, show_type: bool, verbose: bool) -> String {
    // ... build line with name, type badge ...

    // FIX: Only add description in verbose mode
    if verbose {
        if let Some(desc) = &topic.description {
            line.push_str(&format!(" : {}", desc.italic()));
        }
    }

    // ... add icons in non-verbose mode ...
}
```

**Files to Modify:**
1. `research/lib/src/list/format.rs` - Wrap description logic in `if verbose` block (around line 172)

**Acceptance Criteria:**
- [ ] Non-verbose output (`research list`) does NOT show descriptions
- [ ] Verbose output (`research list --verbose`) DOES show descriptions
- [ ] JSON output still includes descriptions (uses different code path)
- [ ] Existing integration tests pass
- [ ] New test: verify description absence in non-verbose terminal output

---

### Phase 3: Fix Type Badge Formatting

**Principal Owner:** Rust Developer

**Goal:** Remove square brackets from type badges and add leading/trailing spaces with background color.

**Dependencies:** None (can run parallel with Phases 1-2)

**Blast Radius:** `cargo test --lib list::format`

**Technical Details:**

The `format_type_badge()` function currently formats types as `[TYPE]` with background color. Spec requires ` TYPE ` format (space, type, space, all with background).

**Current Code** (`research/lib/src/list/format.rs:280-289`):
```rust
fn format_type_badge(type_name: &str) -> String {
    let color = get_badge_color(type_name);
    format!(
        "[{}]",  // BUG: brackets included
        type_name.on_truecolor(color.0, color.1, color.2)
    )
}
```

**Fixed Code:**
```rust
fn format_type_badge(type_name: &str) -> String {
    let color = get_badge_color(type_name);
    let rgb = color;  // (r, g, b) tuple

    // FIX: Format as " TYPE " with background on entire string including spaces
    format!(
        "{}",
        format!(" {} ", type_name)
            .on_truecolor(rgb.0, rgb.1, rgb.2)
    )
}
```

**Visual Change:**
- Before: `- topicname [library] : description`
- After: `- topicname  library  : description` (spaces have background color)

**Files to Modify:**
1. `research/lib/src/list/format.rs` - Update `format_type_badge()` function (around line 280)

**Acceptance Criteria:**
- [ ] Type badges do NOT have square brackets
- [ ] Type badges have leading space with background color
- [ ] Type badges have trailing space with background color
- [ ] Background colors still work correctly for all type variants
- [ ] Existing integration tests pass
- [ ] New test: verify badge format matches ` TYPE ` pattern

---

### Phase 4: Add Language Icons After Type Badge

**Principal Owner:** Rust Developer

**Goal:** Display language-specific icons (ü¶Äüêçüêò ¶) immediately after the type badge in all modes (verbose and non-verbose).

**Dependencies:** Phase 3 (type badge formatting should be fixed first for correct positioning)

**Blast Radius:** `cargo test --lib list`

**Technical Details:**

According to the spec (`research/docs/commands/list.md:62-66`), language icons should appear after the type badge based on `metadata.json`'s `library_info.language` property:

- ü¶Ä if language = "Rust"
- üêç if language = "Python"
- üêò if language = "PHP"
- ` ¶` (BLUE background, BLACK text) if language = "Javascript" or "Typescript"

**Current Issues:**
1. Metadata struct doesn't include `library_info` field
2. `format_main_line()` doesn't generate language icons
3. Icons should show in BOTH verbose and non-verbose modes

**Implementation Steps:**

1. **Update Metadata struct** (`research/lib/src/list/discovery.rs:30-42`):
```rust
#[derive(Debug, Deserialize)]
struct LibraryInfo {
    language: Option<String>,
}

#[derive(Debug, Deserialize)]
struct Metadata {
    #[serde(alias = "type")]
    kind: Option<String>,
    brief: Option<String>,
    library_info: Option<LibraryInfo>,  // NEW FIELD
}
```

2. **Update TopicInfo struct** (`research/lib/src/list/types.rs:50-76`):
```rust
pub struct TopicInfo {
    pub name: String,
    pub topic_type: String,
    pub description: Option<String>,
    pub language: Option<String>,  // NEW FIELD - extracted from metadata.library_info.language
    pub additional_files: Vec<String>,
    pub missing_underlying: Vec<String>,
    pub missing_output: Vec<ResearchOutput>,
    pub missing_metadata: bool,
    pub location: PathBuf,
}
```

3. **Update `analyze_topic()` in discovery.rs** to extract language:
```rust
let language = metadata
    .and_then(|m| m.library_info)
    .and_then(|li| li.language);

TopicInfo {
    // ... other fields ...
    language,
    // ... other fields ...
}
```

4. **Add `format_language_icon()` helper** (`research/lib/src/list/format.rs`):
```rust
/// Format language icon based on language string
/// Returns empty string if no icon applies
fn format_language_icon(language: Option<&String>) -> String {
    match language.map(|s| s.as_str()) {
        Some("Rust") => " ü¶Ä".to_string(),
        Some("Python") => " üêç".to_string(),
        Some("PHP") => " üêò".to_string(),
        Some("Javascript") | Some("TypeScript") | Some("Typescript") => {
            // Blue background (0,122,204), black text
            format!(" {}", " ¶".black().on_truecolor(0, 122, 204))
        }
        _ => String::new(),
    }
}
```

5. **Update `format_main_line()` to insert icon after type badge** (around line 164):
```rust
// Add type badge if needed
if show_type {
    line.push(' ');
    line.push_str(&format_type_badge(&topic.topic_type));
}

// NEW: Add language icon after type badge (in all modes)
line.push_str(&format_language_icon(topic.language.as_ref()));
```

**Files to Modify:**
1. `research/lib/src/list/discovery.rs` - Add `LibraryInfo` struct, update `Metadata`, extract language
2. `research/lib/src/list/types.rs` - Add `language` field to `TopicInfo`
3. `research/lib/src/list/format.rs` - Add `format_language_icon()`, update `format_main_line()`

**Test Fixture Updates:**
Create test metadata with language info:
```json
{
  "kind": "library",
  "brief": "A Rust library for testing",
  "library_info": {
    "language": "Rust"
  }
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/list/discovery.rs` updated with `LibraryInfo` struct
- [ ] File `research/lib/src/list/types.rs` has `language: Option<String>` field
- [ ] File `research/lib/src/list/format.rs` has `format_language_icon()` function
- [ ] `format_main_line()` calls `format_language_icon()` after type badge
- [ ] ü¶Ä icon appears for Rust libraries in both verbose and non-verbose modes
- [ ] üêç icon appears for Python libraries
- [ ] üêò icon appears for PHP libraries
- [ ] ` ¶` (blue bg, black text) appears for Javascript/TypeScript libraries
- [ ] No icon appears for topics without language metadata
- [ ] JSON output includes language field
- [ ] New test: verify language icon display for each language type

---

### Phase 5: Create `chooseFilename(prompt)` Utility Function

**Principal Owner:** Rust Developer

**Goal:** Create a reusable utility function that generates meaningful kebab-case filenames from prompt text using Gemini Flash API. This function can be called by any command that needs to create custom prompt files.

**Dependencies:** None (can run independently or in Group D)

**Blast Radius:** `cargo test --lib` (new module with isolated tests)

**Technical Details:**

Create a new module `research/lib/src/utils/filename.rs` with a public async function that:
1. Takes a prompt string as input
2. Calls Gemini Flash API to generate a short (2-5 word) kebab-case identifier
3. Sanitizes the response (lowercase, alphanumeric + hyphens only)
4. Returns `Result<String, FilenameError>` with `.md` extension
5. Falls back to `question_N.md` pattern if API fails

**Implementation Steps:**

1. **Add HTTP client dependency** (`research/lib/Cargo.toml`):
```toml
[dependencies]
# ... existing deps ...
reqwest = { version = "0.12", features = ["json"] }
serde_json = "1.0"  # if not already present
```

2. **Create utility module** (`research/lib/src/utils/mod.rs`):
```rust
pub mod filename;
```

3. **Implement `chooseFilename` function** (`research/lib/src/utils/filename.rs`):
```rust
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, thiserror::Error)]
pub enum FilenameError {
    #[error("Gemini API error: {0}")]
    ApiError(String),
    #[error("No API key provided. Set GEMINI_API_KEY environment variable")]
    NoApiKey,
    #[error("Invalid response from API: {0}")]
    InvalidResponse(String),
}

#[derive(Serialize)]
struct GeminiRequest {
    contents: Vec<Content>,
}

#[derive(Serialize)]
struct Content {
    parts: Vec<Part>,
}

#[derive(Serialize)]
struct Part {
    text: String,
}

#[derive(Deserialize)]
struct GeminiResponse {
    candidates: Vec<Candidate>,
}

#[derive(Deserialize)]
struct Candidate {
    content: ResponseContent,
}

#[derive(Deserialize)]
struct ResponseContent {
    parts: Vec<ResponsePart>,
}

#[derive(Deserialize)]
struct ResponsePart {
    text: String,
}

/// Generate a kebab-case filename from a prompt using Gemini Flash
///
/// # Arguments
/// * `prompt` - The research prompt text
///
/// # Returns
/// * `Ok(String)` - Kebab-case filename with .md extension (e.g., "async-best-practices.md")
/// * `Err(FilenameError)` - If API call fails, API key missing, or response invalid
///
/// # Environment Variables
/// * `GEMINI_API_KEY` - Required. Your Google Gemini API key
///
/// # Example
/// ```no_run
/// use research_lib::utils::filename::chooseFilename;
///
/// #[tokio::main]
/// async fn main() {
///     let filename = chooseFilename("What are the best practices for async Rust?").await;
///     match filename {
///         Ok(name) => println!("Generated: {}", name),
///         Err(e) => eprintln!("Fallback to question_1.md: {}", e),
///     }
/// }
/// ```
pub async fn chooseFilename(prompt: &str) -> Result<String, FilenameError> {
    // Get API key from environment
    let api_key = std::env::var("GEMINI_API_KEY")
        .map_err(|_| FilenameError::NoApiKey)?;

    // Create HTTP client with timeout
    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| FilenameError::ApiError(e.to_string()))?;

    // Build request
    let system_prompt = "Generate a short (2-5 word) kebab-case identifier for the following research prompt. \
                         Respond with ONLY the kebab-case identifier, no explanation, no quotes, no extra text.";

    let request_body = GeminiRequest {
        contents: vec![Content {
            parts: vec![Part {
                text: format!("{}\n\nPrompt: {}", system_prompt, prompt),
            }],
        }],
    };

    // Call Gemini Flash API
    let url = format!(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={}",
        api_key
    );

    let response = client
        .post(&url)
        .json(&request_body)
        .send()
        .await
        .map_err(|e| FilenameError::ApiError(e.to_string()))?;

    if !response.status().is_success() {
        return Err(FilenameError::ApiError(
            format!("HTTP {}: {}", response.status(), response.text().await.unwrap_or_default())
        ));
    }

    let gemini_response: GeminiResponse = response
        .json()
        .await
        .map_err(|e| FilenameError::InvalidResponse(e.to_string()))?;

    // Extract text from response
    let generated_text = gemini_response
        .candidates
        .first()
        .and_then(|c| c.content.parts.first())
        .map(|p| p.text.as_str())
        .ok_or_else(|| FilenameError::InvalidResponse("No text in response".to_string()))?;

    // Sanitize: lowercase, replace spaces with hyphens, filter to alphanumeric + hyphens
    let sanitized = generated_text
        .trim()
        .to_lowercase()
        .replace(' ', "-")
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '-')
        .collect::<String>();

    // Validate result is not empty
    if sanitized.is_empty() {
        return Err(FilenameError::InvalidResponse(
            format!("Sanitized response is empty: '{}'", generated_text)
        ));
    }

    Ok(format!("{}.md", sanitized))
}

/// Helper function to generate fallback filename with incrementing number
///
/// # Arguments
/// * `existing_files` - List of existing prompt files in the directory
///
/// # Returns
/// Next available `question_N.md` filename
pub fn fallback_filename(existing_files: &[String]) -> String {
    let mut n = 1;
    loop {
        let candidate = format!("question_{}.md", n);
        if !existing_files.contains(&candidate) {
            return candidate;
        }
        n += 1;
    }
}
```

4. **Update `research/lib/src/lib.rs`** to expose the utility:
```rust
pub mod utils;
```

5. **Update commands that create custom prompts** to use `chooseFilename`:
   - Find the code location where custom prompts are created
   - Replace hardcoded `question_N.md` logic with:
   ```rust
   use research_lib::utils::filename::{chooseFilename, fallback_filename};

   let filename = match chooseFilename(&prompt_text).await {
       Ok(name) => {
           eprintln!("Generated filename: {}", name);
           name
       }
       Err(e) => {
           eprintln!("Warning: {}", e);
           let existing = /* get list of existing prompt files */;
           let fallback = fallback_filename(&existing);
           eprintln!("Using fallback: {}", fallback);
           fallback
       }
   };
   ```

**Files to Create:**
- `research/lib/src/utils/mod.rs` - Module declaration
- `research/lib/src/utils/filename.rs` - Implementation of `chooseFilename` and `fallback_filename`

**Files to Modify:**
- `research/lib/Cargo.toml` - Add `reqwest` dependency
- `research/lib/src/lib.rs` - Export `pub mod utils`
- *TBD: Command that creates custom prompts* - Integrate `chooseFilename` call

**Acceptance Criteria:**
- [ ] File `research/lib/src/utils/filename.rs` exists with `chooseFilename` function
- [ ] Function has proper error type with `thiserror`
- [ ] Function calls Gemini Flash API (`gemini-1.5-flash` model)
- [ ] API key comes from `GEMINI_API_KEY` environment variable
- [ ] Response is sanitized: lowercase, alphanumeric + hyphens only, `.md` extension
- [ ] Function has 10-second timeout
- [ ] `fallback_filename` helper generates `question_N.md` with incrementing N
- [ ] Unit tests with mocked HTTP responses verify:
  - [ ] Successful API call returns sanitized kebab-case filename
  - [ ] Missing API key returns `FilenameError::NoApiKey`
  - [ ] API timeout returns `FilenameError::ApiError`
  - [ ] Invalid response returns `FilenameError::InvalidResponse`
  - [ ] Fallback function increments correctly
- [ ] Integration test calls actual Gemini API (requires `GEMINI_API_KEY` in CI)
- [ ] Documentation includes usage example and environment variable requirements

**Environment Setup:**
```bash
# Users need to set this environment variable
export GEMINI_API_KEY="your-api-key-here"
```

**Error Handling:**
- API key missing ‚Üí Clear error message directing user to set env var
- API timeout ‚Üí Return error, calling code uses fallback
- Invalid response ‚Üí Return error, calling code uses fallback
- Network error ‚Üí Return error, calling code uses fallback

**Note:** This utility function is intentionally separate from the `list` command. The `list` command only *displays* custom prompts, while this utility is for *creating* them.

---

### Phase 6: Fix Verbose Sub-Bullets to Use Escape Codes

**Principal Owner:** Rust Developer

**Goal:** Replace markdown syntax (`**bold**`, `*italic*`) with terminal escape codes in verbose mode sub-bullets.

**Dependencies:** None (can run parallel with other phases)

**Blast Radius:** `cargo test --lib list::format`

**Technical Details:**

Currently, `format_subbullets()` uses markdown syntax in the output strings:

**Current Code** (`research/lib/src/list/format.rs:116-133`):
```rust
if topic.missing_metadata {
    subbullets.push(format!("    - üêû **metadata.json** missing required props: ..."));
}
if !topic.missing_underlying.is_empty() {
    subbullets.push(format!("    - üêû missing *underlying* research docs: ..."));
}
if !topic.missing_output.is_empty() {
    subbullets.push(format!("    - üêû missing *final* output deliverables: ..."));
}
if !topic.additional_files.is_empty() {
    subbullets.push(format!("    - üí° {} additional prompts used in research: ...", n));
}
```

**Problems:**
- `**metadata.json**` should use `.bold()` escape codes
- `*underlying*` should use `.italic()` escape codes
- `*final*` should use `.italic()` escape codes

**Fixed Code:**
```rust
use owo_colors::OwoColorize;

if topic.missing_metadata {
    subbullets.push(format!(
        "    - üêû {} missing required props: {}",
        "metadata.json".bold(),
        "type, brief".italic()  // or actual missing props
    ));
}

if !topic.missing_underlying.is_empty() {
    let files = topic.missing_underlying.join(", ");
    subbullets.push(format!(
        "    - üêû missing {} research docs: {}",
        "underlying".italic(),
        files
    ));
}

if !topic.missing_output.is_empty() {
    let outputs = topic.missing_output.iter()
        .map(|o| match o {
            ResearchOutput::DeepDive => "Deep Dive Document",
            ResearchOutput::Brief => "Brief",
            ResearchOutput::Skill => "Skill",
        })
        .collect::<Vec<_>>()
        .join(", ");

    subbullets.push(format!(
        "    - üêû missing {} output deliverables: {}",
        "final".italic(),
        outputs
    ));
}

if !topic.additional_files.is_empty() {
    let n = topic.additional_files.len();
    let files = topic.additional_files.join(", ");
    subbullets.push(format!(
        "    - üí° {} additional prompts used in research: {}",
        n,
        files
    ));
}
```

**Files to Modify:**
1. `research/lib/src/list/format.rs` - Update `format_subbullets()` function (lines 105-134)

**Acceptance Criteria:**
- [ ] Sub-bullets use `.bold()` for "metadata.json"
- [ ] Sub-bullets use `.italic()` for "underlying" and "final"
- [ ] No markdown syntax (`**`, `*`) in terminal output
- [ ] Verbose output displays with correct terminal formatting
- [ ] Existing integration tests pass
- [ ] New test: verify escape codes in verbose sub-bullet output

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit Tests:**
  - Each formatting function (`format_type_badge`, `format_language_icon`, `format_subbullets`) should have unit tests
  - Test escape code generation (verify ANSI sequences in output)

- **Integration Tests:**
  - Add test fixtures with `library_info.language` metadata
  - Test verbose vs non-verbose output differences
  - Test that `-v` and `--verbose` produce identical output
  - Test that descriptions only appear in verbose mode
  - Test type badge format (no brackets, padded spaces)
  - Test language icons appear correctly

- **Manual Testing:**
  - Run `research list` with various flags in actual terminal
  - Verify colors render correctly in dark and light themes
  - Test `-v` shorthand works alongside `--verbose`

### Security Considerations

- **Gemini API Integration (Phase 5):**
  - API key should come from environment variable, not hardcoded
  - Validate/sanitize Gemini responses before using as filenames
  - Implement request timeout to prevent hanging
  - Handle API rate limits gracefully
  - Don't send sensitive research content to external API (only send user's custom prompt text)

### Performance Considerations

- **Gemini API Calls (Phase 5):**
  - Async/await to prevent blocking
  - Cache generated filenames if prompt is repeated
  - Timeout after 5 seconds, fallback to `question_N.md`

- **Terminal Theme Detection:**
  - Already cached in `OnceLock<bool>` - no changes needed

- **Escape Code Generation:**
  - Minimal overhead from `owo_colors` crate
  - String allocations are unavoidable for formatted output

### Backwards Compatibility

- **JSON Output:**
  - Adding `language` field to JSON is backwards-compatible (additive change)
  - Existing consumers will ignore unknown fields

- **Terminal Output:**
  - Visual changes only (formatting improvements)
  - No breaking changes to command-line API

- **Argument Shadowing:**
  - `-v` behavior changes within `list` subcommand
  - Global `-v` behavior unchanged outside subcommands
  - This is technically a breaking change if users relied on `-v` NOT working for list (unlikely)

### Error Handling

- **Gemini API Failures (Phase 5):**
  - Use `thiserror` for structured error types
  - Fallback to `question_N.md` naming scheme on API errors
  - Log warning to stderr when fallback is used

- **Metadata Parsing:**
  - Existing error handling already graceful (treats missing/invalid as missing_metadata: true)
  - No changes needed

## Parallelization Opportunities

**IMPORTANT:** After review, phases touching `format.rs` CANNOT run in parallel due to merge conflicts.

### Revised Implementation Strategy - Sequential

**Why Sequential:** Phases 2, 3, 4, and 6 all modify `research/lib/src/list/format.rs`. Running these in parallel would create merge conflicts.

**Recommended Sequential Order:**

1. **Phase 1** - CLI argument shadowing (modifies `research/cli/src/main.rs` only)
   - Independent, can run first
   - Quick win, fixes `-v` shorthand

2. **Phase 6** - Escape codes in verbose sub-bullets
   - Modifies `format.rs` lines 116-133 (format_subbullets function)
   - High priority visual bug
   - Updates test lines 297, 308, 327, 591, 667-668, 747

3. **Phase 2** - Hide descriptions in non-verbose mode
   - Modifies `format.rs` around line 162-165 (format_main_line function)
   - High priority incorrect behavior
   - No conflict with Phase 6 (different functions)

4. **Phase 3** - Type badge formatting
   - Modifies `format.rs` line 280-289 (format_type_badge function)
   - Prerequisite for Phase 4
   - Updates test lines 620, 634, 677

5. **Phase 4** - Language icons
   - Modifies `format.rs` (adds format_language_icon function, updates format_main_line)
   - Also modifies `discovery.rs` and `types.rs`
   - Depends on Phase 3 for correct icon positioning

6. **Phase 5** - `chooseFilename` utility (creates new files, independent)

### Alternative: Partial Parallel Approach (USER PREFERRED)

**Group A (Parallel):**
- Phase 1 (CLI args) - touches `cli/main.rs`
- Phase 5 (`chooseFilename` utility) - creates new `utils/` module
- Phase 6 (escape codes) - touches `format.rs` subbullets function

**Group B (Sequential after Group A):**
1. Phase 2 - touches `format.rs` main_line function
2. Phase 3 - touches `format.rs` type_badge function
3. Phase 4 - touches `format.rs`, `discovery.rs`, `types.rs`

**Blast Radius for Full Test Run:** After Phase 4, run `cargo test` (full suite) since `TopicInfo` struct changes affect multiple modules.

**User Notes:**
- User prefers partial parallel approach
- User also wants `-v` shorthand added to `link` command (can be done after Phase 1 or in separate commit)

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Argument shadowing breaks existing scripts | Low | Document change, very unlikely anyone relies on `-v` NOT working |
| Escape codes render incorrectly in some terminals | Low | Use well-tested `owo_colors` crate, manual testing in multiple terminals |
| Language icon display breaks with new emoji standards | Low | Use widely supported emojis (ü¶Äüêçüêò), test TypeScript  ¶ icon in CI |
| Type badge spacing looks wrong in some terminals | Low | Test in multiple terminal emulators (iTerm2, Terminal.app, Alacritty) |
| TopicInfo struct changes break backward compatibility | Medium | Add `#[serde(default)]` to new fields, test JSON deserialization |
| Test migration from markdown to ANSI codes incomplete | Medium | Systematically update all tests checking for `**` and `*` syntax |
| Gemini API key not configured by users | Medium | Clear error message with setup instructions, graceful fallback to `question_N.md` |
| Gemini API rate limiting or downtime | Low | 10-second timeout, fallback to `question_N.md` on any API error |

## Open Questions

All questions resolved:

- [x] Should Gemini API integration be a required dependency or optional feature?
  - **Resolution:** Required dependency (`reqwest`), but API key is optional. Graceful fallback to `question_N.md` if key not set.

- [x] Where is the code that creates custom prompt files (for Phase 5)?
  - **Resolution:** Phase 5 creates a reusable utility function. Integration point TBD (will be identified during implementation or in follow-up commit).

- [x] Should `-v` shorthand shadowing be documented in user-facing help text?
  - **Resolution:** Yes, clap will automatically show both `-v` and `--verbose` in help

- [x] Are there any other commands besides `list` that need the `-v` shadowing fix?
  - **Resolution:** Yes, `link` command also has `--verbose` (line 74) - user wants this updated too. Can be done after Phase 1 or in separate commit.

- [x] Should the `language` field be added to JSON output schema documentation?
  - **Resolution:** Yes, Phase 4 includes updating `research/docs/commands/list.md`

## Files to Modify Summary

| File | Phases | Changes |
|------|--------|---------|
| `research/cli/src/main.rs` | 1 | Add `short = 'v'` to List::verbose (and optionally Link::verbose) |
| `research/lib/Cargo.toml` | 5 | Add `reqwest` dependency with JSON feature |
| `research/lib/src/lib.rs` | 5 | Export `pub mod utils` |
| `research/lib/src/utils/mod.rs` | 5 | **NEW FILE** - Module declaration for `pub mod filename` |
| `research/lib/src/utils/filename.rs` | 5 | **NEW FILE** - `chooseFilename` and `fallback_filename` functions |
| `research/lib/src/list/format.rs` | 2, 3, 4, 6 | Fix description display, type badge format, add language icon helper, fix escape codes, update tests |
| `research/lib/src/list/discovery.rs` | 4 | Add LibraryInfo struct, update Metadata struct, extract language from metadata |
| `research/lib/src/list/types.rs` | 4 | Add `language: Option<String>` field to TopicInfo |
| `research/lib/tests/list_integration_test.rs` | 1, 2, 3, 4, 6 | Add tests for all new behaviors, update existing tests |
| `research/lib/tests/fixtures/.research/library/*/metadata.json` | 4 | Add test fixtures with library_info.language |
| `research/docs/commands/list.md` | 4 | Document new language field in JSON output schema |

**Total:** 2 new files, 9 modified files
