# Fixing Changelog Research Quality

**Created:** 2025-12-30
**Status:** Reviewed - Ready for Implementation

## Executive Summary

The changelog generation in the research library is the most fragile of all underlying research documents. This plan implements a multi-step changelog mining strategy that inspects repositories for structured information assets (CHANGELOG.md, GitHub Releases, package registry versions) before falling back to LLM knowledge. The output will include proper frontmatter with `created_at`, `updated_at`, and `latest_version` fields.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Implement multi-step changelog information mining strategy | High | Rust Developer |
| FR-2 | Search for CHANGELOG.md/HISTORY.md files in repositories | High | Rust Developer |
| FR-3 | Query GitHub Releases API for version history | High | Rust Developer |
| FR-4 | Parse package registry APIs (crates.io, npm, PyPI) for version data | High | Rust Developer |
| FR-5 | Generate minimal timeline if confident changelog unavailable | Medium | Rust Developer |
| FR-6 | Add frontmatter with `created_at`, `updated_at`, `latest_version` | High | Schema Architect |
| FR-7 | Update prompt template with structured mining instructions | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Changelog quality improvement (reduce "I don't know" responses) | >80% useful content | Rust Developer |
| NFR-2 | Respect rate limits for GitHub/registry APIs | No 429 errors | Rust Developer |
| NFR-3 | Graceful degradation when APIs unavailable | Fallback to LLM knowledge | Rust Developer |
| NFR-4 | Total changelog generation time | <60 seconds | Rust Developer |

## Architecture Overview

The enhanced changelog generation uses a **tiered information gathering** approach:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Changelog Generation Pipeline                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Tier 1: Structured Sources (Highest Confidence)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐              │
│  │ CHANGELOG.md│  │ GitHub      │  │ Package Registry│              │
│  │ HISTORY.md  │  │ Releases API│  │ Version History │              │
│  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘              │
│         │                │                   │                       │
│         ▼                ▼                   ▼                       │
│  ┌──────────────────────────────────────────────────────┐           │
│  │              Content Aggregator                       │           │
│  │  (Dedupe, merge, normalize dates/versions)           │           │
│  └──────────────────────────────────────────────────────┘           │
│                           │                                          │
│  Tier 2: LLM Synthesis    ▼                                         │
│  ┌──────────────────────────────────────────────────────┐           │
│  │              LLM Synthesizer (GPT-5.2)               │           │
│  │  - Enrich with context if structured sources exist   │           │
│  │  - Generate from knowledge if no sources found       │           │
│  │  - Produce minimal timeline as fallback              │           │
│  └──────────────────────────────────────────────────────┘           │
│                           │                                          │
│                           ▼                                          │
│  ┌──────────────────────────────────────────────────────┐           │
│  │              Output: changelog.md                     │           │
│  │  - Frontmatter: created_at, updated_at, latest_version│          │
│  │  - Version timeline table                             │           │
│  │  - Major version details                              │           │
│  │  - Confidence indicator                               │           │
│  └──────────────────────────────────────────────────────┘           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Data Flow

1. **Input**: Library name, package manager, repository URL (from LibraryInfo)
2. **Tier 1 Gathering**: Parallel API calls to fetch structured version data
3. **Aggregation**: Merge and normalize all gathered information
4. **LLM Synthesis**: Generate human-readable changelog with context
5. **Output**: Markdown document with frontmatter and structured content

## Phases

### Phase 1: Version Data Fetching Infrastructure

**Principal Owner:** Rust Developer

**Goal:** Create the infrastructure to fetch version history from multiple sources

**Dependencies:** None

**Blast Radius:** `cargo test -p research-lib --lib`

**Files to create:**

- `research/lib/src/changelog/mod.rs` - Module entry point
- `research/lib/src/changelog/types.rs` - VersionInfo, ChangelogSource, VersionHistory structs
- `research/lib/src/changelog/github.rs` - GitHub Releases API client
- `research/lib/src/changelog/registry.rs` - Package registry version fetching

**Dependencies to add:**

- `semver = "1.0"` (for robust version parsing and comparison)

**Deliverables:**

- `VersionInfo` struct with version string, release date, significance level
- `ChangelogSource` enum (GitHubRelease, ChangelogFile, RegistryVersion, LlmKnowledge)
- `VersionHistory` struct aggregating multiple sources
- `ChangelogError` error type with thiserror
- Flexible date parsing helper for various formats
- `Default`, `Ord` implementations for core types

**Technical Details:**

```rust
// research/lib/src/changelog/types.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Error types for changelog operations
#[derive(Error, Debug)]
pub enum ChangelogError {
    #[error("HTTP request failed: {0}")]
    Http(#[from] reqwest::Error),

    #[error("Failed to parse URL: {0}")]
    UrlParse(String),

    #[error("Failed to parse version: {0}")]
    VersionParse(String),

    #[error("Failed to parse JSON response: {0}")]
    JsonParse(#[from] serde_json::Error),

    #[error("GitHub API rate limit exceeded")]
    RateLimitExceeded,

    #[error("Failed to parse changelog file: {0}")]
    ParseError(String),

    #[error("No valid sources available")]
    NoSources,
}

/// Significance level for a version release
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum VersionSignificance {
    Major,      // 1.0.0, 2.0.0
    Minor,      // 1.1.0, 1.2.0 (with notable features)
    Patch,      // 1.0.1 (only if notable fix)
    Prerelease, // alpha, beta, rc
}

/// Information about a specific version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionInfo {
    pub version: String,
    pub release_date: Option<DateTime<Utc>>,
    pub significance: VersionSignificance,
    pub summary: Option<String>,
    pub breaking_changes: Vec<String>,
    pub new_features: Vec<String>,
    /// Sources that confirmed this version (multiple sources can validate same version)
    pub sources: Vec<ChangelogSource>,
}

/// Where the version information came from
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ChangelogSource {
    GitHubRelease,
    ChangelogFile,
    RegistryVersion,
    LlmKnowledge,
}

/// Aggregated version history from all sources
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionHistory {
    pub latest_version: String,
    pub versions: Vec<VersionInfo>,
    pub sources_used: Vec<ChangelogSource>,
    pub confidence: ConfidenceLevel,
}

impl Default for VersionHistory {
    fn default() -> Self {
        Self {
            latest_version: String::new(),
            versions: vec![],
            sources_used: vec![],
            confidence: ConfidenceLevel::Low,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConfidenceLevel {
    High,   // Structured sources available
    Medium, // Some structured + LLM knowledge
    Low,    // LLM knowledge only
}

/// Parse dates from various formats (ISO-8601, US, UK, relative)
pub fn parse_flexible_date(s: &str) -> Result<DateTime<Utc>, ChangelogError>;
```

**Acceptance Criteria:**

- [ ] File `research/lib/src/changelog/mod.rs` exists
- [ ] File `research/lib/src/changelog/types.rs` exists with >150 lines
- [ ] `grep "pub struct VersionInfo" research/lib/src/changelog/types.rs` succeeds
- [ ] `grep "pub struct VersionHistory" research/lib/src/changelog/types.rs` succeeds
- [ ] `grep "pub enum ChangelogError" research/lib/src/changelog/types.rs` succeeds
- [ ] `grep "impl Default for VersionHistory" research/lib/src/changelog/types.rs` succeeds
- [ ] `cargo test -p research-lib --lib changelog::types` runs 8+ tests
- [ ] Property tests verify: version ordering is transitive, deduplication is idempotent
- [ ] All new tests pass

---

### Phase 2: GitHub Releases API Integration

**Principal Owner:** Rust Developer

**Goal:** Implement GitHub Releases API client for fetching release information

**Dependencies:** Phase 1 (types)

**Blast Radius:** `cargo test -p research-lib --lib changelog`

**Files to create/modify:**

- `research/lib/src/changelog/github.rs` - GitHub Releases API client

**Deliverables:**

- GitHub API client with authentication support (optional token)
- Rate limit detection and backoff
- Release body parsing (markdown to structured info)
- URL extraction from package registry URLs

**Technical Details:**

```rust
// research/lib/src/changelog/github.rs

/// Fetch releases from GitHub Releases API
///
/// # Arguments
/// * `repo_url` - GitHub repository URL (e.g., https://github.com/owner/repo)
/// * `limit` - Maximum number of releases to fetch
///
/// # Returns
/// Vector of VersionInfo from GitHub releases
pub async fn fetch_github_releases(
    client: &HttpClient,
    repo_url: &str,
    limit: usize,
) -> Result<Vec<VersionInfo>, ChangelogError> {
    // 1. Parse owner/repo from URL
    // 2. Call https://api.github.com/repos/{owner}/{repo}/releases
    // 3. Handle rate limiting (X-RateLimit-Remaining header)
    // 4. Parse release body for breaking changes/features
    // 5. Return structured VersionInfo
}

/// Extract owner/repo from various GitHub URL formats
pub fn parse_github_url(url: &str) -> Option<(String, String)>;
```

**Environment Variables:**

- `GITHUB_TOKEN` (optional) - For higher rate limits (5000 req/hr vs 60 req/hr)

**HTTP Timeouts:**

- GitHub API requests: 10 seconds

**Acceptance Criteria:**

- [ ] File `research/lib/src/changelog/github.rs` exists with >150 lines
- [ ] `grep "pub async fn fetch_github_releases" research/lib/src/changelog/github.rs` succeeds
- [ ] `grep "parse_github_url" research/lib/src/changelog/github.rs` succeeds
- [ ] `cargo test -p research-lib --lib changelog::github` runs 10+ tests
- [ ] Unit tests mock GitHub API responses (no live calls in tests)
- [ ] Tests verify rate limiting: 429 response triggers backoff
- [ ] Tests verify error handling: malformed JSON, network timeout, invalid URL
- [ ] Tests verify URL parsing: handles github.com, raw.githubusercontent.com, git@ URLs
- [ ] All new tests pass

---

### Phase 3: Package Registry Version Fetching

**Principal Owner:** Rust Developer

**Goal:** Implement version fetching from package registries (crates.io, npm, PyPI)

**Dependencies:** Phase 1 (types)

**Blast Radius:** `cargo test -p research-lib --lib changelog`

**Files to create/modify:**

- `research/lib/src/changelog/registry.rs` - Package registry clients

**Deliverables:**

- crates.io version history fetching (existing code in lib.rs, refactor)
- npm registry version fetching
- PyPI version fetching
- Unified interface for all registries

**Technical Details:**

```rust
// research/lib/src/changelog/registry.rs

/// Fetch version history from a package registry
pub async fn fetch_registry_versions(
    client: &HttpClient,
    package_manager: &str,
    package_name: &str,
    limit: usize,
) -> Result<Vec<VersionInfo>, ChangelogError> {
    match package_manager {
        "crates.io" => fetch_crates_io_versions(client, package_name, limit).await,
        "npm" => fetch_npm_versions(client, package_name, limit).await,
        "PyPI" => fetch_pypi_versions(client, package_name, limit).await,
        _ => Ok(vec![]), // Unsupported registry
    }
}

// crates.io: GET https://crates.io/api/v1/crates/{name}/versions
// npm: GET https://registry.npmjs.org/{name}
// PyPI: GET https://pypi.org/pypi/{name}/json
```

**HTTP Timeouts:**

- Registry API requests: 5 seconds

**Acceptance Criteria:**

- [ ] File `research/lib/src/changelog/registry.rs` exists with >200 lines
- [ ] `grep "fetch_crates_io_versions" research/lib/src/changelog/registry.rs` succeeds
- [ ] `grep "fetch_npm_versions" research/lib/src/changelog/registry.rs` succeeds
- [ ] `grep "fetch_pypi_versions" research/lib/src/changelog/registry.rs` succeeds
- [ ] `cargo test -p research-lib --lib changelog::registry` runs 12+ tests
- [ ] Tests verify error handling: 404 (package not found), timeout, malformed JSON
- [ ] All new tests pass

---

### Phase 4: Changelog File Discovery via Web Scraping

**Principal Owner:** Rust Developer

**Goal:** Implement discovery and parsing of CHANGELOG.md files in repositories

**Dependencies:** Phase 2 (GitHub URL parsing)

**Blast Radius:** `cargo test -p research-lib --lib changelog`

**Files to create/modify:**

- `research/lib/src/changelog/discovery.rs` - File discovery and parsing

**Deliverables:**

- GitHub raw content fetching for CHANGELOG.md, HISTORY.md, NEWS.md
- Common changelog formats parsing (Keep a Changelog, conventional-changelog)
- Fallback file name patterns

**Technical Details:**

```rust
// research/lib/src/changelog/discovery.rs

/// Common changelog file names to search for (in priority order)
const CHANGELOG_FILES: &[&str] = &[
    "CHANGELOG.md",
    "CHANGELOG",
    "HISTORY.md",
    "HISTORY",
    "NEWS.md",
    "NEWS",
    "RELEASES.md",
    "CHANGES.md",
    "CHANGES",
];

/// Attempt to discover and fetch a changelog file from a repository
pub async fn discover_changelog_file(
    client: &HttpClient,
    repo_url: &str,
) -> Result<Option<String>, ChangelogError> {
    // 1. Parse repo URL to get raw content base URL
    // 2. Try each file name in order
    // 3. Return first successful fetch
}

/// Parse a Keep a Changelog format file
pub fn parse_keep_a_changelog(content: &str) -> Vec<VersionInfo>;

/// Parse a conventional-changelog format file
pub fn parse_conventional_changelog(content: &str) -> Vec<VersionInfo>;
```

**HTTP Timeouts:**

- Changelog file fetching: 15 seconds (potentially large files)

**File Size Limits:**

- Maximum changelog file size: 5MB (reject larger files)
- Maximum lines to parse: 5000 (for very large changelogs)

**Test Fixtures to Create:**

- `research/lib/tests/fixtures/changelogs/keep-a-changelog.md` - Standard Keep a Changelog format
- `research/lib/tests/fixtures/changelogs/conventional.md` - Conventional changelog format
- `research/lib/tests/fixtures/changelogs/malformed.md` - Invalid markdown, missing sections
- `research/lib/tests/fixtures/changelogs/empty.md` - Empty file

**Acceptance Criteria:**

- [ ] File `research/lib/src/changelog/discovery.rs` exists with >250 lines
- [ ] `grep "CHANGELOG_FILES" research/lib/src/changelog/discovery.rs` succeeds
- [ ] `grep "parse_keep_a_changelog" research/lib/src/changelog/discovery.rs` succeeds
- [ ] `cargo test -p research-lib --lib changelog::discovery` runs 15+ tests
- [ ] Parsing tests use fixture files with `include_str!`
- [ ] Tests cover at least 4 different changelog formats
- [ ] Tests include malformed/empty file handling
- [ ] All new tests pass

---

### Phase 5: Changelog Aggregator

**Principal Owner:** Rust Developer

**Goal:** Implement the aggregation layer that combines all sources into unified history

**Dependencies:** Phases 2, 3, 4

**Blast Radius:** `cargo test -p research-lib --lib changelog`

**Files to create/modify:**

- `research/lib/src/changelog/aggregator.rs` - Source aggregation and deduplication

**Deliverables:**

- Parallel fetching from all sources
- Version deduplication and merging
- Confidence level calculation
- Latest version determination

**Technical Details:**

```rust
// research/lib/src/changelog/aggregator.rs

/// Aggregate changelog information from all available sources
pub async fn aggregate_version_history(
    client: &HttpClient,
    library_info: &LibraryInfo,
) -> Result<VersionHistory, ChangelogError> {
    // 1. Parallel fetch from all sources
    let (github_result, registry_result, file_result) = tokio::join!(
        fetch_github_releases(client, &library_info.url, 50),
        fetch_registry_versions(client, &library_info.package_manager, &library_info.name, 100),
        discover_changelog_file(client, &library_info.url),
    );

    // 2. Merge and deduplicate
    // 3. Sort by date/version
    // 4. Calculate confidence level
    // 5. Return unified history
}

/// Merge version info from multiple sources, preferring structured sources
fn merge_version_info(versions: Vec<Vec<VersionInfo>>) -> Vec<VersionInfo>;

/// Calculate confidence level based on sources used
fn calculate_confidence(sources: &[ChangelogSource]) -> ConfidenceLevel;
```

**Deduplication Strategy (Source Precedence):**

- **Version matching**: Use semver for exact matching (use `semver` crate)
- **Date conflicts**: Prefer ChangelogFile → GitHubRelease → RegistryVersion → LlmKnowledge
- **Content merging**: Combine `breaking_changes` and `new_features` from all sources (deduped)
- **Sources field**: Accumulate all sources that confirmed the version

**Confidence Calculation:**

- High: GitHub Releases + (Registry OR ChangelogFile)
- Medium: One structured source OR LLM-enriched structured data
- Low: LLM knowledge only

**Acceptance Criteria:**

- [ ] File `research/lib/src/changelog/aggregator.rs` exists with >200 lines
- [ ] `grep "pub async fn aggregate_version_history" research/lib/src/changelog/aggregator.rs` succeeds
- [ ] `grep "merge_version_info" research/lib/src/changelog/aggregator.rs` succeeds
- [ ] `cargo test -p research-lib --lib changelog::aggregator` runs 12+ tests
- [ ] Tests verify deduplication: same version from multiple sources merged correctly
- [ ] Tests verify confidence calculation: all three tiers
- [ ] Tests verify parallel fetching: all sources execute concurrently
- [ ] Tests verify graceful degradation: one source fails, others continue
- [ ] All new tests pass

---

### Phase 6: Enhanced Changelog Prompt Template

**Principal Owner:** Rust Developer

**Goal:** Update the changelog prompt to use aggregated version data

**Dependencies:** Phase 5

**Blast Radius:** `cargo test -p research-lib`

**Files to modify:**

- `research/lib/prompts/changelog.md` - Enhanced prompt template
- `research/lib/src/lib.rs` - Integration with aggregator

**Deliverables:**

- Updated prompt template with version history context
- Frontmatter generation with required fields
- Fallback minimal timeline generation
- Integration with existing Phase 1 pipeline

**Technical Details:**

The new prompt template will receive pre-gathered structured data:

```markdown
# Version History for {{topic}}

You are synthesizing changelog information for the **{{topic}}** library.

**Library Context:**
- Package Manager: {{package_manager}}
- Language: {{language}}
- URL: {{url}}

## Pre-gathered Version Data

The following version information was gathered from structured sources:

{{version_data}}

**Data Confidence:** {{confidence_level}}
**Sources Used:** {{sources_used}}

## Your Task

Based on the pre-gathered data above (if available) and your training knowledge:

1. **If structured data exists:** Synthesize it into a readable changelog format, enriching with context where helpful.

2. **If no structured data exists:** Generate the best changelog you can from your knowledge, being explicit about uncertainty.

3. **If you cannot produce a confident changelog:** Generate a minimal timeline showing:
   - First known stable release date
   - Major version release dates (1.0, 2.0, etc.)
   - Current version information

## Required Output Format

Your response MUST begin with YAML frontmatter:

```yaml
---
created_at: {{current_date}}
updated_at: {{current_date}}
latest_version: "X.Y.Z"
confidence: high|medium|low
sources:
  - github_releases
  - changelog_file
  - registry_versions
  - llm_knowledge
---
```

[Rest of changelog content following the existing structure...]

```

**Frontmatter Validation:**
- Use existing `validation::parse_and_validate_frontmatter` function
- Extend with changelog-specific validation (required fields: `created_at`, `updated_at`, `latest_version`)
- Create `ChangelogFrontmatter` struct for type-safe validation

**Acceptance Criteria:**
- [ ] File `research/lib/prompts/changelog.md` updated with >100 lines
- [ ] `grep "version_data" research/lib/prompts/changelog.md` succeeds
- [ ] `grep "confidence_level" research/lib/prompts/changelog.md` succeeds
- [ ] `grep "frontmatter" research/lib/prompts/changelog.md` succeeds
- [ ] Tests verify frontmatter parsing: valid YAML, missing fields, invalid dates
- [ ] Tests verify frontmatter validation rejects invalid inputs
- [ ] Integration tests pass with mock version data
- [ ] All existing tests pass

---

### Phase 7: Integration with Research Pipeline

**Principal Owner:** Rust Developer

**Goal:** Integrate the new changelog system with the existing research pipeline

**Dependencies:** Phase 6

**Blast Radius:** `cargo test -p research-lib`

**Files to modify:**
- `research/lib/src/lib.rs` - Update changelog task creation

**Deliverables:**
- Pre-fetch version history before LLM call
- Inject version data into prompt
- Handle aggregation failures gracefully
- Update metadata.json with changelog metadata

**Technical Details:**

```rust
// In lib.rs, update the changelog task

// Before: Direct LLM call with basic prompt
// After:
// 1. Call aggregate_version_history()
// 2. Format version data for prompt injection
// 3. Call LLM with enriched prompt
// 4. Parse frontmatter from response
// 5. Update metadata.json with latest_version

async fn run_changelog_task(
    task_name: &str,
    filename: &str,
    output_dir: PathBuf,
    client: &HttpClient,
    library_info: &LibraryInfo,
    model: impl CompletionModel,
    // ... other params
) -> PromptTaskResult {
    // 1. Aggregate version history
    let version_history = aggregate_version_history(client, library_info).await;

    // 2. Build enhanced prompt
    let prompt = build_changelog_prompt(&version_history, library_info);

    // 3. Call LLM
    let response = model.prompt(&prompt).await?;

    // 4. Write output with frontmatter validation
    // 5. Return result with metadata
}
```

**Integration Notes:**

- Update `build_prompt()` helper to accept `Option<&VersionHistory>` parameter
- Use existing `HttpClient` from research pipeline (already threaded through)
- Handle `LibraryInfo.repository` (Option<String>): prefer if available, fall back to `url` field

**Acceptance Criteria:**

- [ ] Changelog task uses aggregator before LLM call
- [ ] Version data injected into prompt template
- [ ] Graceful fallback when aggregation fails
- [ ] `cargo test -p research-lib` all tests pass
- [ ] Integration test with mocked "serde" fixture produces valid frontmatter
- [ ] Integration test verifies graceful degradation: all sources fail → LLM-only fallback
- [ ] Integration test verifies confidence calculation: structured sources → High, mixed → Medium, LLM-only → Low
- [ ] Use `validation::parse_and_validate_frontmatter` after LLM response, regenerate if invalid

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests**: Each changelog module (`types`, `github`, `registry`, `discovery`, `aggregator`)
- **Integration tests**: End-to-end changelog generation with mocked APIs
- **Fixture tests**: Parse known changelog formats (Keep a Changelog, conventional-changelog)
- **Property tests**: Version sorting, deduplication logic

### Security Considerations

- Rate limit detection for GitHub API (check X-RateLimit-Remaining)
- Timeout on HTTP requests (10s default)
- Validate URL formats before fetching
- No credential storage (use environment variables for GitHub token if needed)

### Performance Considerations

- Parallel fetching from all sources (tokio::join!)
- Early exit if high-confidence source found
- Cache HTTP client across requests
- Limit version fetch count (100 versions max)

### Error Handling

- `ChangelogError` type with thiserror
- Graceful degradation: if one source fails, continue with others
- Log warnings for API failures, don't fail entire research
- Fallback to LLM-only if all structured sources fail

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Foundation types, no dependencies |
| Group B | Phase 2, 3, 4 | Independent API clients, all depend only on Phase 1 |
| Group C | Phase 5 | Aggregator depends on all of Group B |
| Group D | Phase 6, 7 | Integration, sequential dependency |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────────────────►

Phase 1: ████████ (Types/Foundation)
                │
Phase 2: ───────┴──████████ (GitHub API)
Phase 3: ───────┴──████████ (Registry API)     ← Parallel
Phase 4: ───────┴──████████ (File Discovery)
                          │
Phase 5: ─────────────────┴──████████ (Aggregator)
                                    │
Phase 6: ───────────────────────────┴──████████ (Prompt Template)
                                              │
Phase 7: ─────────────────────────────────────┴──████████ (Integration)
```

### Synchronization Points

1. **After Phase 1:** Types must be defined before API clients
2. **After Phases 2-4:** All data sources must be implemented before aggregator
3. **After Phase 6:** Prompt template must be ready before integration

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| GitHub API rate limiting | Medium | Use conditional requests, optional auth token, backoff |
| Package registries down | Low | Graceful degradation to LLM-only |
| Changelog file format variations | Medium | Multiple parsers, fallback to raw content |
| LLM generates invalid frontmatter | Medium | Parse and validate frontmatter, regenerate if invalid |
| Increased research time | Low | Parallel fetching, timeout limits |

## Open Questions

- [x] Should we support GitHub token for higher rate limits? → **Yes, `GITHUB_TOKEN` env var added to Phase 2**
- [x] Should changelog file content be cached locally? → **No for MVP. Research outputs are already cached.**
- [x] How to handle monorepo packages with shared changelog? → **Defer to future work. Document as limitation.**
- [x] Should we parse release notes for migration guides? → **No. Too complex for initial implementation.**

---

## Review Summary

**Reviews Completed:** 2025-12-30

**Reviewers:**

- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. **Added `ChangelogError` type definition** to Phase 1 (was missing, would cause compilation failures)
2. **Changed `VersionInfo.source` to `sources: Vec<ChangelogSource>`** to track multiple validation sources
3. **Added `semver` dependency** for correct version sorting
4. **Added `Default`, `Ord` implementations** for core types
5. **Documented deduplication/merge strategy** for Phase 5 aggregator
6. **Added `GITHUB_TOKEN` environment variable** support in Phase 2
7. **Added explicit HTTP timeout values** (10s GitHub, 5s registries, 15s files)
8. **Added file size limits** (5MB max) for changelog file parsing
9. **Added test fixture creation** requirements in Phase 4
10. **Replaced live API integration test** with mocked fixtures
11. **Added frontmatter validation integration** with existing validation module
12. **Enhanced acceptance criteria** with specific error path testing

**Resolved Concerns:**

| Concern | Resolution |
|---------|------------|
| Missing `ChangelogError` type | Added to Phase 1 types.rs with thiserror |
| Single source field in VersionInfo | Changed to `sources: Vec<ChangelogSource>` |
| Deduplication strategy undefined | Documented precedence order and merge rules |
| HTTP client sharing unclear | Clarified reuse of existing HttpClient |
| Frontmatter validation | Integrated with existing `validation::frontmatter` module |
| Rate limiting not testable | Added wiremock tests for 429 responses |
| Live API tests non-deterministic | Replaced with mocked fixture tests |
| Large changelog files could OOM | Added 5MB size limit and 5000 line limit |

**Deferred Items (Future Work):**

- Monorepo changelog handling
- Migration guide extraction from release notes
- Local caching of changelog file content
- `async-trait` for pluggable fetchers
