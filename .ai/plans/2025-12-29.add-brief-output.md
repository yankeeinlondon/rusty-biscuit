# Plan: Add `brief.md` Output File to Research CLI

## Overview

Add a new Phase 2 output file `brief.md` that provides a concise summary of the deep dive document. This file includes frontmatter with a single-sentence summary and repository URL, plus a paragraph-length description in the body.

## Requirements

1. **New output file:** `brief.md`
   - Frontmatter with `summary` (single sentence), `repo` (repository URL)
   - Body: paragraph-length summary of the deep dive

2. **Parallel generation:** Both summaries (sentence + paragraph) generated in parallel using `gemini-3-flash-preview`

3. **Metadata updates:** Add to `metadata.json`:
   - `brief`: single-sentence summary
   - `summary`: paragraph-length description

4. **Repository URL:** Extract actual repo URL from package manager APIs (not just package manager page URL)

---

## Phase 1: Extend Data Structures and API Parsing

**Principal Owner:** Rust Developer

**Goal:** Add repository URL extraction and update metadata structures

### 1.1 Update `LibraryInfo` struct

**File:** `research/lib/src/lib.rs:186-191`

```rust
pub struct LibraryInfo {
    pub package_manager: String,
    pub language: String,
    pub url: String,                    // Package manager page URL
    pub repository: Option<String>,     // NEW: Actual source repository URL
    pub description: Option<String>,
}
```

### 1.2 Update `LibraryInfoMetadata` struct

**File:** `research/lib/src/lib.rs:236-240`

```rust
pub struct LibraryInfoMetadata {
    pub package_manager: String,
    pub language: String,
    pub url: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,     // NEW
}
```

### 1.3 Update `ResearchMetadata` struct

**File:** `research/lib/src/lib.rs:219-232`

```rust
pub struct ResearchMetadata {
    pub kind: ResearchKind,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub library_info: Option<LibraryInfoMetadata>,
    #[serde(default)]
    pub additional_files: std::collections::HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    // NEW fields
    #[serde(skip_serializing_if = "Option::is_none")]
    pub brief: Option<String>,          // Single-sentence summary
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,        // Paragraph summary
}
```

### 1.4 Update API response structs for repository extraction

**File:** `research/lib/src/lib.rs:347-395` (add repository fields)

#### crates.io
```rust
#[derive(Debug, Deserialize)]
struct CratesIoCrate {
    description: Option<String>,
    repository: Option<String>,         // NEW
}
```

#### npm
```rust
#[derive(Debug, Deserialize)]
struct NpmResponse {
    description: Option<String>,
    repository: Option<NpmRepository>,  // NEW
}

#[derive(Debug, Deserialize)]
struct NpmRepository {
    url: Option<String>,
}
```

#### PyPI
```rust
#[derive(Debug, Deserialize)]
struct PyPIInfo {
    summary: Option<String>,
    project_urls: Option<HashMap<String, String>>,  // NEW - contains "Repository" key
}
```

### 1.5 Update check_* functions to extract repository

Update each `check_*` function to populate the new `repository` field:

- `check_crates_io`: Use `data.krate.repository`
- `check_npm`: Parse `data.repository.url` (format: `git+https://...`)
- `check_pypi`: Use `data.info.project_urls["Repository"]` or `["Source"]`
- Others: Leave as `None` (can be enhanced later)

### 1.6 Update `From<&LibraryInfo> for LibraryInfoMetadata`

**File:** `research/lib/src/lib.rs:242-250`

```rust
impl From<&LibraryInfo> for LibraryInfoMetadata {
    fn from(info: &LibraryInfo) -> Self {
        Self {
            package_manager: info.package_manager.clone(),
            language: info.language.clone(),
            url: info.url.clone(),
            repository: info.repository.clone(),  // NEW
        }
    }
}
```

### Acceptance Criteria
- [ ] `LibraryInfo` has `repository: Option<String>` field
- [ ] `LibraryInfoMetadata` has `repository: Option<String>` field
- [ ] `ResearchMetadata` has `brief` and `summary` fields
- [ ] crates.io returns repository URL when available
- [ ] npm returns repository URL (cleaned from git+ prefix)
- [ ] PyPI returns repository URL from project_urls
- [ ] All conversions between structs preserve repository field

---

## Phase 2: Create Brief Prompt Template

**Principal Owner:** Rust Developer

**Goal:** Create the prompt template for brief generation

### 2.1 Create `research/lib/prompts/brief.md`

```markdown
You are creating a brief summary of the '{{topic}}' library.

Using this comprehensive deep dive document:

{{deep_dive}}

Generate a brief summary with exactly two parts:

## Part 1: One-Sentence Summary (BRIEF)
Write a single sentence (under 100 characters) that captures the essence of what this library does. Be specific and technical. This will be used as metadata.

Format: Start with "BRIEF:" followed by the sentence.

## Part 2: Paragraph Summary (SUMMARY)
Write a single paragraph (3-5 sentences, under 500 characters) that expands on the brief to include:
- Primary purpose and use cases
- Key distinguishing features
- Target audience or typical users

Format: Start with "SUMMARY:" followed by the paragraph.

## Output Format
Output ONLY these two labeled sections, nothing else:

BRIEF: [single sentence]

SUMMARY: [paragraph]
```

### 2.2 Add prompt constant

**File:** `research/lib/src/lib.rs:140-144`

```rust
pub mod prompts {
    pub const CONTEXT: &str = include_str!("../prompts/context.md");
    pub const SKILL: &str = include_str!("../prompts/skill.md");
    pub const DEEP_DIVE: &str = include_str!("../prompts/deep_dive.md");
    pub const BRIEF: &str = include_str!("../prompts/brief.md");  // NEW
}
```

### Acceptance Criteria
- [ ] `research/lib/prompts/brief.md` exists with template
- [ ] `prompts::BRIEF` constant is defined
- [ ] Prompt clearly separates BRIEF and SUMMARY outputs

---

## Phase 3: Implement Brief Generation in Phase 2 Pipeline

**Principal Owner:** Rust Developer

**Goal:** Add parallel brief generation after deep_dive.md is created

### 3.1 Add brief parsing helper function

**File:** `research/lib/src/lib.rs` (new function)

```rust
/// Parse the brief response into (brief, summary) tuple
fn parse_brief_response(response: &str) -> (Option<String>, Option<String>) {
    let mut brief = None;
    let mut summary = None;

    for line in response.lines() {
        let line = line.trim();
        if line.starts_with("BRIEF:") {
            brief = Some(line.trim_start_matches("BRIEF:").trim().to_string());
        } else if line.starts_with("SUMMARY:") {
            // Summary might span multiple lines until end
            let start = response.find("SUMMARY:").unwrap() + 8;
            summary = Some(response[start..].trim().to_string());
            break;
        }
    }

    (brief, summary)
}
```

### 3.2 Update `run_fresh_research` function

**File:** `research/lib/src/lib.rs` (around line 2255)

After the current Phase 2 parallel execution, add brief generation:

```rust
// === Phase 2b: Generate brief from deep_dive (if successful) ===
let (brief_text, summary_text) = if deep_dive_result.is_ok() {
    println!("Generating brief summary...\n");

    // Read the deep_dive content
    let deep_dive_content = fs::read_to_string(output_dir.join("deep_dive.md"))
        .await
        .unwrap_or_default();

    let brief_prompt = prompts::BRIEF
        .replace("{{topic}}", topic)
        .replace("{{deep_dive}}", &deep_dive_content);

    let brief_model = gemini.completion_model("gemini-3-flash-preview");

    match brief_model.prompt(&brief_prompt).await {
        Ok(response) => {
            let (brief, summary) = parse_brief_response(&response);

            // Write brief.md file
            if let (Some(ref b), Some(ref s)) = (&brief, &summary) {
                let repo_url = library_info.as_ref()
                    .and_then(|li| li.repository.as_ref())
                    .map(|r| format!("repo: {}\n", r))
                    .unwrap_or_default();

                let brief_content = format!(
                    "---\nsummary: {}\n{}---\n\n{}",
                    b, repo_url, s
                );
                let _ = fs::write(output_dir.join("brief.md"), brief_content).await;
                println!("[3/3] brief ✓");
            }

            (brief, summary)
        }
        Err(e) => {
            eprintln!("Warning: Failed to generate brief: {}", e);
            (None, None)
        }
    }
} else {
    (None, None)
};
```

### 3.3 Update metadata saving to include brief/summary

**File:** `research/lib/src/lib.rs` (around line 2345-2352)

```rust
// Write metadata.json
let mut metadata = ResearchMetadata::new_library(library_info.as_ref());
metadata.brief = brief_text;      // NEW
metadata.summary = summary_text;  // NEW
for (i, question) in questions.iter().enumerate() {
    let filename = format!("question_{}.md", i + 1);
    metadata.add_additional_file(filename, question.clone());
}
if let Err(e) = metadata.save(&output_dir).await {
    eprintln!("Warning: Failed to write metadata.json: {}", e);
}
```

### 3.4 Update `run_incremental_research` similarly

**File:** `research/lib/src/lib.rs` (around line 1556-1628)

Apply the same changes to the incremental research path.

### Acceptance Criteria
- [ ] Brief generation runs after deep_dive.md is created
- [ ] Uses `gemini-3-flash-preview` model
- [ ] Parses BRIEF and SUMMARY from response
- [ ] Writes `brief.md` with correct frontmatter structure
- [ ] Updates metadata with `brief` and `summary` fields
- [ ] Works in both fresh and incremental research paths
- [ ] Handles errors gracefully (doesn't fail entire research)

---

## Phase 4: Update Documentation

**Principal Owner:** Rust Developer

**Goal:** Document the new output file

### 4.1 Update `research/README.md`

Add to the "Summary Deliverables" section:

```markdown
#### 3. Brief (`brief.md`)

- A compact summary for quick reference
- Frontmatter includes:
  - `summary`: Single-sentence description
  - `repo`: Link to source repository (when available)
- Body contains a paragraph-length overview
- Generated using Gemini Flash from the deep dive
```

Update the pipeline diagram:

```
Phase 2: Synthesis (parallel, after Phase 1)
├── skill/SKILL.md       [GPT-5.2]
├── deep_dive.md         [GPT-5.2]
└── brief.md             [Gemini Flash] (after deep_dive)
```

Update metadata example:

```json
{
  "kind": "library",
  "library_info": {
    "package_manager": "crates.io",
    "language": "Rust",
    "url": "https://crates.io/crates/clap",
    "repository": "https://github.com/clap-rs/clap"
  },
  "brief": "A full-featured command-line argument parser for Rust applications.",
  "summary": "clap is a fast, full-featured argument parser for Rust that supports...",
  "additional_files": {},
  "created_at": "2025-12-28T10:00:00Z",
  "updated_at": "2025-12-28T10:00:00Z"
}
```

### Acceptance Criteria
- [ ] README documents `brief.md` structure
- [ ] Pipeline diagram updated
- [ ] Metadata example shows new fields
- [ ] Repository field documented in library_info

---

## Testing Strategy

### Unit Tests

1. **`parse_brief_response` tests:**
   - Valid response with both BRIEF and SUMMARY
   - Response with only BRIEF
   - Response with only SUMMARY
   - Malformed response (returns None, None)
   - Multi-line SUMMARY handling

2. **Repository extraction tests:**
   - crates.io with repository
   - npm with repository (git+https format)
   - PyPI with project_urls
   - All with missing repository (returns None)

### Integration Tests

1. **Fresh research with brief generation:**
   - Run full research pipeline
   - Verify `brief.md` created with correct format
   - Verify `metadata.json` contains brief/summary

2. **Incremental research:**
   - Run incremental update
   - Verify brief is regenerated

### Manual Testing

```bash
# Test fresh research
research library clap

# Verify outputs
cat ~/.research/library/clap/brief.md
cat ~/.research/library/clap/metadata.json | jq '.brief, .summary'
```

---

## File Changes Summary

| File | Changes |
|------|---------|
| `research/lib/src/lib.rs` | Add repository fields, metadata fields, brief generation logic, parse helper |
| `research/lib/prompts/brief.md` | NEW - Brief generation prompt template |
| `research/README.md` | Document new output and metadata fields |

---

## Implementation Order

1. Phase 1: Data structures and API parsing (foundation)
2. Phase 2: Prompt template (no dependencies)
3. Phase 3: Pipeline integration (depends on 1 & 2)
4. Phase 4: Documentation (after implementation verified)

Phases 1 and 2 can run in parallel.

---

## Risk Assessment

| Risk | Mitigation |
|------|------------|
| Gemini Flash rate limiting | Brief generation is non-critical; graceful degradation |
| Repository URL not available | `repo` field is optional in frontmatter |
| Parsing failures | Robust error handling; don't fail research if brief fails |
| Increased API costs | Single additional Gemini call per research (low cost) |
