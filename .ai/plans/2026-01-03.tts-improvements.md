# TTS Improvements in Shared Library

**Created:** 2026-01-03
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Refactor the TTS module (`shared/src/tts.rs`) to remove convenience wrapper functions, introduce a `VoiceConfig` struct with builder pattern for voice configuration, add proper error handling with `speak()` returning `Result`, and update all callers to use `speak_when_able()`.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Remove `announce_completion()`, `announce_research_complete()`, `format_completion_message()`, `format_research_message()` functions | High | Rust Developer |
| FR-2 | Create `VoiceConfig` struct with builder pattern (`with_voice()`, `of_gender()`, `with_volume()`) | High | Schema Architect |
| FR-3 | Refactor `speak()` to return `Result<(), TtsError>` | High | Rust Developer |
| FR-4 | Add `speak_when_able()` function that ignores errors | High | Rust Developer |
| FR-5 | Add `available_system_voices()` function to query host voices | Medium | Rust Developer |
| FR-6 | Update all callers in monorepo to use `speak_when_able()` | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Maintain existing blocking behavior for speech | 100% compatibility | Rust Developer |
| NFR-2 | Error types must use thiserror with proper source chaining | thiserror integration | Rust Developer |
| NFR-3 | API should be ergonomic with builder pattern | Developer experience | Schema Architect |
| NFR-4 | All public enums must be extensible | `#[non_exhaustive]` on all enums | Schema Architect |

## Architecture Overview

### Current State

```
shared/src/tts.rs
├── speak(message: &str)              # Ignores errors
├── announce_completion(task: &str)   # TO BE REMOVED
├── announce_research_complete(lib)   # TO BE REMOVED
├── format_completion_message(task)   # TO BE REMOVED
└── format_research_message(lib)      # TO BE REMOVED

Callers:
├── so-you-say/src/main.rs           # Uses shared::tts::speak()
└── research/cli/src/main.rs         # Has local announce_completion()
```

### Target State

```
shared/src/tts.rs
├── VoiceConfig struct                # NEW: Builder for voice config (renamed from Voice)
│   ├── language: Language
│   ├── voice_stack: Vec<VoiceSelector>
│   ├── gender: Gender
│   └── volume: Volume                # NEW: Validated newtype
├── speak(message, config) -> Result  # NEW: Returns Result
├── speak_when_able(message, config)  # NEW: Ignores errors
├── available_system_voices()         # NEW: Query host voices (renamed)
├── TtsError enum                     # NEW: Error types with #[source]
├── Gender enum                       # NEW: #[non_exhaustive]
├── Language enum                     # NEW: #[non_exhaustive]
├── VoiceSelector enum                # NEW: Renamed from KnownVoice
├── Volume newtype                    # NEW: Validated f32 wrapper
└── SystemVoiceInfo struct            # NEW: Wrapper for tts::Voice

Callers updated:
├── so-you-say/src/main.rs           # speak_when_able()
└── research/cli/src/main.rs         # speak_when_able() with inline message
```

### Data Flow

```
User Message → VoiceConfig (builder pattern) → speak()/speak_when_able()
                                                      ↓
                                            tts::Tts::default()
                                                      ↓
                                            Voice selection algorithm:
                                            1. Try each VoiceSelector in voice_stack
                                            2. Fall back to language filtering
                                            3. Fall back to any English voice
                                            4. Return TtsError::NoSuitableVoice
                                                      ↓
                                            tts.speak() + blocking wait
                                                      ↓
                                            Result<(), TtsError> / ()
```

## Phases

### Phase 1: Core Types and Error Handling

**Principal Owner:** Schema Architect

**Goal:** Define all type foundations for the refactored TTS module

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib tts`

**Files to create/modify:**
- `shared/src/tts.rs` - Add new types at top of file (keep existing functions temporarily)

**Deliverables:**

1. `TtsError` enum with thiserror and proper source chaining:
   ```rust
   #[non_exhaustive]
   #[derive(Debug, thiserror::Error)]
   pub enum TtsError {
       #[error("TTS initialization failed")]
       InitFailed {
           #[source]
           source: Box<dyn std::error::Error + Send + Sync>,
       },
       #[error("Voice selection failed: {reason}")]
       VoiceSelectionFailed { reason: String },
       #[error("Speech failed")]
       SpeechFailed {
           #[source]
           source: Box<dyn std::error::Error + Send + Sync>,
       },
       #[error("No suitable voice found (language: {language})")]
       NoSuitableVoice { language: String },
   }
   ```

2. `Gender` enum:
   ```rust
   #[non_exhaustive]
   #[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
   pub enum Gender {
       Male,
       Female,
       #[default]
       Any,
   }
   ```

3. `Language` enum:
   ```rust
   #[non_exhaustive]
   #[derive(Debug, Clone, Default, PartialEq, Eq)]
   pub enum Language {
       #[default]
       English,
       /// Custom language code (BCP-47 format recommended, e.g., "fr-FR", "es-MX")
       Custom(String),
   }

   impl Language {
       /// Returns the language code prefix for voice matching
       pub fn code_prefix(&self) -> &str {
           match self {
               Language::English => "en",
               Language::Custom(code) => code,
           }
       }
   }
   ```

4. `VoiceSelector` enum (renamed from `KnownVoice` for clarity):
   ```rust
   #[non_exhaustive]
   #[derive(Debug, Clone, PartialEq, Eq)]
   pub enum VoiceSelector {
       /// Select system voice by exact ID match
       ById(String),
       /// Select system voice by name match
       ByName(String),
   }
   ```

5. `Volume` newtype with validation:
   ```rust
   #[derive(Debug, Clone, Copy, PartialEq)]
   pub struct Volume(f32);

   impl Volume {
       /// Create a new Volume, clamping to valid range [0.0, 1.0]
       pub fn new(value: f32) -> Self {
           Self(value.clamp(0.0, 1.0))
       }

       /// Get the volume value
       pub fn get(&self) -> f32 {
           self.0
       }
   }

   impl Default for Volume {
       fn default() -> Self {
           Self(1.0)
       }
   }
   ```

6. `VoiceConfig` struct (renamed from `Voice` to avoid collision with `tts::Voice`):
   ```rust
   #[derive(Debug, Clone)]
   pub struct VoiceConfig {
       pub language: Language,
       pub voice_stack: Vec<VoiceSelector>,
       pub gender: Gender,
       pub volume: Volume,
   }

   impl Default for VoiceConfig {
       fn default() -> Self {
           Self {
               language: Language::default(),
               voice_stack: Vec::new(),
               gender: Gender::default(),
               volume: Volume::default(),
           }
       }
   }
   ```

7. `SystemVoiceInfo` struct (wrapper for `tts::Voice` to avoid leaking internal types):
   ```rust
   #[derive(Debug, Clone)]
   pub struct SystemVoiceInfo {
       pub id: String,
       pub name: String,
       pub language: String,
   }
   ```

**Technical Details:**
- All public enums have `#[non_exhaustive]` for future extensibility
- `TtsError` uses `#[source]` for proper error chaining
- `Volume` newtype prevents invalid states at compile time
- `VoiceConfig` renamed from `Voice` to avoid collision with `tts::Voice`
- `VoiceSelector` renamed from `KnownVoice` for semantic clarity
- Gender filtering removed from voice selection (TTS API doesn't expose gender reliably)

**Acceptance Criteria:**
- [ ] File `shared/src/tts.rs` contains `TtsError` enum with 4 variants and `#[non_exhaustive]`
- [ ] `grep "#\[non_exhaustive\]" shared/src/tts.rs` shows at least 4 matches
- [ ] `grep "pub enum Gender" shared/src/tts.rs` succeeds
- [ ] `grep "pub enum Language" shared/src/tts.rs` succeeds
- [ ] `grep "pub enum VoiceSelector" shared/src/tts.rs` succeeds
- [ ] `grep "pub struct VoiceConfig" shared/src/tts.rs` succeeds
- [ ] `grep "pub struct Volume" shared/src/tts.rs` succeeds
- [ ] `grep "pub struct SystemVoiceInfo" shared/src/tts.rs` succeeds
- [ ] `cargo test -p shared --lib tts` passes
- [ ] At least 10 unit tests for type behavior:
  - [ ] `TtsError::InitFailed` displays correctly
  - [ ] `TtsError::NoSuitableVoice` displays correctly with language
  - [ ] `Gender::default()` returns `Gender::Any`
  - [ ] `Language::default()` returns `Language::English`
  - [ ] `Language::code_prefix()` returns correct values
  - [ ] `VoiceConfig::default()` has empty `voice_stack`
  - [ ] `VoiceConfig::default()` has `Volume(1.0)`
  - [ ] `Volume::new(1.5)` clamps to 1.0
  - [ ] `Volume::new(-0.5)` clamps to 0.0
  - [ ] `Volume::default()` returns 1.0

---

### Phase 2: Voice Builder Pattern

**Principal Owner:** Rust Developer

**Goal:** Implement the builder pattern for VoiceConfig configuration

**Dependencies:** Phase 1 (types must exist)

**Blast Radius:** `cargo test -p shared --lib tts`

**Files to modify:**
- `shared/src/tts.rs` - Add impl blocks for VoiceConfig

**Deliverables:**

1. `VoiceConfig::new()` constructor:
   ```rust
   impl VoiceConfig {
       pub fn new() -> Self {
           Self::default()
       }
   }
   ```

2. Builder methods (all return `Self`, marked `#[must_use]`):
   ```rust
   #[must_use]
   pub fn with_voice(mut self, voice: VoiceSelector) -> Self {
       self.voice_stack.push(voice);
       self
   }

   #[must_use]
   pub fn of_gender(mut self, gender: Gender) -> Self {
       self.gender = gender;
       self
   }

   #[must_use]
   pub fn with_volume(mut self, volume: f32) -> Self {
       self.volume = Volume::new(volume);
       self
   }

   #[must_use]
   pub fn with_language(mut self, language: Language) -> Self {
       self.language = language;
       self
   }
   ```

3. Convenience constructors:
   ```rust
   /// Create a VoiceConfig with a specific voice by name
   pub fn with_name(name: impl Into<String>) -> Self {
       Self::new().with_voice(VoiceSelector::ByName(name.into()))
   }

   /// Create a VoiceConfig with a specific voice by ID
   pub fn with_id(id: impl Into<String>) -> Self {
       Self::new().with_voice(VoiceSelector::ById(id.into()))
   }
   ```

**Technical Details:**
- Builder pattern uses move semantics (takes `self`, returns `Self`)
- `#[must_use]` on builder methods prevents accidentally discarding built config
- Volume uses `Volume::new()` which handles clamping internally
- Voice stack preserves insertion order (first match wins)

**Acceptance Criteria:**
- [ ] `VoiceConfig::new()` returns default VoiceConfig
- [ ] Chained builder calls work: `VoiceConfig::new().of_gender(Gender::Female).with_volume(0.8)`
- [ ] Multiple `with_voice()` calls preserve insertion order
- [ ] `VoiceConfig::with_name("Alice")` creates config with that voice
- [ ] `VoiceConfig::with_id("com.apple.voice.Alex")` creates config with that voice
- [ ] Volume clamping: `with_volume(1.5)` results in volume of 1.0
- [ ] Volume clamping: `with_volume(-0.5)` results in volume of 0.0
- [ ] `cargo test -p shared --lib tts` runs at least 15 tests
- [ ] All new tests pass

---

### Phase 3: Core Speech Functions

**Principal Owner:** Rust Developer

**Goal:** Implement the new `speak()` and `speak_when_able()` functions

**Dependencies:** Phase 2 (VoiceConfig builder must work)

**Blast Radius:** `cargo test -p shared --lib tts`

**Files to modify:**
- `shared/src/tts.rs` - Add new speak functions, keep old temporarily

**Deliverables:**

1. `speak(message: &str, config: &VoiceConfig) -> Result<(), TtsError>`:
   ```rust
   /// Speak a message using the system's TTS engine.
   ///
   /// # Blocking
   /// This function blocks the current thread until speech completes.
   ///
   /// # Errors
   /// Returns `TtsError` if TTS initialization, voice selection, or speech fails.
   #[tracing::instrument(skip(config), fields(message_len = message.len()))]
   pub fn speak(message: &str, config: &VoiceConfig) -> Result<(), TtsError> {
       // Implementation details below
   }
   ```

2. `speak_when_able(message: &str, config: &VoiceConfig)`:
   ```rust
   /// Speak a message, ignoring any errors.
   ///
   /// This is the fire-and-forget variant of `speak()`. Use when TTS is
   /// a nice-to-have feature and failures shouldn't affect the main flow.
   ///
   /// # Blocking
   /// This function blocks the current thread until speech completes (if successful).
   pub fn speak_when_able(message: &str, config: &VoiceConfig) {
       if let Err(e) = speak(message, config) {
           tracing::debug!(error = ?e, "TTS failed (non-fatal)");
       }
   }
   ```

3. `available_system_voices() -> Result<Vec<SystemVoiceInfo>, TtsError>`:
   ```rust
   /// Query the system's available TTS voices.
   ///
   /// # Errors
   /// Returns `TtsError::InitFailed` if TTS initialization fails.
   pub fn available_system_voices() -> Result<Vec<SystemVoiceInfo>, TtsError> {
       let tts = Tts::default().map_err(|e| TtsError::InitFailed {
           source: Box::new(e),
       })?;

       let voices = tts.voices().map_err(|e| TtsError::InitFailed {
           source: Box::new(e),
       })?;

       Ok(voices.into_iter().map(|v| SystemVoiceInfo {
           id: v.id().to_string(),
           name: v.name().to_string(),
           language: v.language().to_string(),
       }).collect())
   }
   ```

**Voice Selection Algorithm** (detailed pseudocode):
```rust
fn select_voice(tts: &mut Tts, config: &VoiceConfig) -> Result<(), TtsError> {
    let voices = tts.voices().map_err(...)?;

    // Step 1: Try each VoiceSelector in voice_stack order
    for selector in &config.voice_stack {
        match selector {
            VoiceSelector::ById(id) => {
                if let Some(voice) = voices.iter().find(|v| v.id() == id) {
                    tts.set_voice(voice).map_err(...)?;
                    return Ok(());
                }
            }
            VoiceSelector::ByName(name) => {
                if let Some(voice) = voices.iter().find(|v| v.name() == name) {
                    tts.set_voice(voice).map_err(...)?;
                    return Ok(());
                }
            }
        }
    }

    // Step 2: Fall back to language filtering (excluding compact/eloquence)
    let lang_prefix = config.language.code_prefix();
    if let Some(voice) = voices.iter().find(|v| {
        let id = v.id().to_lowercase();
        !id.contains("compact")
            && !id.contains("eloquence")
            && v.language().starts_with(lang_prefix)
    }) {
        tts.set_voice(voice).map_err(...)?;
        return Ok(());
    }

    // Step 3: Final fallback - any English voice
    if let Some(voice) = voices.iter().find(|v| v.language().starts_with("en")) {
        tts.set_voice(voice).map_err(...)?;
        return Ok(());
    }

    // Step 4: No suitable voice found
    Err(TtsError::NoSuitableVoice {
        language: lang_prefix.to_string(),
    })
}
```

**Technical Details:**
- Voice selection removes gender filtering (TTS API doesn't expose gender reliably)
- Preserves current "compact"/"eloquence" filtering behavior
- Blocking behavior preserved from existing implementation (100ms poll loop)
- Tracing instrumentation added for observability
- Error variants used appropriately with `#[source]` for chaining

**Acceptance Criteria:**
- [ ] `speak("test", &VoiceConfig::default())` returns `Result<(), TtsError>`
- [ ] `speak_when_able("test", &VoiceConfig::default())` compiles and runs without panic
- [ ] `available_system_voices()` returns `Result<Vec<SystemVoiceInfo>, TtsError>`
- [ ] `SystemVoiceInfo` has `id`, `name`, `language` fields
- [ ] Voice selection tries voice_stack first, then language, then fallback
- [ ] `TtsError::InitFailed` returned when `Tts::default()` fails
- [ ] `TtsError::SpeechFailed` returned when `tts.speak()` fails
- [ ] `TtsError::NoSuitableVoice` returned when no voice matches
- [ ] `cargo test -p shared --lib tts` runs at least 20 tests
- [ ] All tests pass

---

### Phase 4: Remove Deprecated Functions and Update Callers

**Principal Owner:** Rust Developer

**Goal:** Remove the deprecated wrapper functions and update all callers

**Dependencies:** Phase 3 (new functions must work)

**Blast Radius:** `cargo test -p shared && cargo test -p so-you-say && cargo test -p research-cli`

**Files to modify:**
- `shared/src/tts.rs` - Remove deprecated functions and their tests
- `so-you-say/src/main.rs` - Update to use `speak_when_able()`
- `research/cli/src/main.rs` - Update to use `speak_when_able()` with inline message

**Deliverables:**

1. Remove from `shared/src/tts.rs`:
   - `announce_completion()` function
   - `announce_research_complete()` function
   - `format_completion_message()` function
   - `format_research_message()` function
   - All associated tests for these functions
   - Old `speak(message: &str)` function (replaced by new signature)

2. Update `so-you-say/src/main.rs`:
   ```rust
   // Before:
   shared::tts::speak(&message);

   // After:
   shared::tts::speak_when_able(&message, &shared::tts::VoiceConfig::default());
   ```

3. Update `research/cli/src/main.rs`:
   - Remove local `announce_completion()` function (lines 295-315)
   - Replace call with:
   ```rust
   // Before:
   announce_completion(&result.topic);

   // After:
   use shared::tts::{speak_when_able, VoiceConfig};
   let message = format!("Research for the {} library has completed", result.topic);
   speak_when_able(&message, &VoiceConfig::default());
   ```
   - Remove unused `use tts::Tts;` import (line 8)

**Technical Details:**
- Callers now construct their own messages (no more magic formatting)
- All callers use `speak_when_able()` for fire-and-forget behavior
- `VoiceConfig::default()` provides sensible defaults matching current behavior

**Regression Tests:**
- [ ] `speak_when_able()` behavior identical to old `speak()` (ignores errors)
- [ ] Blocking behavior preserved: Function blocks until speech completes
- [ ] Default voice selection matches old English voice filtering behavior

**Acceptance Criteria:**
- [ ] `grep "announce_completion" shared/src/tts.rs` returns no matches
- [ ] `grep "announce_research_complete" shared/src/tts.rs` returns no matches
- [ ] `grep "format_completion_message" shared/src/tts.rs` returns no matches
- [ ] `grep "format_research_message" shared/src/tts.rs` returns no matches
- [ ] `grep "fn speak(message: &str)" shared/src/tts.rs` returns no matches (old signature gone)
- [ ] `so-you-say/src/main.rs` uses `speak_when_able()` with `VoiceConfig::default()`
- [ ] `research/cli/src/main.rs` uses `speak_when_able()` with inline message format
- [ ] `research/cli/src/main.rs` does not contain local `announce_completion` function
- [ ] `research/cli/src/main.rs` does not have `use tts::Tts;` import
- [ ] `cargo test -p shared --lib tts` passes
- [ ] `cargo test -p so-you-say` passes
- [ ] `cargo test -p research-cli` passes
- [ ] `cargo build --workspace` succeeds

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests:** `#[cfg(test)] mod tests` in `shared/src/tts.rs`
  - Type construction and defaults (10 tests minimum)
  - Builder pattern chaining and volume clamping (8 tests minimum)
  - Voice selection algorithm with mocked voice lists (6 tests minimum)
  - Error variant construction and Display formatting (4 tests minimum)
  - Regression: `speak_when_able()` matches old behavior (2 tests minimum)
- **Mock Strategy:** The voice selection algorithm can be tested by:
  - Creating a list of mock `SystemVoiceInfo` structs
  - Testing the selection logic separately from actual TTS calls
  - Hardware-dependent tests (actual speech) marked with `#[ignore]` for CI
- **Integration tests:** Manual testing required (TTS is hardware-dependent)
- **Doc tests:** Examples in rustdoc for builder pattern, speak functions

### Error Handling

- `TtsError` uses thiserror for derive with `#[source]` for proper error chaining
- Errors preserve full context from underlying `tts` crate
- `speak_when_able()` logs errors at debug level before ignoring

### API Design Considerations

- Builder pattern uses move semantics with `#[must_use]` for ergonomic chaining
- `VoiceConfig::default()` provides English, any gender, normal volume
- `VoiceSelector` allows both ID-based and name-based voice selection
- All public enums are `#[non_exhaustive]` for future extensibility
- `Volume` newtype prevents invalid states at construction time

### Observability

- `speak()` has tracing instrumentation with message length field
- Errors are logged at debug level in `speak_when_able()` for troubleshooting

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Types can be implemented independently |
| Sequential | Phase 2 | Depends on Phase 1 types |
| Sequential | Phase 3 | Depends on Phase 2 builder |
| Sequential | Phase 4 | Depends on Phase 3 functions |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────►

Phase 1: ████████ (Core types)
                │
Phase 2:        └──████████ (VoiceConfig builder)
                        │
Phase 3:                └──████████ (Speech functions)
                                │
Phase 4:                        └──████████ (Remove deprecated, update callers)
```

### Phase 1 Internal Parallelization

If multiple developers available, Phase 1 can be split:
- Developer A: `TtsError` + `Volume` newtype
- Developer B: `Gender` + `Language` enums
- Developer C: `VoiceSelector` enum + `VoiceConfig` + `SystemVoiceInfo` structs

### Synchronization Points

1. **After Phase 1:** All types must compile before builder implementation
2. **After Phase 3:** New functions must work before removing old ones
3. **Final:** All workspace tests must pass

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| TTS crate API changes | Medium | Pin tts version in Cargo.toml |
| Platform-specific voice selection issues | Low | Fallback to any English voice, test on macOS |
| Breaking callers during refactor | High | Keep old functions until Phase 4, test incrementally |
| Name collision with tts::Voice | Medium | Renamed to VoiceConfig |

## Resolved Open Questions

- **Regex matching for voice IDs?** No - YAGNI. Add if user demand emerges.
- **Volume enum vs f32?** Use `Volume` newtype (f32 wrapper with validation) for flexibility while preventing invalid states.
- **`available_voices()` filtering?** Return all voices with rich metadata (`SystemVoiceInfo`) and let callers filter.
- **Gender filtering in voice selection?** Removed - TTS API doesn't expose gender reliably.

## Review Summary

**Reviews Completed:** 2026-01-03

**Reviewers:**
- Rust Developer: Request Revision → Changes incorporated
- Rust Architect: Approve with Changes → Changes incorporated
- Schema Architect: Approve with Changes → Changes incorporated
- Feature Tester (Rust): Request Revision → Changes incorporated

**Key Changes from Review:**

1. **Naming:** Renamed `Voice` → `VoiceConfig` to avoid collision with `tts::Voice`
2. **Naming:** Renamed `KnownVoice` → `VoiceSelector` for semantic clarity
3. **Naming:** Renamed `available_voices()` → `available_system_voices()` for clarity
4. **Naming:** Renamed `default_volume` → `volume` (clearer purpose)
5. **Types:** Added `Volume` newtype to prevent invalid states
6. **Types:** Added `SystemVoiceInfo` struct to avoid leaking `tts::Voice` in public API
7. **Extensibility:** Added `#[non_exhaustive]` to all public enums
8. **Errors:** Changed `TtsError` to use `#[source]` for proper error chaining
9. **Errors:** Updated `NoSuitableVoice` to include language context
10. **API:** Added `#[must_use]` to builder methods
11. **API:** Added convenience constructors `VoiceConfig::with_name()` and `VoiceConfig::with_id()`
12. **Algorithm:** Removed gender filtering from voice selection (unreliable in TTS API)
13. **Testing:** Expanded test requirements with specific scenarios (30+ tests total)
14. **Observability:** Added tracing instrumentation to `speak()`

**Resolved Concerns:**
- Voice selection algorithm now clearly documented with pseudocode
- Error chaining preserves underlying TTS errors
- Volume validation happens at construction time via newtype
- All public types are extensible via `#[non_exhaustive]`
