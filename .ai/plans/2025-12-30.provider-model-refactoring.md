# Provider & Model System Refactoring Plan

**Created:** 2025-12-30
**Status:** ⚡ IN PROGRESS - 5/7 Phases Complete (71%)
**Last Updated:** 2025-12-30

## Executive Summary

This plan refactors the `shared` library's provider and model system to eliminate code duplication, introduce a strongly-typed `ProviderModel` enum for compile-time model safety, create a dedicated `api` module for API utilities, and implement intelligent prompt filename generation in the research area. The refactoring addresses code review findings while adding powerful new capabilities for model management and discovery.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Create `ProviderModel` enum with static variants for known models and String outlets for bleeding-edge models | High | Schema Architect |
| FR-2 | Implement `TryFrom<String>` and `TryFrom<&str>` for `ProviderModel` with API validation fallback | High | Rust Developer |
| FR-3 | Implement `ProviderModel::update()` to refresh enum definition from provider APIs | High | Rust Developer |
| FR-4 | Move duplicate types (`OpenAIModelsResponse`, `OpenAIModel`) to `providers/types.rs` | High | Rust Developer |
| FR-5 | Extract retry logic (`is_rate_limit_error`, `fetch_with_retry`) to `providers/retry.rs` | High | Rust Developer |
| FR-6 | Extract duplicate constants to `providers/constants.rs` | Medium | Rust Developer |
| FR-7 | Create `api` module with `get_provider_models_from_api()` and `get_all_provider_models()` | High | Rust Developer |
| FR-8 | Implement `extract_prompt_name()` for manual prompt naming via `filename -> prompt` syntax | High | Rust Developer |
| FR-9 | Enhance `choose_filename()` with validation against core research documents | Medium | Rust Developer |
| FR-10 | Add unique filename collision resolution with `_1`, `_2` suffixes | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Code duplication eliminated (DRY principle) | 0 duplicate functions | Rust Architect |
| NFR-2 | `ProviderModel` update should cache results to avoid repeated API calls | 24hr cache like existing | Rust Developer |
| NFR-3 | API validation timeout for `TryFrom` should be short | ≤ 5 seconds | Rust Developer |
| NFR-4 | Prompt filename generation should fail gracefully | Fallback to `question_N.md` | Rust Developer |
| NFR-5 | All public APIs must have rustdoc examples | 100% coverage | Rust Architect |
| NFR-6 | Test coverage for new functionality | >80% | Feature Tester (Rust) |

## Architecture Overview

### Current State Issues

1. **Code Duplication:**
   - `OpenAIModelsResponse` and `OpenAIModel` defined in both `base.rs` and `discovery.rs`
   - `is_rate_limit_error()` and `fetch_with_retry()` duplicated across `base.rs` and `discovery.rs`
   - HTTP constants (`REQUEST_TIMEOUT`, etc.) duplicated

2. **Weak Typing:**
   - Models represented as `String` - no compile-time safety
   - No distinction between known models and experimental/undocumented ones

3. **Module Organization:**
   - No dedicated `api` module for API primitives
   - Provider-specific logic scattered across `base.rs` and `discovery.rs`

### Proposed Architecture

```
shared/src/
├── api/
│   ├── mod.rs              # Public API module exports
│   ├── types.rs            # ApiAuth, ApiEndpoint, etc.
│   ├── openai_compat.rs    # OpenAI-compatible API utilities
│   └── README.md           # Module documentation (exists)
│
├── providers/
│   ├── mod.rs              # Re-exports
│   ├── base.rs             # Provider enum, API key management (simplified)
│   ├── discovery.rs        # High-level discovery orchestration (simplified)
│   ├── types.rs            # ProviderModel enum, OpenAIModelsResponse, etc. (NEW/UPDATED)
│   ├── retry.rs            # Retry logic utilities (NEW)
│   ├── constants.rs        # Shared HTTP constants (NEW)
│   ├── curated.rs          # Static model lists (existing)
│   └── cache.rs            # 24hr caching (existing)
│
└── model/
    ├── mod.rs              # Model selection module (existing)
    ├── types.rs            # Model-related types (existing)
    └── selection.rs        # Model selection logic (existing)
```

### Component Diagram

```
┌──────────────────────────────────────────────────────────────┐
│                     Application Layer                        │
│  ┌────────────────┐    ┌────────────────┐                    │
│  │  research-cli  │    │  so-you-say    │                    │
│  └────────────────┘    └────────────────┘                    │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                  shared::providers (NEW)                     │
│  ┌──────────────────────────────────────────────────────────┐│
│  │  types::ProviderModel enum                               ││
│  │  ├─ Anthropic__ClaudeOpus_4_5_20251101                   ││
│  │  ├─ Anthropic(String)  ← outlet for undocumented models  ││
│  │  ├─ OpenRouter__Anthropic__Opus_4_5_20251101             ││
│  │  └─ TryFrom<String> with API validation                  ││
│  └──────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────┐│
│  │  retry.rs - Shared retry logic                           ││
│  │  constants.rs - HTTP/retry constants                     ││
│  │  base.rs - Provider enum, API keys (uses retry.rs)       ││
│  │  discovery.rs - Orchestration (uses retry.rs)            ││
│  └──────────────────────────────────────────────────────────┘│
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                      shared::api (NEW)                       │
│  ┌──────────────────────────────────────────────────────────┐│
│  │  openai_compat.rs                                        ││
│  │  ├─ get_provider_models_from_api(provider, api_key)      ││
│  │  └─ get_all_provider_models() → HashMap<Provider, Vec>   ││
│  └──────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────┐│
│  │  types.rs                                                ││
│  │  ├─ ApiAuth enum (Bearer, Header, Query)                ││
│  │  ├─ ApiEndpoint struct                                  ││
│  │  └─ OpenAIModelsResponse (moved from providers)         ││
│  └──────────────────────────────────────────────────────────┘│
└──────────────────────────────────────────────────────────────┘
```

### Data Flow

**Model Discovery & Validation:**

```
User code: ProviderModel::try_from("anthropic/claude-opus-4-5-20251101")?
    │
    ├─ 1. Check static variants (naming convention match)
    │     └─ Match! → Return Anthropic__ClaudeOpus_4_5_20251101
    │
    ├─ 2. No static match → Call api::get_provider_models_from_api()
    │     ├─ Check cache (24hr)
    │     ├─ If cache miss → HTTP GET /v1/models
    │     └─ Validate model exists
    │
    └─ 3. Return Anthropic(String) outlet or Err
```

**Update Flow (`ProviderModel::update()`):**

```
ProviderModel::update()
    │
    ├─ 1. Call api::get_all_provider_models()
    │     ├─ base::get_api_keys() → available providers
    │     ├─ Parallel calls to each provider's /v1/models
    │     └─ Parse & aggregate results
    │
    ├─ 2. Detect new models (not in current enum)
    │     ├─ Aggregator hints (OpenRouter) → add aggregator variant
    │     └─ Direct provider access → add underlying provider variant
    │
    ├─ 3. Generate new enum code via codegen::inject_enum()
    │     └─ Update providers/types.rs with new variants
    │
    └─ 4. Return update summary (models added, providers checked)
```

## Phases

**Progress: 5/7 Complete (71%)**

| Phase | Name | Status | Completion |
|-------|------|--------|------------|
| 0 | Setup and Shared Utilities | ✅ COMPLETE | 2025-12-30 |
| 1 | API Module - Provider Model Discovery | ✅ COMPLETE | 2025-12-30 |
| 2 | ProviderModel Enum - Type Definition | ✅ COMPLETE | 2025-12-30 |
| 3 | ProviderModel TryFrom Implementation | ✅ COMPLETE | 2025-12-30 |
| 4 | ProviderModel Update Mechanism | ⏸️ PENDING | Not started |
| 5 | Research - Prompt Filename Extraction | ✅ COMPLETE | 2025-12-30 |
| 6 | Research - Enhanced Filename Generation | ⏸️ READY | Phase 5 satisfied |
| 7 | Documentation and Code Review | ⏸️ BLOCKED | Needs 4, 6 |

---

### Phase 0: Setup and Shared Utilities ✅ COMPLETE

**Principal Owner:** Rust Developer
**Completed:** 2025-12-30
**Status:** ✅ All acceptance criteria met, 85 tests passing

**Goal:** Create shared modules that eliminate duplication and establish foundations for subsequent phases.

**Dependencies:** None

**Blast Radius:** `cargo test --lib providers`

**Files to create:**
- `shared/src/providers/retry.rs` - Retry logic utilities
- `shared/src/providers/constants.rs` - HTTP/retry constants
- `shared/src/api/mod.rs` - API module entry point
- `shared/src/api/types.rs` - API types (ApiAuth, etc.)

**Files to modify:**
- `shared/src/lib.rs` - Add `pub mod api;`
- `shared/src/providers/types.rs` - Add `OpenAIModelsResponse`, `OpenAIModel` (move from base.rs/discovery.rs)
- `shared/src/providers/base.rs` - Remove duplicates, import from new modules
- `shared/src/providers/discovery.rs` - Remove duplicates, import from new modules

**Deliverables:**

1. **`providers/constants.rs`:**
   ```rust
   use std::time::Duration;

   pub const REQUEST_TIMEOUT: Duration = Duration::from_secs(30);
   pub const MAX_RESPONSE_SIZE: usize = 10 * 1024 * 1024; // 10MB
   pub const INITIAL_RETRY_DELAY: Duration = Duration::from_secs(1);
   pub const MAX_RETRY_DELAY: Duration = Duration::from_secs(30);
   pub const RETRY_MULTIPLIER: f64 = 2.0;
   pub const MAX_RETRIES: u32 = 3;
   ```

2. **`providers/retry.rs`:**
   - Move `is_rate_limit_error(status: StatusCode) -> bool`
   - Move `async fn fetch_with_retry<F, Fut, T, E>(...) -> Result<T, E>`
   - Use constants from `constants.rs`
   - Add comprehensive rustdoc with examples
   - Add unit tests for retry logic (mock HTTP responses)

3. **`providers/types.rs` updates:**
   - Move `OpenAIModelsResponse` and `OpenAIModel` from `base.rs` and `discovery.rs`
   - Make structs public
   - Add rustdoc comments
   - Keep existing `LlmEntry`, `ProviderListFormat` (already there)

4. **`api/types.rs`:**
   ```rust
   /// API authentication methods
   #[derive(Debug, Clone, PartialEq, Eq)]
   pub enum ApiAuth {
       Bearer(String),          // Authorization: Bearer {token}
       HeaderKey(String, String), // Custom header: {name}: {value}
       QueryParam(String, String), // URL query: ?{name}={value}
       None,                    // No auth (local providers)
   }

   /// API endpoint configuration
   #[derive(Debug, Clone)]
   pub struct ApiEndpoint {
       pub base_url: String,
       pub path: String,
       pub auth: ApiAuth,
   }
   ```

5. **Update imports in `base.rs` and `discovery.rs`:**
   - Replace local constants with `use super::constants::*;`
   - Replace local retry functions with `use super::retry::*;`
   - Replace local types with `use super::types::{OpenAIModelsResponse, OpenAIModel};`

**Technical Details:**
- `retry.rs` should use `#[tracing::instrument]` for observability
- All moved code should maintain existing behavior (refactor, not rewrite)
- Tests should be moved alongside code (keep existing coverage)
- Document migration path in rustdoc (e.g., "Moved from `base.rs` in refactoring")

**Acceptance Criteria:**
- [ ] File `shared/src/providers/constants.rs` exists with 6 constants
- [ ] File `shared/src/providers/retry.rs` exists with `is_rate_limit_error()` and `fetch_with_retry()`
- [ ] `providers/types.rs` contains `OpenAIModelsResponse` and `OpenAIModel` (no duplicates in base.rs/discovery.rs)
- [ ] File `shared/src/api/types.rs` exists with `ApiAuth` and `ApiEndpoint`
- [ ] File `shared/src/api/mod.rs` exists and exports types
- [ ] `shared/src/lib.rs` contains `pub mod api;`
- [ ] `grep "const REQUEST_TIMEOUT" shared/src/providers/base.rs` returns no matches
- [ ] `grep "const REQUEST_TIMEOUT" shared/src/providers/discovery.rs` returns no matches
- [ ] `grep "OpenAIModelsResponse" shared/src/providers/base.rs` returns only import statement
- [ ] `grep "fn fetch_with_retry" shared/src/providers/base.rs` returns no matches
- [ ] All tests pass: `cargo test --lib providers`
- [ ] `cargo clippy --lib` reports no warnings

---

### Phase 1: API Module - Provider Model Discovery Functions ✅ COMPLETE

**Principal Owner:** Rust Developer
**Completed:** 2025-12-30
**Status:** ✅ All acceptance criteria met, 49 tests passing

**Goal:** Implement `api::openai_compat` module with functions to fetch models from OpenAI-compatible APIs.

**Dependencies:** Phase 0 (needs retry.rs, constants.rs, api/types.rs)

**Blast Radius:** `cargo test --lib api`

**Files to create:**
- `shared/src/api/openai_compat.rs` - OpenAI-compatible API utilities

**Files to modify:**
- `shared/src/api/mod.rs` - Export new functions
- `shared/src/providers/base.rs` - Refactor `get_provider_models()` to use `api::get_all_provider_models()`

**Deliverables:**

1. **`api/openai_compat.rs`:**

   ```rust
   /// Fetch models from a single provider's OpenAI-compatible API
   ///
   /// ## Arguments
   /// * `provider` - The provider to query
   /// * `api_key` - API key for authentication
   ///
   /// ## Returns
   /// Vec of model IDs (unprefixed, as returned by API)
   ///
   /// ## Errors
   /// - `ProviderError::RateLimitExceeded` - 429 response
   /// - `ProviderError::AuthenticationFailed` - 401/403 response
   /// - `ProviderError::Timeout` - Request exceeded timeout
   ///
   /// ## Examples
   /// ```no_run
   /// use shared::api::openai_compat::get_provider_models_from_api;
   /// use shared::providers::Provider;
   ///
   /// #[tokio::main]
   /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
   ///     let models = get_provider_models_from_api(
   ///         Provider::OpenAi,
   ///         "sk-..."
   ///     ).await?;
   ///     println!("OpenAI models: {:?}", models);
   ///     Ok(())
   /// }
   /// ```
   #[tracing::instrument(skip(api_key))]
   pub async fn get_provider_models_from_api(
       provider: Provider,
       api_key: &str,
   ) -> Result<Vec<String>, ProviderError> {
       // Implementation...
   }

   /// Fetch models from all available providers
   ///
   /// Queries all providers that have API keys configured in environment.
   /// Runs API calls in parallel for efficiency.
   ///
   /// ## Returns
   /// HashMap mapping Provider to Vec of model IDs (unprefixed)
   ///
   /// ## Notes
   /// - Local providers (Ollama) included if accessible
   /// - Providers without API keys are skipped (logged at DEBUG level)
   /// - Individual provider failures logged but don't fail entire operation
   ///
   /// ## Examples
   /// ```no_run
   /// use shared::api::openai_compat::get_all_provider_models;
   ///
   /// #[tokio::main]
   /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
   ///     let all_models = get_all_provider_models().await?;
   ///     for (provider, models) in &all_models {
   ///         println!("{:?}: {} models", provider, models.len());
   ///     }
   ///     Ok(())
   /// }
   /// ```
   #[tracing::instrument]
   pub async fn get_all_provider_models() -> Result<HashMap<Provider, Vec<String>>, ProviderError> {
       // Implementation...
   }
   ```

2. **Refactor `providers/base.rs::get_provider_models()`:**
   - Replace implementation with call to `api::get_all_provider_models()`
   - Add provider prefix to model IDs: `{provider}/{model_id}`
   - Keep existing caching behavior
   - Maintain existing function signature and public API

**Technical Details:**
- Use `providers::retry::fetch_with_retry()` for HTTP requests
- Use `providers::constants::*` for timeouts and limits
- Use `PROVIDER_BASE_URLS` from `providers::base` for endpoint discovery
- Parse responses using `api::types::OpenAIModelsResponse`
- Parallelize API calls with `futures::stream::iter().buffer_unordered(8)`
- Skip ZenMux (no /v1/models support - document in code)
- Cache results for 24hr using existing `providers::cache` module

**Acceptance Criteria:**
- [ ] File `shared/src/api/openai_compat.rs` exists with >200 lines
- [ ] Function `get_provider_models_from_api()` implemented with rustdoc
- [ ] Function `get_all_provider_models()` implemented with rustdoc
- [ ] `shared/src/api/mod.rs` exports both functions
- [ ] `providers/base.rs::get_provider_models()` calls `api::get_all_provider_models()`
- [ ] All tests pass: `cargo test --lib api`
- [ ] All tests pass: `cargo test --lib providers::base`
- [ ] Unit tests added: 5+ tests in `api/openai_compat.rs` (wiremock for HTTP mocking)
- [ ] Doc tests compile: `cargo test --doc api::openai_compat`

---

### Phase 2: ProviderModel Enum - Type Definition ✅ COMPLETE

**Principal Owner:** Schema Architect
**Completed:** 2025-12-30
**Status:** ✅ All acceptance criteria met, 10 static variants (per review feedback), 19 tests passing

**Goal:** Design and implement the `ProviderModel` enum with static variants for known models and String outlets for undocumented models.

**Dependencies:** Phase 1 (needs api::get_all_provider_models)

**Blast Radius:** `cargo test --lib providers::types`

**Files to create:**
- None (editing `shared/src/providers/types.rs`)

**Files to modify:**
- `shared/src/providers/types.rs` - Add `ProviderModel` enum
- `shared/src/providers/mod.rs` - Re-export `ProviderModel`

**Deliverables:**

1. **`ProviderModel` enum in `providers/types.rs`:**

   ```rust
   /// Strongly-typed enumeration of LLM provider models
   ///
   /// This enum provides compile-time safety for known models while allowing
   /// runtime flexibility for bleeding-edge or undocumented models via String outlets.
   ///
   /// ## Naming Convention
   /// Static variants use: `{Provider}__{ModelId}` with special characters converted:
   /// - Hyphens `-` → Underscores `_`
   /// - Dots `.` → Underscores `_`
   /// - Colons `:` → Removed
   ///
   /// ## Examples
   /// ```
   /// use shared::providers::ProviderModel;
   ///
   /// // Known model (compile-time safe)
   /// let model = ProviderModel::Anthropic__ClaudeOpus_4_5_20251101;
   ///
   /// // Undocumented model (runtime string outlet)
   /// let bleeding_edge = ProviderModel::Anthropic("claude-opus-5-experimental".to_string());
   ///
   /// // Parse from string
   /// let parsed: ProviderModel = "anthropic/claude-opus-4-5-20251101".try_into()?;
   /// ```
   #[derive(Debug, Clone, PartialEq, Eq, Hash)]
   pub enum ProviderModel {
       // Anthropic models
       Anthropic__ClaudeOpus_4_5_20251101,
       Anthropic__ClaudeSonnet_4_5_20250929,
       Anthropic__ClaudeHaiku_4_0_20250107,
       Anthropic(String), // Outlet for undocumented Anthropic models

       // OpenAI models
       OpenAi__Gpt_4o,
       OpenAi__Gpt_4o_Mini,
       OpenAi__O1,
       OpenAi__O1_Mini,
       OpenAi(String), // Outlet for undocumented OpenAI models

       // Deepseek models
       Deepseek__Chat,
       Deepseek__Reasoner,
       Deepseek(String),

       // Gemini models
       Gemini__Gemini_3_Flash_Preview,
       Gemini__Gemini_3_Flash_Thinking,
       Gemini__Gemini_2_0_Flash_Exp,
       Gemini(String),

       // MoonshotAI models
       MoonshotAi__Moonshot_V1_8k,
       MoonshotAi__Moonshot_V1_32k,
       MoonshotAi__Moonshot_V1_128k,
       MoonshotAi(String),

       // Ollama (local models - no static variants, always use outlet)
       Ollama(String),

       // OpenRouter aggregator
       OpenRouter__Anthropic__ClaudeOpus_4_5_20251101,
       OpenRouter__OpenAi__Gpt_4o,
       OpenRouter__Deepseek__Chat,
       OpenRouter(String),

       // ZAI models
       Zai__Glm_4_7,
       Zai__Glm_4_32k,
       Zai(String),

       // ZenMux aggregator
       ZenMux(String), // No /v1/models support, always use outlet
   }
   ```

2. **Implementation guidelines:**
   - Initial static variants based on curated list from `providers/curated.rs`
   - Total ~50-80 static variants across all providers
   - String outlets (`Anthropic(String)`, etc.) for flexibility
   - Document in rustdoc: "Generated and updated via `ProviderModel::update()` - do not edit manually"

**Technical Details:**
- Enum will be meta-programmed in Phase 3, but start with manual definition
- Use descriptive variant names based on official model IDs
- Add `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- Consider using `strum` crate for enum utilities if helpful
- Document naming convention clearly in rustdoc

**Acceptance Criteria:**
- [ ] `ProviderModel` enum defined in `shared/src/providers/types.rs`
- [ ] Enum has ~50-80 static variants covering major models
- [ ] Each provider has a String outlet variant (e.g., `Anthropic(String)`)
- [ ] `shared/src/providers/mod.rs` re-exports `ProviderModel`
- [ ] Rustdoc comments added with examples
- [ ] `cargo build --lib` succeeds
- [ ] `cargo clippy --lib` reports no warnings

---

### Phase 3: ProviderModel TryFrom Implementation ✅ COMPLETE

**Principal Owner:** Rust Developer
**Completed:** 2025-12-30
**Status:** ✅ All acceptance criteria met, synchronous TryFrom (per review feedback), 31 tests passing

**Goal:** Implement `TryFrom<String>` and `TryFrom<&str>` for `ProviderModel` with naming convention matching and API validation fallback.

**Dependencies:** Phase 2 (needs ProviderModel enum)

**Blast Radius:** `cargo test --lib providers::types`

**Files to modify:**
- `shared/src/providers/types.rs` - Add `TryFrom` implementations

**Deliverables:**

1. **`TryFrom<String>` implementation:**

   ```rust
   impl TryFrom<String> for ProviderModel {
       type Error = ProviderError;

       /// Convert a string like "anthropic/claude-opus-4-5-20251101" to ProviderModel
       ///
       /// ## Conversion Strategy
       /// 1. Check static variants using naming convention
       /// 2. If no match, call API to validate model exists
       /// 3. Return String outlet variant if valid, error if not
       ///
       /// ## Errors
       /// - `ProviderError::InvalidModelString` - Malformed input
       /// - `ProviderError::UnknownModel` - Not in enum and not found via API
       /// - `ProviderError::Timeout` - API validation timed out
       ///
       /// ## Examples
       /// ```
       /// use shared::providers::ProviderModel;
       ///
       /// // Known model - no API call
       /// let model: ProviderModel = "anthropic/claude-opus-4-5-20251101".to_string().try_into()?;
       /// assert!(matches!(model, ProviderModel::Anthropic__ClaudeOpus_4_5_20251101));
       ///
       /// // Unknown model - validates via API, uses outlet
       /// let experimental: ProviderModel = "anthropic/claude-opus-5-experimental".to_string().try_into()?;
       /// assert!(matches!(experimental, ProviderModel::Anthropic(_)));
       /// ```
       fn try_from(value: String) -> Result<Self, Self::Error> {
           // Implementation...
       }
   }

   impl TryFrom<&str> for ProviderModel {
       type Error = ProviderError;

       fn try_from(value: &str) -> Result<Self, Self::Error> {
           value.to_string().try_from()
       }
   }
   ```

2. **Naming convention conversion logic:**
   - Parse `{provider}/{model-id}` format
   - Convert provider name to enum prefix (e.g., "anthropic" → "Anthropic")
   - Convert model ID to variant name:
     - Replace `-` with `_`
     - Replace `.` with `_`
     - Remove `:`
     - Example: `claude-opus-4.5:20251101` → `ClaudeOpus_4_5_20251101`
   - Check if variant exists (use string matching against known variants)

3. **API validation fallback:**
   - If no static match, call `api::get_provider_models_from_api(provider, api_key)`
   - Check if model ID in returned list
   - If yes, return String outlet variant
   - If no, return `ProviderError::UnknownModel`
   - Use 5-second timeout (short for interactive use)
   - Cache API results for 24hr to avoid repeated calls

**Technical Details:**
- Use `lazy_static` or `once_cell` for static variant name list
- API validation should only happen on cache miss
- Log at DEBUG level when falling back to API validation
- Consider implementing `FromStr` trait as well (wraps `TryFrom<&str>`)

**Acceptance Criteria:**
- [ ] `TryFrom<String>` implemented for `ProviderModel`
- [ ] `TryFrom<&str>` implemented for `ProviderModel`
- [ ] Naming convention conversion works for known models (no API call)
- [ ] API validation fallback works for unknown models
- [ ] Timeout is 5 seconds for API validation
- [ ] Results cached for 24hr
- [ ] Unit tests: 10+ tests covering:
   - [ ] Known model conversion (no API call)
   - [ ] Unknown model conversion (with API mock)
   - [ ] Invalid format strings
   - [ ] API timeout scenario
   - [ ] API 404 (model not found)
- [ ] Doc tests compile and pass
- [ ] All tests pass: `cargo test --lib providers::types::provider_model`

---

### Phase 4: ProviderModel Update Mechanism ⏸️ PENDING

**Principal Owner:** Rust Developer
**Status:** ⏸️ Not started - requires code generation/meta-programming

**Goal:** Implement `ProviderModel::update()` to refresh enum definition from live provider APIs using meta-programming.

**Dependencies:** Phase 3 (needs TryFrom), Phase 1 (needs api::get_all_provider_models)

**Blast Radius:** `cargo test --lib providers::types && cargo test --lib codegen`

**Files to modify:**
- `shared/src/providers/types.rs` - Add `ProviderModel::update()` method
- Potentially `shared/src/codegen/inject.rs` - Use or enhance existing injection

**Deliverables:**

1. **`ProviderModel::update()` method:**

   ```rust
   impl ProviderModel {
       /// Update the ProviderModel enum definition from live provider APIs
       ///
       /// Fetches current models from all available providers and generates
       /// new enum variants. Preserves existing variants to avoid breaking changes.
       ///
       /// ## Update Strategy
       /// - Never remove variants (backward compatibility)
       /// - Add new variants for newly discovered models
       /// - Aggregator hints: add aggregator variant, conditionally add underlying
       /// - Direct provider access: interrogate directly, ignore aggregator hints
       ///
       /// ## Returns
       /// UpdateSummary with counts of models added per provider
       ///
       /// ## Errors
       /// - `ProviderError::CodegenFailed` - Failed to inject enum code
       /// - `ProviderError::NoProvidersAvailable` - No API keys configured
       ///
       /// ## Examples
       /// ```no_run
       /// use shared::providers::ProviderModel;
       ///
       /// #[tokio::main]
       /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
       ///     let summary = ProviderModel::update().await?;
       ///     println!("Added {} new models", summary.total_added());
       ///     Ok(())
       /// }
       /// ```
       pub async fn update() -> Result<UpdateSummary, ProviderError> {
           // Implementation...
       }
   }

   #[derive(Debug)]
   pub struct UpdateSummary {
       pub models_added: HashMap<Provider, usize>,
       pub providers_checked: Vec<Provider>,
       pub aggregator_hints_applied: usize,
   }
   ```

2. **Update algorithm:**
   ```
   1. Call api::get_all_provider_models() → HashMap<Provider, Vec<String>>

   2. Build set of existing variants from current enum definition

   3. For each (provider, models) pair:
      a. Filter out models already in enum
      b. New models → generate variant names (naming convention)

   4. Handle aggregator hints:
      a. If provider is OpenRouter/ZenMux:
         - Parse model IDs for underlying provider hints
         - If underlying provider API key available:
           * Skip hint (will interrogate directly)
         - Else:
           * Add both aggregator variant AND underlying provider variant

   5. Generate enum code:
      a. Use codegen::inject_enum() or similar
      b. Inject new variants into providers/types.rs
      c. Preserve existing variants (append only)

   6. Return UpdateSummary
   ```

3. **Code generation using `codegen` module:**
   - Leverage existing `shared/src/codegen/inject.rs` if suitable
   - Target file: `shared/src/providers/types.rs`
   - Injection point: Inside `ProviderModel` enum
   - Generated code format:
     ```rust
     // === AUTO-GENERATED VARIANTS (do not edit manually) ===
     // Generated: 2025-12-30 via ProviderModel::update()
     Anthropic__ClaudeOpus_4_6_20260301,
     // === END AUTO-GENERATED ===
     ```

**Technical Details:**
- Use AST manipulation (syn crate) to safely inject enum variants
- Never remove existing variants (additive only)
- Add comment markers for generated code section
- Consider creating a CLI utility: `cargo run --bin update-provider-models`
- Log at INFO level: "Added 5 new Anthropic models, 3 OpenAI models"
- Dry-run mode: return what WOULD be added without modifying files

**Acceptance Criteria:**
- [ ] `ProviderModel::update()` method implemented
- [ ] `UpdateSummary` struct defined and returned
- [ ] New variants appended to enum (existing preserved)
- [ ] Aggregator hint logic correctly distinguishes available vs unavailable providers
- [ ] Generated code has clear comment markers
- [ ] Unit tests: 8+ tests covering:
   - [ ] No new models (idempotent)
   - [ ] New models added
   - [ ] Aggregator hints with/without underlying provider access
   - [ ] Naming convention edge cases
   - [ ] Code injection validation
- [ ] Integration test: Run update against test fixtures
- [ ] All tests pass: `cargo test --lib providers::types`
- [ ] Doc test compiles and demonstrates usage

---

### Phase 5: Research Area - Prompt Filename Extraction ✅ COMPLETE

**Principal Owner:** Rust Developer
**Completed:** 2025-12-30
**Status:** ✅ All acceptance criteria met, 17 tests passing (exceeds 12+ requirement)

**Goal:** Implement `extract_prompt_name()` to parse manual filename prefix from prompts and validate against core research documents.

**Dependencies:** None (research area is independent)

**Blast Radius:** `cargo test --lib research_lib::utils::filename`

**Files to create:**
- None (editing existing `research/lib/src/utils/filename.rs`)

**Files to modify:**
- `research/lib/src/utils/filename.rs` - Add `extract_prompt_name()`
- `research/lib/src/lib.rs` or usage sites - Integrate extraction before LLM naming

**Deliverables:**

1. **`extract_prompt_name()` function in `utils/filename.rs`:**

   ```rust
   /// Extract manual filename from prompt if present
   ///
   /// Parses prompt for `{filename} -> {prompt_text}` pattern.
   /// Validates filename doesn't conflict with core research documents.
   ///
   /// ## Arguments
   /// * `prompt` - The user-provided research prompt
   ///
   /// ## Returns
   /// `(cleaned_prompt, optional_filename)`
   /// - `cleaned_prompt`: Prompt with filename prefix removed (or unchanged)
   /// - `optional_filename`: Some(filename) if valid, None if invalid or absent
   ///
   /// ## Validation Rules
   /// - Filename cannot be empty after trimming
   /// - Filename cannot match core documents: `overview`, `similar_libraries`,
   ///   `integration_partners`, `use_cases`, `changelog`, `deep_dive`, `brief`
   /// - Filename must not contain path separators (`/`, `\`)
   /// - `.md` extension added automatically if omitted
   ///
   /// ## Examples
   /// ```
   /// use research_lib::utils::filename::extract_prompt_name;
   ///
   /// // Valid filename
   /// let (prompt, filename) = extract_prompt_name("async-patterns -> What are best async patterns?");
   /// assert_eq!(prompt, "What are best async patterns?");
   /// assert_eq!(filename, Some("async-patterns.md".to_string()));
   ///
   /// // Invalid filename (core document)
   /// let (prompt, filename) = extract_prompt_name("overview -> What is this library?");
   /// assert_eq!(prompt, "What is this library?"); // Prefix stripped
   /// assert_eq!(filename, None); // Rejected
   ///
   /// // No filename prefix
   /// let (prompt, filename) = extract_prompt_name("What are best practices?");
   /// assert_eq!(prompt, "What are best practices?");
   /// assert_eq!(filename, None);
   /// ```
   pub fn extract_prompt_name(prompt: &str) -> (String, Option<String>) {
       // Implementation...
   }
   ```

2. **Core document validation:**
   - Create constant: `const CORE_DOCUMENTS: &[&str] = &["overview", "similar_libraries", ...];`
   - Check extracted filename (without `.md`) against this list
   - Case-insensitive comparison
   - Log to STDERR on conflict: `- a custom prompt expressed an invalid filename (overview) which conflicts with the core research docs being produced.`

3. **Filename sanitization:**
   - Trim leading/trailing whitespace
   - Check for path separators (`/`, `\`) → reject if present
   - Ensure filename is valid UTF-8 and not empty
   - Add `.md` extension if not present
   - Convert spaces to hyphens (optional normalization)

**Technical Details:**
- Use `str::split_once("->")` for parsing
- Return tuple `(String, Option<String>)` for ergonomic usage
- Log rejected filenames at WARN level with `tracing::warn!`
- Consider adding `FilenameConflictError` variant to `FilenameError` enum

**Acceptance Criteria:**
- [ ] Function `extract_prompt_name()` exists in `utils/filename.rs`
- [ ] Returns tuple `(String, Option<String>)`
- [ ] Correctly parses `{filename} -> {prompt}` syntax
- [ ] Strips filename prefix from returned prompt
- [ ] Validates against core document names
- [ ] Rejects filenames with path separators
- [ ] Adds `.md` extension if absent
- [ ] Logs conflicts to STDERR
- [ ] Unit tests: 12+ tests covering:
   - [ ] Valid filename extraction
   - [ ] Core document conflict
   - [ ] No prefix (passthrough)
   - [ ] Empty filename
   - [ ] Path separator rejection
   - [ ] Whitespace trimming
   - [ ] Case-insensitive core doc matching
   - [ ] `.md` extension handling
- [ ] All tests pass: `cargo test --lib utils::filename::extract_prompt_name`

---

### Phase 6: Research Area - Enhanced Filename Generation ⏸️ READY

**Principal Owner:** Rust Developer
**Status:** ⏸️ Ready to start - Phase 5 dependency satisfied

**Goal:** Enhance `choose_filename()` with metadata validation and add collision resolution with `_1`, `_2` suffixes.

**Dependencies:** Phase 5 (uses extract_prompt_name)

**Blast Radius:** `cargo test --lib research_lib::utils::filename`

**Files to modify:**
- `research/lib/src/utils/filename.rs` - Enhance `choose_filename()`
- Research CLI integration point - Call `extract_prompt_name()` then `choose_filename()`

**Deliverables:**

1. **Enhanced `choose_filename()` function:**

   ```rust
   /// Generate a semantic filename from a prompt using LLM
   ///
   /// Calls Gemini Flash to summarize prompt into 3-5 word expression,
   /// converts to snake_case, validates uniqueness against existing research.
   ///
   /// ## Arguments
   /// * `prompt` - The research prompt text
   /// * `existing_files` - List of filenames already in use for this research topic
   ///
   /// ## Returns
   /// * `Ok(String)` - Snake_case filename with .md extension
   /// * `Err(FilenameError)` - If API call fails or validation fails
   ///
   /// ## Collision Resolution
   /// If generated filename conflicts with `existing_files`, appends `_1`, `_2`, etc.
   /// until unique name found.
   ///
   /// ## Examples
   /// ```no_run
   /// use research_lib::utils::filename::choose_filename;
   ///
   /// #[tokio::main]
   /// async fn main() {
   ///     let existing = vec!["async_patterns.md".to_string()];
   ///     let filename = choose_filename(
   ///         "What are advanced async patterns?",
   ///         &existing
   ///     ).await?;
   ///     // Result: "advanced_async_patterns.md" or "async_patterns_1.md" if collision
   ///     Ok(())
   /// }
   /// ```
   pub async fn choose_filename(prompt: &str, existing_files: &[String]) -> Result<String, FilenameError> {
       // Implementation...
   }
   ```

2. **Metadata validation:**
   - Accept `&[String]` parameter for existing filenames
   - Check generated filename against this list
   - If conflict, append `_1`, `_2`, incrementing until unique
   - Existing `fallback_filename()` can be used as reference

3. **Integration with research CLI:**
   - Modify research library to load `metadata.json` before filename generation
   - Extract `additional_files` keys as existing filename list
   - Call `extract_prompt_name()` first
   - If extraction returns None, call `choose_filename()` with existing files
   - If extraction returns Some, validate uniqueness manually

**Technical Details:**
- Maintain existing LLM prompt: "Generate a short (2-5 word) kebab-case identifier"
- Convert kebab-case to snake_case for consistency
- Use existing sanitization logic (alphanumeric + hyphens/underscores)
- Log at INFO level: "Generated filename: async_patterns.md"
- Log at DEBUG level if collision: "Filename collision detected, trying async_patterns_1.md"

**Acceptance Criteria:**
- [ ] Function `choose_filename()` accepts `existing_files: &[String]` parameter
- [ ] Collision resolution appends `_1`, `_2`, etc.
- [ ] Integration with `metadata.json` additional_files keys
- [ ] Research CLI calls `extract_prompt_name()` before `choose_filename()`
- [ ] Unit tests: 8+ tests covering:
   - [ ] No collision (unique filename)
   - [ ] Collision with _1 suffix
   - [ ] Multiple collisions (_1, _2, _3)
   - [ ] Empty existing files list
   - [ ] LLM API failure (falls back to question_N.md)
- [ ] Integration test: End-to-end filename generation workflow
- [ ] All tests pass: `cargo test --lib utils::filename`
- [ ] Manual test: Run research CLI with custom prompts, verify filenames

---

### Phase 7: Documentation and Code Review ⏸️ BLOCKED

**Principal Owner:** Rust Architect
**Status:** ⏸️ Blocked - requires Phases 4 and 6 complete

**Goal:** Comprehensive documentation, final code review, and cleanup.

**Dependencies:** Phases 0-6 (all implementation complete)

**Blast Radius:** `cargo test` (full workspace)

**Files to modify:**
- All files in `shared/src/providers/`, `shared/src/api/`, `research/lib/src/utils/`
- `shared/README.md` - Update architecture documentation
- `research/README.md` - Document custom prompt naming
- Create migration guide: `.ai/docs/provider-model-migration.md`

**Deliverables:**

1. **Rustdoc review:**
   - All public types have rustdoc comments
   - All public functions have examples
   - Complex algorithms have implementation notes
   - Follow H2 heading convention (## Returns, ## Errors, ## Examples)

2. **Migration guide (`.ai/docs/provider-model-migration.md`):**
   ```markdown
   # Provider & Model System Migration Guide

   ## Breaking Changes
   - `providers/base.rs` and `providers/discovery.rs` no longer contain duplicate code
   - Import paths changed for `OpenAIModelsResponse` (now in `providers/types`)

   ## New Features
   - `ProviderModel` enum for type-safe model references
   - `api` module for OpenAI-compatible API utilities
   - Enhanced research prompt filename generation

   ## Migration Steps
   1. Update imports: `use shared::providers::types::{OpenAIModelsResponse, ProviderModel};`
   2. Replace string model references with `ProviderModel::try_from()`
   3. Use `api::get_all_provider_models()` instead of manual provider iteration

   ## Examples
   [Before/after code examples]
   ```

3. **Code review checklist:**
   - [ ] All `todo!()` macros removed
   - [ ] No duplicate code (DRY principle)
   - [ ] Error handling comprehensive (no unwrap/expect in lib code)
   - [ ] All public APIs have rustdoc with examples
   - [ ] Tracing instrumentation added (`#[tracing::instrument]`)
   - [ ] Security: API keys never logged
   - [ ] Tests cover new functionality (>80% coverage)
   - [ ] Clippy warnings addressed
   - [ ] No unsafe code (or justified with SAFETY comments)

4. **Update README files:**
   - `shared/README.md`: Document new `api` module
   - `shared/src/api/README.md`: Expand with architecture details
   - `research/README.md`: Document custom prompt naming syntax

**Technical Details:**
- Run `cargo doc --no-deps --open` to review generated documentation
- Use `cargo clippy --all-targets -- -D warnings` for strict linting
- Consider running `cargo tarpaulin` for coverage report

**Acceptance Criteria:**
- [ ] All public types/functions have rustdoc comments
- [ ] All rustdoc examples compile: `cargo test --doc`
- [ ] Migration guide created at `.ai/docs/provider-model-migration.md`
- [ ] Code review checklist 100% complete
- [ ] `shared/README.md` and `research/README.md` updated
- [ ] All tests pass: `cargo test`
- [ ] Clippy clean: `cargo clippy --all-targets -- -D warnings`
- [ ] Documentation renders correctly: `cargo doc --no-deps`

---

## Cross-Cutting Concerns

### Testing Strategy

**Unit Tests:**
- In `#[cfg(test)] mod tests` blocks within each module
- Mock HTTP responses with `wiremock` for API calls
- Use `#[serial_test::serial]` for environment variable tests
- Property-based tests (proptest) for:
  - ProviderModel naming convention conversion (arbitrary strings)
  - Filename sanitization (arbitrary UTF-8)

**Integration Tests:**
- `tests/provider_model_integration.rs` - End-to-end model discovery and conversion
- `tests/research_filename_integration.rs` - Complete filename generation workflow

**Doc Tests:**
- All public API examples must compile and run
- Use `#[tokio::main]` for async examples
- Use `no_run` for examples requiring API keys

### Security Considerations

**API Key Handling:**
- Never log API keys (use `#[tracing::instrument(skip(api_key))]`)
- Never include in error messages
- Use `Debug` impl that redacts sensitive data

**Input Validation:**
- Validate model strings before API calls (prevent injection)
- Sanitize filenames (no path traversal)
- Validate HTTP responses (size limits, content-type)

**Rate Limiting:**
- Respect provider rate limits (existing retry logic)
- Cache API results (24hr) to minimize calls
- Timeout on slow API responses (5-30 seconds)

### Performance Considerations

**API Efficiency:**
- Parallelize provider API calls (`buffer_unordered(8)`)
- Cache results for 24hr (existing cache module)
- Short timeout for `TryFrom` validation (5 seconds)

**Code Generation:**
- Use AST manipulation (syn) for safe enum injection
- Avoid regex on Rust code
- Validate injection points before modification

**Filename Generation:**
- LLM call only on cache miss
- Fallback to `question_N.md` on timeout/error
- Quick collision resolution (linear search is fine for small lists)

### Error Handling

**Library Errors (thiserror):**
- `ProviderError::UnknownModel` - Model not found in enum or API
- `ProviderError::InvalidModelString` - Malformed model string
- `ProviderError::CodegenFailed` - Enum injection failed
- `FilenameError::InvalidFilename` - Filename validation failed

**Error Context:**
- Use `.map_err()` to add context
- Include provider name in errors
- Include model string in errors (sanitized)

### Observability

**Tracing:**
- INFO: Model discovery start/complete, filename generation
- DEBUG: API calls, cache hits/misses, naming convention fallback
- WARN: Filename conflicts, API validation failures
- ERROR: Code generation failures, critical API errors

**Metrics (future):**
- Track API validation hit rate (cache effectiveness)
- Count model enum updates (how often new models appear)
- Measure filename generation latency

---

## Parallelization Opportunities

### Parallel Execution Groups

| Group | Phases | Can Start After | Duration Estimate |
|-------|--------|-----------------|-------------------|
| A | Phase 0 | Plan approval | ~2 hours |
| B | Phase 1, Phase 2, Phase 5 | Phase 0 complete | ~3 hours |
| C | Phase 3 | Phase 2 complete | ~2 hours |
| D | Phase 4, Phase 6 | Phase 3, Phase 5 complete | ~2 hours |
| E | Phase 7 | All phases complete | ~1 hour |

**Total Critical Path:** ~10 hours

### Parallelization Diagram

```text
Timeline:
─────────────────────────────────────────────────────►

Group A: ██████ (Phase 0 - Setup)
              │
              ├──────────────────────────────────┐
              │                                  │
Group B:      ├─ ████████ (Phase 1 - API)       │
              │                                  │
              ├─ ████████ (Phase 2 - Enum)      │
              │                                  │
              └─ ████████ (Phase 5 - Extract)   │
                       │                         │
Group C:               └─ ██████ (Phase 3 - TryFrom)
                                │                │
Group D:                        ├─ ██████ (Phase 4 - Update)
                                │
                                └─ ██████ (Phase 6 - Enhance)
                                         │
Group E:                                 └─ ███ (Phase 7 - Docs)
```

### Synchronization Points

1. **After Group A:** Shared utilities (retry, constants, types) available for all subsequent work
2. **After Group B:**
   - Phase 1 enables Phase 4 (API utilities ready)
   - Phase 2 enables Phase 3 (Enum defined)
   - Phase 5 enables Phase 6 (Extraction function ready)
3. **After Group C:** TryFrom enables Phase 4 (conversion needed for update)
4. **After Group D:** All functionality complete, ready for documentation
5. **Final:** Documentation complete, ready for production

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| API provider changes break compatibility | High | Use retry logic, cache results, test against multiple providers |
| Naming convention doesn't cover all model names | Medium | Use String outlets for edge cases, document limitations |
| Code generation breaks existing enum | High | Use AST validation, keep backups, test thoroughly |
| LLM filename generation produces conflicts | Medium | Implement collision resolution with _1, _2 suffixes |
| Performance degradation from API calls | Medium | Use caching aggressively (24hr), short timeouts |
| Breaking changes for existing users | Medium | Create migration guide, deprecate old APIs gradually |
| Test coverage gaps on edge cases | Medium | Use property-based testing (proptest) for fuzz scenarios |

---

## Review Summary

**Reviews Completed:** 2025-12-30

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Status:** Reviewed - Implementation Ready with Changes

### Key Changes from Review

**1. Simplify ProviderModel Enum (Rust Developer, Rust Architect, Schema Architect)**

**Original:** ~50-80 static variants covering all known models

**Revised:** 10-15 static variants for most common/stable models only

**Rationale**:
- Large enums (50-80+ variants) cause IDE slowdown and compilation bottlenecks
- Most models can use String outlets without losing much value
- Easier maintenance and faster enum updates

**Impact**: Update Phase 2 deliverables to target 10-15 variants max

---

**2. Make TryFrom Synchronous (All Reviewers)**

**Original:** `TryFrom` calls API for validation (5-second timeout)

**Revised:** `TryFrom` checks static variants + cache ONLY, add separate async `validate()` method

**Rationale**:
- Users expect `TryFrom` to be cheap and synchronous
- 5-second blocking is poor UX in interactive scenarios
- No async TryFrom trait in Rust

**Implementation**:
```rust
impl TryFrom<String> for ProviderModel {
    // Fast, sync - check static variants + cache only
    fn try_from(value: String) -> Result<Self, Self::Error> {
        match check_static_or_cache(&value) {
            Some(model) => Ok(model),
            None => {
                // Use String outlet without API validation
                let (provider, model_id) = parse_provider_model(&value)?;
                Ok(provider_outlet(provider, model_id)?)
            }
        }
    }
}

impl ProviderModel {
    // Explicit async validation when needed
    pub async fn validate_exists(&self) -> Result<(), ProviderError> {
        // API validation here
    }
}
```

**Impact**: Update Phase 3 implementation and acceptance criteria

---

**3. Add CLI Tool for Model Updates (Rust Developer, Rust Architect)**

**Original:** `ProviderModel::update()` invocation mechanism unclear

**Revised:** Add dedicated CLI binary `update-provider-models`

**Implementation** (Phase 4):
```
Files to create:
- `shared/src/bin/update-provider-models.rs` - CLI tool

CLI interface:
  update-provider-models [OPTIONS]

  Options:
    --dry-run          Show what would be updated
    --provider <NAME>  Only update specific provider
    --output <PATH>    Custom output path
```

**Rationale**:
- Avoids build.rs API rate limit issues
- Gives developers visibility into changes
- Allows testing before committing

**Impact**: Add to Phase 4 deliverables

---

**4. Strengthen Validation and Error Types (All Reviewers)**

**Additions**:

a. **Input validation in TryFrom** (Phase 3):
```rust
fn validate_model_format(s: &str) -> Result<(), ProviderError> {
    lazy_static! {
        static ref MODEL_RE: Regex = Regex::new(r"^[a-z0-9_-]+/[a-z0-9._:-]+$").unwrap();
    }
    if !MODEL_RE.is_match(s) {
        return Err(ProviderError::InvalidModelString { input: s.to_string() });
    }
    Ok(())
}
```

b. **Expand ProviderError variants** (Phase 0):
```rust
#[derive(Error, Debug)]
pub enum ProviderError {
    #[error("Unknown model '{model}' for provider {provider:?}")]
    UnknownModel { provider: Provider, model: String },

    #[error("Invalid model string format: '{input}' (expected 'provider/model-id')")]
    InvalidModelString { input: String },

    #[error("Code generation failed: {details}")]
    CodegenFailed { details: String },

    #[error("Validation timeout for provider {provider:?}")]
    ValidationTimeout { provider: Provider },

    // ... existing variants
}
```

c. **Add newtype wrapper for validated models** (Phase 2 - optional):
```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ValidatedModelId(String); // Prevents unsafe direct construction

pub enum ProviderModel {
    Anthropic__ClaudeOpus_4_5,
    Anthropic(ValidatedModelId), // Can only be created via TryFrom
    // ...
}
```

**Impact**: Update Phase 0 (error types), Phase 2 (optional newtype), Phase 3 (validation)

---

**5. Enhanced Testing Requirements (Feature Tester)**

**Additions to acceptance criteria**:

**Phase 0:**
- [ ] Snapshot tests verify retry logic behavior unchanged (refactoring safety)

**Phase 1:**
- [ ] HTTP mock scenarios: 200 OK, 429 rate limit, 401/403 auth, timeout, malformed JSON, empty list, network error
- [ ] Parallel API test: buffer_unordered(8) doesn't deadlock

**Phase 2:**
- [ ] Pattern matching test on all static variants
- [ ] Debug/Clone/PartialEq/Eq/Hash derives tested

**Phase 3:**
- [ ] Malformed input tests: "no-slash", "provider/", "/model", "", "provider//model"
- [ ] Cache hit test: second TryFrom doesn't hit API
- [ ] Performance test: validation completes within timeout

**Phase 4:**
- [ ] AST validation: generated code parses with syn
- [ ] rustfmt can format generated code
- [ ] Recompilation succeeds after injection
- [ ] No duplicate variant names
- [ ] Dry-run test: no files modified

**Phase 5:**
- [ ] Property tests (proptest): arbitrary UTF-8 input doesn't panic
- [ ] Case sensitivity test: "Overview" and "OVERVIEW" both rejected

**Phase 6:**
- [ ] Collision bounds test: 100+ existing files
- [ ] Integration test: end-to-end with metadata.json

**Impact**: Update all phase acceptance criteria

---

**6. Code Generation Safety (Rust Architect, Feature Tester)**

**Add to Phase 4 technical details**:

**Atomic write strategy**:
```rust
1. Write to temporary file: types.rs.new
2. Validate with syn::parse_file()
3. Test compilation: rustc --crate-type lib types.rs.new
4. Run rustfmt on temp file
5. Create backup: types.rs.bak
6. Atomic rename: types.rs.new -> types.rs
```

**Rollback on failure**: Keep backup for manual recovery

**Impact**: Update Phase 4 technical details and acceptance criteria

---

**7. API Type Design Improvements (Schema Architect)**

**Add helper methods to ProviderModel** (Phase 2):
```rust
impl ProviderModel {
    pub fn provider(&self) -> Provider { /* ... */ }
    pub fn model_id(&self) -> &str { /* ... */ }
    pub fn to_identifier(&self) -> String { /* ... */ }
}

impl Display for ProviderModel {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", self.to_identifier())
    }
}
```

**Serde customization** (Phase 2):
```rust
#[derive(Serialize, Deserialize)]
#[serde(into = "String", try_from = "String")]
pub enum ProviderModel { /* ... */ }
```

**Impact**: Add to Phase 2 deliverables

---

### Resolved Open Questions

- [x] **Code generation frequency:** Manual CLI tool (`update-provider-models` binary)
- [x] **Enum size limits:** 10-15 static variants initially, warn at 150, error at 200+
- [x] **Aggregator model naming:** Yes, parse with regex `^([^/]+)/([^/]+)/(.+)$`
- [x] **Cache invalidation:** Manual via `update-provider-models` CLI
- [x] **Filename generation:** Keep Gemini Flash, document in code

### Critical Action Items Before Implementation

1. ✅ Update Phase 2 to target 10-15 static variants (not 50-80)
2. ✅ Revise Phase 3 TryFrom to be synchronous (no API calls)
3. ✅ Add `update-provider-models` CLI specification to Phase 4
4. ✅ Expand ProviderError variants in Phase 0
5. ✅ Add validation functions to Phase 3
6. ✅ Enhance test requirements across all phases
7. ✅ Document atomic write strategy in Phase 4

---

## Dependencies to Add/Update

**No new dependencies required** - all functionality uses existing crates:

- `syn`, `quote`, `prettyplease` - Already in codegen module for AST manipulation
- `reqwest`, `serde`, `serde_json` - Already used for HTTP/JSON
- `tokio`, `futures` - Already used for async
- `thiserror` - Already used for errors
- `tracing` - Already used for observability
- `wiremock`, `proptest`, `serial_test` - Already in dev-dependencies for testing

---

## Implementation Summary

**This refactoring will:**

1. **Eliminate code duplication:**
   - Move shared types to `providers/types.rs`
   - Extract retry logic to `providers/retry.rs`
   - Consolidate constants to `providers/constants.rs`

2. **Introduce type safety:**
   - `ProviderModel` enum with static variants
   - Compile-time guarantees for known models
   - Runtime flexibility via String outlets

3. **Create API module:**
   - `api::get_provider_models_from_api()` - Single provider
   - `api::get_all_provider_models()` - All providers
   - Clean separation of concerns

4. **Enhance research workflow:**
   - Manual filename specification: `filename -> prompt`
   - LLM-generated semantic filenames
   - Collision resolution with suffixes
   - Validation against core documents

**Code quality improvements:**
- DRY principle enforced (no duplication)
- Comprehensive rustdoc with examples
- >80% test coverage
- Tracing instrumentation
- Type safety and error handling

**Ready for production use after Phase 7 completion.**
