# Sniff Library and CLI Implementation Plan

**Created:** 2026-01-03
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2026-01-03

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. Added `chrono` dependency for git timestamps
2. Added `LanguageDetection` error variant to SniffError
3. Enhanced network detection to handle PermissionDenied gracefully
4. Added testing dependencies (tempfile, assert_cmd, predicates)
5. Added `#[non_exhaustive]` to public enums for API stability
6. Created `sniff/justfile` with standard recipes
7. Added explicit test scenarios for edge cases
8. **macOS and Linux both fully supported in v1** (Windows deferred to v2)
9. Added cross-platform testing strategy with platform-agnostic assertions

**Resolved Concerns:**
- Missing chrono dependency → Added to Phase 5 and dependencies list
- toml crate usage unclear → Using proper TOML parsing for workspace detection
- Network permission handling → Added graceful degradation path
- Test fixture organization → Added tempfile and fixture helpers

---

## Executive Summary

Implement the Sniff library (`sniff/lib`) and CLI (`sniff/cli`) for detecting host system information across Hardware, Network, and Filesystem domains. The first iteration focuses on the core `detect()` function and a minimal CLI that reports system information to stdout.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Detect hardware info (OS, CPU, memory, storage) | High | Rust Developer |
| FR-2 | Detect network interfaces (name, IPs, flags) | High | Rust Developer |
| FR-3 | Detect filesystem info (languages, git, monorepo) | High | Rust Developer |
| FR-4 | Aggregate all detection into `detect()` function | High | Rust Developer |
| FR-5 | CLI with `--base`/`-b` directory override | High | Rust Developer |
| FR-6 | CLI with `--format`/`-f` output format (text/json) | Medium | Rust Developer |
| FR-7 | Serialize all results with serde | High | Schema Architect |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Fast path detection (no CPU sampling) | <300ms | Rust Developer |
| NFR-2 | Cross-platform support | macOS and Linux (Windows deferred to v2) | Rust Developer |
| NFR-3 | Proper error handling with thiserror | All paths | Rust Architect |
| NFR-4 | Unit test coverage for all public APIs | >80% | Feature Tester |

## Architecture Overview

### Module Structure

```
sniff/
├── lib/
│   └── src/
│       ├── lib.rs           # Public API: detect(), SniffConfig, SniffResult
│       ├── error.rs         # SniffError with thiserror
│       ├── hardware/
│       │   ├── mod.rs       # detect_hardware(), HardwareInfo
│       │   ├── os.rs        # OsInfo
│       │   ├── cpu.rs       # CpuInfo
│       │   ├── memory.rs    # MemoryInfo
│       │   └── storage.rs   # StorageInfo
│       ├── network/
│       │   ├── mod.rs       # detect_network(), NetworkInfo
│       │   └── interface.rs # NetworkInterface, InterfaceFlags
│       └── filesystem/
│           ├── mod.rs       # detect_filesystem(), FilesystemInfo
│           ├── languages.rs # LanguageBreakdown, LanguageStats
│           ├── git.rs       # GitInfo, RepoStatus, HostingProvider
│           ├── monorepo.rs  # MonorepoInfo, MonorepoTool
│           └── dependencies.rs # PackageManager, DependencyReport (stub)
├── cli/
│   └── src/
│       ├── main.rs          # clap CLI entry point
│       └── output.rs        # Text and JSON formatters
└── justfile                  # Build/test recipes
```

### Data Flow

```
CLI (--base ./some/dir)
         │
         ▼
   SniffConfig { base_dir: Some(path), ... }
         │
         ▼
   detect_with_config(config)
         │
    ┌────┴────┬────────────┐
    ▼         ▼            ▼
 Hardware  Network    Filesystem
    │         │            │
    ▼         ▼            ▼
  sysinfo  getifaddrs   git2 + walkdir
    │         │            │
    └────┬────┴────────────┘
         ▼
    SniffResult { hardware, network, filesystem }
         │
         ▼
   CLI output (text or JSON)
```

## Phases

### Phase 1: Core Error Types and Library Foundation

**Principal Owner:** Rust Architect

**Goal:** Establish error handling, core type definitions, and project structure

**Dependencies:** None

**Blast Radius:** `cargo test -p sniff-lib`

**Files to create:**
- `sniff/lib/src/error.rs` - SniffError enum with thiserror
- `sniff/justfile` - Build/test recipes

**Files to modify:**
- `sniff/lib/Cargo.toml` - Fix package name to `sniff-lib`, add missing deps
- `sniff/lib/src/lib.rs` - Add `pub mod error` and re-exports
- `Cargo.toml` (workspace) - Ensure `sniff/lib` is in members

**Deliverables:**
- `SniffError` enum with variants: Io, Git, NotARepository, SystemInfo, LanguageDetection
- `Result<T>` type alias
- Justfile with standard recipes

**Technical Details:**
```rust
#[derive(Debug, thiserror::Error)]
pub enum SniffError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Git error: {0}")]
    Git(#[from] git2::Error),

    #[error("Not a git repository: {0}")]
    NotARepository(PathBuf),

    #[error("System info error in {domain}: {message}")]
    SystemInfo { domain: &'static str, message: String },

    #[error("Language detection failed: {0}")]
    LanguageDetection(String),
}

pub type Result<T> = std::result::Result<T, SniffError>;
```

**Justfile:**
```make
# sniff/justfile
default:
    @just --list

build:
    cargo build -p sniff-lib
    cargo build -p sniff

test:
    cargo test -p sniff-lib
    cargo test -p sniff

lint:
    cargo clippy -p sniff-lib -p sniff

install:
    cargo install --path cli
```

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/error.rs` exists with >30 lines
- [ ] `grep "pub enum SniffError" sniff/lib/src/error.rs` succeeds
- [ ] `grep "LanguageDetection" sniff/lib/src/error.rs` succeeds
- [ ] `grep "thiserror" sniff/lib/Cargo.toml` succeeds
- [ ] File `sniff/justfile` exists with build, test, lint recipes
- [ ] `cargo build -p sniff-lib` succeeds
- [ ] `cargo test -p sniff-lib` runs (even with 0 tests initially)

---

### Phase 2: Hardware Detection Module

**Principal Owner:** Rust Developer

**Goal:** Implement hardware detection using sysinfo crate

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib hardware`

**Files to create:**
- `sniff/lib/src/hardware/os.rs` - OsInfo struct
- `sniff/lib/src/hardware/cpu.rs` - CpuInfo struct
- `sniff/lib/src/hardware/memory.rs` - MemoryInfo struct
- `sniff/lib/src/hardware/storage.rs` - StorageInfo struct

**Files to modify:**
- `sniff/lib/src/hardware/mod.rs` - HardwareInfo, detect_hardware()

**Deliverables:**
- `HardwareInfo` struct with os, cpu, memory, storage fields
- `detect_hardware()` function
- `detect_hardware_with_usage()` function (opt-in CPU sampling)

**Technical Details:**
```rust
use sysinfo::{System, RefreshKind, CpuRefreshKind, MemoryRefreshKind};

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct HardwareInfo {
    pub os: OsInfo,
    pub cpu: CpuInfo,
    pub memory: MemoryInfo,
    pub storage: Vec<StorageInfo>,
}

pub fn detect_hardware() -> Result<HardwareInfo> {
    let sys = System::new_with_specifics(
        RefreshKind::new()
            .with_cpu(CpuRefreshKind::new())
            .with_memory(MemoryRefreshKind::everything()),
    );

    let os = OsInfo {
        name: System::name().unwrap_or_default(),
        version: System::os_version().unwrap_or_default(),
        kernel: System::kernel_version().unwrap_or_default(),
        arch: std::env::consts::ARCH.to_string(),
        hostname: System::host_name().unwrap_or_default(),
    };

    // ... extract CPU, memory, storage
    Ok(HardwareInfo { os, cpu, memory, storage })
}
```

**Test Scenarios:**
- Memory values are reasonable (not zero, not u64::MAX)
- CPU count matches available cores
- Storage info handles empty/unavailable disks gracefully
- OsInfo fields are non-empty strings
- OS name varies by platform (e.g., "macOS" vs "Ubuntu") - test is non-empty, not specific value
- Storage mount points work regardless of convention (`/Volumes` macOS, `/mnt` Linux)

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/hardware/mod.rs` exists with >100 lines
- [ ] File `sniff/lib/src/hardware/os.rs` exists with OsInfo struct
- [ ] File `sniff/lib/src/hardware/cpu.rs` exists with CpuInfo struct
- [ ] File `sniff/lib/src/hardware/memory.rs` exists with MemoryInfo struct
- [ ] File `sniff/lib/src/hardware/storage.rs` exists with StorageInfo struct
- [ ] `grep "pub fn detect_hardware" sniff/lib/src/hardware/mod.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib hardware` runs 5+ tests
- [ ] All tests pass

---

### Phase 3: Network Detection Module

**Principal Owner:** Rust Developer

**Goal:** Implement network interface enumeration using getifaddrs

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib network`

**Files to create:**
- `sniff/lib/src/network/interface.rs` - NetworkInterface, InterfaceFlags, MacAddress, Ipv4Network, Ipv6Network

**Files to modify:**
- `sniff/lib/src/network/mod.rs` - NetworkInfo, detect_network(), detect_network_filtered()

**Deliverables:**
- `NetworkInfo` struct with interfaces and primary_interface
- `NetworkInterface` struct with name, IPs, flags
- `detect_network()` function with PermissionDenied handling
- `InterfaceFilter` struct for filtering options

**Technical Details:**
```rust
use getifaddrs::getifaddrs;
use std::collections::HashMap;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct NetworkInfo {
    pub interfaces: Vec<NetworkInterface>,
    /// First non-loopback interface with an IPv4 address
    pub primary_interface: Option<String>,
    /// True if permission was denied during enumeration
    pub permission_denied: bool,
}

pub fn detect_network() -> Result<NetworkInfo> {
    let addrs = match getifaddrs() {
        Ok(addrs) => addrs,
        Err(e) if e.kind() == std::io::ErrorKind::PermissionDenied => {
            return Ok(NetworkInfo {
                interfaces: vec![],
                primary_interface: None,
                permission_denied: true,
            });
        }
        Err(e) => return Err(e.into()),
    };

    let mut interfaces: HashMap<String, NetworkInterface> = HashMap::new();

    for ifaddr in addrs {
        let entry = interfaces.entry(ifaddr.name.clone()).or_insert_with(|| {
            NetworkInterface::new(ifaddr.name.clone())
        });
        // Add addresses based on type
    }

    let interfaces: Vec<_> = interfaces.into_values().collect();
    let primary = find_primary_interface(&interfaces);

    Ok(NetworkInfo { interfaces, primary_interface: primary, permission_denied: false })
}

fn find_primary_interface(interfaces: &[NetworkInterface]) -> Option<String> {
    interfaces.iter()
        .find(|i| !i.flags.is_loopback && !i.ipv4_addresses.is_empty())
        .map(|i| i.name.clone())
}
```

**Test Scenarios:**
- Filter out loopback interfaces in filtered mode
- Handle interfaces with multiple IPs (both IPv4 and IPv6)
- Test primary interface selection logic (name-agnostic: works with `en0` on macOS, `eth0`/`enp0s3` on Linux)
- Handle missing/down interfaces gracefully
- PermissionDenied returns empty list with flag set
- MAC address retrieval works on both macOS (`AF_LINK`) and Linux (`AF_PACKET`) - handled by getifaddrs internally
- Loopback detection works (`lo0` on macOS, `lo` on Linux) - checks `is_loopback` flag, not name

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/network/mod.rs` exists with >100 lines
- [ ] File `sniff/lib/src/network/interface.rs` exists with >100 lines
- [ ] `grep "pub fn detect_network" sniff/lib/src/network/mod.rs` succeeds
- [ ] `grep "pub struct NetworkInterface" sniff/lib/src/network/interface.rs` succeeds
- [ ] `grep "permission_denied" sniff/lib/src/network/mod.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib network` runs 4+ tests
- [ ] All tests pass

---

### Phase 4: Filesystem Detection - Language Detection

**Principal Owner:** Rust Developer

**Goal:** Refactor language detection to use hyperpolyglot and proper types

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib filesystem::languages`

**Files to create:**
- `sniff/lib/src/filesystem/languages.rs` - LanguageBreakdown, LanguageStats, DetectionMethod

**Files to modify:**
- `sniff/lib/src/filesystem/mod.rs` - Update module structure
- `sniff/lib/src/filesystem/language_detection.rs` - Delete (replaced by languages.rs)
- `sniff/lib/Cargo.toml` - Add hyperpolyglot dependency

**Deliverables:**
- `LanguageBreakdown` struct with languages, primary, total_files
- `LanguageStats` struct with language, file_count, percentage
- `detect_languages()` function with early termination

**Technical Details:**
```rust
use hyperpolyglot::detect;
use walkdir::{DirEntry, WalkDir};

/// Maximum files to scan before early termination
const MAX_FILES: usize = 10_000;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LanguageBreakdown {
    pub languages: Vec<LanguageStats>,
    pub primary: Option<String>,
    pub total_files: usize,
}

pub fn detect_languages(root: &Path) -> Result<LanguageBreakdown> {
    let mut language_counts: HashMap<String, usize> = HashMap::new();
    let mut total_files = 0;

    for entry in WalkDir::new(root)
        .into_iter()
        .filter_entry(|e| !is_excluded_dir(e))
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .take(MAX_FILES)
    {
        total_files += 1;
        if let Some(detection) = detect(entry.path()) {
            *language_counts.entry(detection.language().to_string()).or_insert(0) += 1;
        }
    }

    // Calculate percentages, sort by count, determine primary
    let languages = calculate_stats(&language_counts, total_files);
    let primary = languages.first().map(|s| s.language.clone());

    Ok(LanguageBreakdown { languages, primary, total_files })
}

fn is_excluded_dir(entry: &DirEntry) -> bool {
    if !entry.file_type().is_dir() { return false; }
    matches!(
        entry.file_name().to_str(),
        Some("node_modules" | "target" | ".git" | "vendor" | "dist" | "build" | "__pycache__")
    )
}
```

**Test Scenarios:**
- Empty directory returns zero languages
- Directory with only excluded subdirs returns zero
- Mixed-language project identifies correct primary language
- Early termination at 10k files works correctly
- Binary files are ignored

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/filesystem/languages.rs` exists with >100 lines
- [ ] `sniff/lib/src/filesystem/language_detection.rs` deleted
- [ ] `grep "hyperpolyglot" sniff/lib/Cargo.toml` succeeds
- [ ] `grep "pub fn detect_languages" sniff/lib/src/filesystem/languages.rs` succeeds
- [ ] `grep "MAX_FILES" sniff/lib/src/filesystem/languages.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib filesystem::languages` runs 4+ tests
- [ ] All tests pass

---

### Phase 5: Filesystem Detection - Git Info

**Principal Owner:** Rust Developer

**Goal:** Implement git repository detection using git2

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib filesystem::git`

**Files to create:**
- `sniff/lib/src/filesystem/git.rs` - GitInfo, RepoStatus, RemoteInfo, HostingProvider, CommitInfo

**Files to modify:**
- `sniff/lib/src/filesystem/mod.rs` - Add git module
- `sniff/lib/src/filesystem/git_info.rs` - Delete (replaced by git.rs)
- `sniff/lib/Cargo.toml` - Add chrono for timestamps

**Deliverables:**
- `GitInfo` struct with repo_root, current_branch, head_commit, status, remotes
- `RepoStatus` struct with is_dirty, staged/unstaged/untracked counts
- `HostingProvider` enum with GitHub, GitLab, Bitbucket, etc. (marked `#[non_exhaustive]`)
- `detect_git()` function

**Technical Details:**
```rust
use git2::{Repository, StatusOptions};
use chrono::{DateTime, Utc};

#[non_exhaustive]
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum HostingProvider {
    GitHub,
    GitLab,
    Bitbucket,
    AzureDevOps,
    AwsCodeCommit,
    Gitea,
    Forgejo,
    SourceHut,
    SelfHosted,
    Unknown,
}

impl HostingProvider {
    pub fn from_url(url: &str) -> Self {
        let normalized = url
            .trim_start_matches("git@")
            .trim_start_matches("https://")
            .trim_start_matches("http://")
            .trim_start_matches("ssh://");

        if normalized.starts_with("github.com") { Self::GitHub }
        else if normalized.starts_with("gitlab.com") { Self::GitLab }
        else if normalized.starts_with("bitbucket.org") { Self::Bitbucket }
        else if normalized.contains("dev.azure.com") || normalized.contains("visualstudio.com") { Self::AzureDevOps }
        else if normalized.contains("codecommit") && normalized.contains("amazonaws.com") { Self::AwsCodeCommit }
        else if normalized.contains("sr.ht") { Self::SourceHut }
        else if normalized.contains(".") { Self::SelfHosted }
        else { Self::Unknown }
    }
}

pub fn detect_git(path: &Path) -> Result<Option<GitInfo>> {
    let repo = match Repository::discover(path) {
        Ok(r) => r,
        Err(_) => return Ok(None),
    };

    let repo_root = repo.workdir()
        .ok_or_else(|| SniffError::NotARepository(path.to_path_buf()))?
        .to_path_buf();

    let head = repo.head().ok();
    let current_branch = head.as_ref()
        .and_then(|h| h.shorthand())
        .map(String::from);

    // Get status, remotes, etc.
    Ok(Some(GitInfo { repo_root, current_branch, head_commit, status, remotes }))
}
```

**Test Scenarios:**
- Non-git directory returns `None`
- Detached HEAD state is handled
- Dirty repo correctly counts staged/unstaged/untracked
- Remotes with different hosting providers are detected
- Bare repositories handled gracefully

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/filesystem/git.rs` exists with >150 lines
- [ ] `sniff/lib/src/filesystem/git_info.rs` deleted
- [ ] `grep "chrono" sniff/lib/Cargo.toml` succeeds
- [ ] `grep "pub fn detect_git" sniff/lib/src/filesystem/git.rs` succeeds
- [ ] `grep "#\\[non_exhaustive\\]" sniff/lib/src/filesystem/git.rs` succeeds
- [ ] `grep "pub enum HostingProvider" sniff/lib/src/filesystem/git.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib filesystem::git` runs 5+ tests
- [ ] All tests pass

---

### Phase 6: Filesystem Detection - Monorepo Detection

**Principal Owner:** Rust Developer

**Goal:** Detect monorepo tools and package locations

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib filesystem::monorepo`

**Files to create:**
- `sniff/lib/src/filesystem/monorepo.rs` - MonorepoInfo, MonorepoTool, PackageLocation

**Files to modify:**
- `sniff/lib/src/filesystem/mod.rs` - Add monorepo module
- `sniff/lib/Cargo.toml` - Add serde_yaml for pnpm-workspace.yaml, toml for Cargo.toml

**Deliverables:**
- `MonorepoInfo` struct with is_monorepo, tool, root, packages
- `MonorepoTool` enum (marked `#[non_exhaustive]`)
- `detect_monorepo()` function using proper TOML/YAML parsing

**Technical Details:**
```rust
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum MonorepoTool {
    CargoWorkspace,
    NpmWorkspaces,
    PnpmWorkspaces,
    YarnWorkspaces,
    Nx,
    Turborepo,
    Lerna,
    Unknown,
}

pub fn detect_monorepo(root: &Path) -> Result<Option<MonorepoInfo>> {
    // Check in priority order (more specific tools first)
    if let Some(info) = detect_cargo_workspace(root)? { return Ok(Some(info)); }
    if let Some(info) = detect_nx(root)? { return Ok(Some(info)); }
    if let Some(info) = detect_turborepo(root)? { return Ok(Some(info)); }
    if let Some(info) = detect_pnpm_workspace(root)? { return Ok(Some(info)); }
    if let Some(info) = detect_npm_workspace(root)? { return Ok(Some(info)); }
    Ok(None)
}

fn detect_cargo_workspace(root: &Path) -> Result<Option<MonorepoInfo>> {
    let cargo_toml = root.join("Cargo.toml");
    if !cargo_toml.exists() { return Ok(None); }

    let content = std::fs::read_to_string(&cargo_toml)?;
    let parsed: toml::Value = toml::from_str(&content)
        .map_err(|e| SniffError::SystemInfo {
            domain: "monorepo",
            message: e.to_string()
        })?;

    let workspace = match parsed.get("workspace") {
        Some(w) => w,
        None => return Ok(None),
    };

    // Parse members array and expand globs
    let members = workspace.get("members")
        .and_then(|m| m.as_array())
        .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect::<Vec<_>>())
        .unwrap_or_default();

    // ... expand globs and build package list
}
```

**Test Scenarios:**
- Cargo workspace with glob patterns (`"members/*"`)
- `pnpm-workspace.yaml` with glob patterns
- `nx.json` detection
- Nested workspaces (should detect top-level only)
- Invalid/malformed workspace files return errors

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/filesystem/monorepo.rs` exists with >120 lines
- [ ] `grep "toml" sniff/lib/Cargo.toml` succeeds
- [ ] `grep "pub fn detect_monorepo" sniff/lib/src/filesystem/monorepo.rs` succeeds
- [ ] `grep "#\\[non_exhaustive\\]" sniff/lib/src/filesystem/monorepo.rs` succeeds
- [ ] `grep "pub enum MonorepoTool" sniff/lib/src/filesystem/monorepo.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib filesystem::monorepo` runs 4+ tests
- [ ] All tests pass

---

### Phase 7: Filesystem Detection - Dependencies (Stub)

**Principal Owner:** Rust Developer

**Goal:** Create stub for dependency detection (full implementation deferred)

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p sniff-lib --lib filesystem::dependencies`

**Files to create:**
- `sniff/lib/src/filesystem/dependencies.rs` - PackageManager enum, DependencyReport (stub)

**Files to modify:**
- `sniff/lib/src/filesystem/mod.rs` - Add dependencies module

**Deliverables:**
- `PackageManager` enum with primary_language(), registry_url() methods (marked `#[non_exhaustive]`)
- `DependencyReport` struct (empty for now)
- `detect_dependencies()` function returning empty report

**Technical Details:**
```rust
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum PackageManager {
    Npm, Pnpm, Yarn, Bun,
    Cargo,
    Pip, Poetry, Pdm, Uv,
    Bundler,
    Composer,
    Maven, Gradle,
    GoMod,
}

impl PackageManager {
    pub fn primary_language(&self) -> &'static str {
        match self {
            Self::Npm | Self::Pnpm | Self::Yarn | Self::Bun => "JavaScript",
            Self::Cargo => "Rust",
            Self::Pip | Self::Poetry | Self::Pdm | Self::Uv => "Python",
            Self::Bundler => "Ruby",
            Self::Composer => "PHP",
            Self::Maven | Self::Gradle => "Java",
            Self::GoMod => "Go",
        }
    }

    pub fn registry_url(&self) -> Option<&'static str> {
        match self {
            Self::Npm | Self::Pnpm | Self::Yarn | Self::Bun => Some("https://registry.npmjs.org"),
            Self::Cargo => Some("https://crates.io"),
            Self::Pip | Self::Poetry | Self::Pdm | Self::Uv => Some("https://pypi.org"),
            Self::Bundler => Some("https://rubygems.org"),
            Self::Composer => Some("https://packagist.org"),
            Self::Maven => Some("https://repo1.maven.org/maven2"),
            Self::GoMod => Some("https://pkg.go.dev"),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DependencyReport {
    pub packages: Vec<()>, // Stub: empty for v1
}

pub fn detect_dependencies(_root: &Path) -> Result<DependencyReport> {
    // Stub: return empty report
    Ok(DependencyReport::default())
}
```

**Test Scenarios:**
- Returns empty report without errors
- PackageManager enum methods return correct values
- Stub can be safely called on any directory

**Acceptance Criteria:**
- [ ] File `sniff/lib/src/filesystem/dependencies.rs` exists with >60 lines
- [ ] `grep "#\\[non_exhaustive\\]" sniff/lib/src/filesystem/dependencies.rs` succeeds
- [ ] `grep "pub enum PackageManager" sniff/lib/src/filesystem/dependencies.rs` succeeds
- [ ] `grep "pub fn detect_dependencies" sniff/lib/src/filesystem/dependencies.rs` succeeds
- [ ] `cargo test -p sniff-lib --lib filesystem::dependencies` runs 3+ tests
- [ ] All tests pass

---

### Phase 8: Aggregate detect() Function

**Principal Owner:** Rust Developer

**Goal:** Wire all detectors together in the main detect() API

**Dependencies:** Phases 2, 3, 4, 5, 6, 7 complete

**Blast Radius:** `cargo test -p sniff-lib`

**Files to modify:**
- `sniff/lib/src/lib.rs` - SniffResult, SniffConfig, detect(), detect_with_config()
- `sniff/lib/src/filesystem/mod.rs` - FilesystemInfo, detect_filesystem()

**Deliverables:**
- `SniffResult` struct with hardware, network, filesystem
- `SniffConfig` struct with base_dir, skip_* flags and builder methods
- `detect()` function (default config)
- `detect_with_config()` function with tracing instrumentation

**Technical Details:**
```rust
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SniffResult {
    pub hardware: HardwareInfo,
    pub network: NetworkInfo,
    pub filesystem: Option<FilesystemInfo>,
}

#[derive(Debug, Clone, Default)]
pub struct SniffConfig {
    pub base_dir: Option<PathBuf>,
    pub include_cpu_usage: bool,
    pub skip_hardware: bool,
    pub skip_network: bool,
    pub skip_filesystem: bool,
}

impl SniffConfig {
    pub fn new() -> Self { Self::default() }

    pub fn base_dir(mut self, path: PathBuf) -> Self {
        self.base_dir = Some(path);
        self
    }

    pub fn include_cpu_usage(mut self, include: bool) -> Self {
        self.include_cpu_usage = include;
        self
    }

    pub fn skip_hardware(mut self) -> Self {
        self.skip_hardware = true;
        self
    }

    pub fn skip_network(mut self) -> Self {
        self.skip_network = true;
        self
    }

    pub fn skip_filesystem(mut self) -> Self {
        self.skip_filesystem = true;
        self
    }
}

/// Detect system information with default configuration
pub fn detect() -> Result<SniffResult> {
    detect_with_config(SniffConfig::default())
}

/// Detect system information with custom configuration
pub fn detect_with_config(config: SniffConfig) -> Result<SniffResult> {
    let hardware = if config.skip_hardware {
        HardwareInfo::default()
    } else if config.include_cpu_usage {
        hardware::detect_hardware_with_usage()?
    } else {
        hardware::detect_hardware()?
    };

    let network = if config.skip_network {
        NetworkInfo::default()
    } else {
        network::detect_network()?
    };

    let filesystem = if config.skip_filesystem {
        None
    } else {
        let base = config.base_dir.unwrap_or_else(|| std::env::current_dir().unwrap());
        Some(filesystem::detect_filesystem(&base)?)
    };

    Ok(SniffResult { hardware, network, filesystem })
}
```

**Test Scenarios:**
- `skip_hardware` flag actually skips hardware detection
- `skip_network` flag actually skips network detection
- `skip_filesystem` flag actually skips filesystem detection
- `include_cpu_usage` triggers CPU sampling
- All sub-detectors can fail independently without crashing
- Builder pattern works fluently
- Doc tests pass

**Acceptance Criteria:**
- [ ] `grep "pub fn detect\\b" sniff/lib/src/lib.rs` succeeds
- [ ] `grep "pub fn detect_with_config" sniff/lib/src/lib.rs` succeeds
- [ ] `grep "pub struct SniffResult" sniff/lib/src/lib.rs` succeeds
- [ ] `grep "pub struct SniffConfig" sniff/lib/src/lib.rs` succeeds
- [ ] `grep "pub fn base_dir" sniff/lib/src/lib.rs` succeeds (builder method)
- [ ] `cargo test -p sniff-lib` runs 25+ tests total
- [ ] `cargo test --doc -p sniff-lib` passes
- [ ] All tests pass

---

### Phase 9: CLI Implementation

**Principal Owner:** Rust Developer

**Goal:** Create the sniff CLI binary using clap

**Dependencies:** Phase 8 complete

**Blast Radius:** `cargo build -p sniff && cargo test -p sniff`

**Files to create:**
- `sniff/cli/Cargo.toml` - CLI package definition with test dependencies
- `sniff/cli/src/main.rs` - clap-based CLI entry point
- `sniff/cli/src/output.rs` - Output formatters (text, json)

**Files to modify:**
- `Cargo.toml` (workspace) - Add `sniff/cli` to members

**Deliverables:**
- `sniff` CLI binary
- `--base`/`-b` flag for directory override (with path canonicalization)
- `--format`/`-f` flag for output format (text, json)
- Text and JSON output formatters with proper signatures

**Technical Details:**
```rust
// main.rs
use clap::Parser;
use sniff_lib::{detect_with_config, SniffConfig};
use std::path::PathBuf;

mod output;

/// Detect system and repository information
#[derive(Parser)]
#[command(name = "sniff", version, about)]
struct Cli {
    /// Base directory for filesystem analysis
    #[arg(short, long)]
    base: Option<PathBuf>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "text")]
    format: OutputFormat,
}

#[derive(Clone, Copy, clap::ValueEnum)]
enum OutputFormat {
    Text,
    Json,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    // Canonicalize path if provided
    let base_dir = cli.base.map(|p| {
        std::fs::canonicalize(&p).unwrap_or(p)
    });

    let config = SniffConfig {
        base_dir,
        ..Default::default()
    };

    let result = detect_with_config(config)?;

    match cli.format {
        OutputFormat::Text => output::print_text(&result),
        OutputFormat::Json => output::print_json(&result)?,
    }

    Ok(())
}

// output.rs
use sniff_lib::SniffResult;

pub fn print_text(result: &SniffResult) {
    println!("=== Hardware ===");
    println!("OS: {} {}", result.hardware.os.name, result.hardware.os.version);
    println!("CPU: {} ({} cores)", result.hardware.cpu.brand, result.hardware.cpu.logical_cores);
    // ... more fields
}

pub fn print_json(result: &SniffResult) -> serde_json::Result<()> {
    println!("{}", serde_json::to_string_pretty(result)?);
    Ok(())
}
```

**Test Scenarios:**
- `--help` shows correct usage text
- Invalid `--format` value shows error
- `--base` with non-existent directory shows error
- `--base` with relative path is resolved correctly
- Exit codes: 0 for success, non-zero for errors
- JSON output is valid and parsable
- Text output is human-readable

**Acceptance Criteria:**
- [ ] File `sniff/cli/Cargo.toml` exists with assert_cmd, predicates in dev-dependencies
- [ ] File `sniff/cli/src/main.rs` exists with >50 lines
- [ ] File `sniff/cli/src/output.rs` exists with >100 lines
- [ ] `grep 'sniff/cli' Cargo.toml` succeeds (workspace member)
- [ ] `grep "assert_cmd" sniff/cli/Cargo.toml` succeeds
- [ ] `cargo build -p sniff` succeeds
- [ ] `cargo run -p sniff -- --help` shows help text
- [ ] `cargo run -p sniff -- --format json` outputs valid JSON
- [ ] `cargo run -p sniff -- --base .` works

---

### Phase 10: Integration Testing and Documentation

**Principal Owner:** Feature Tester

**Goal:** Add integration tests, fixture helpers, and verify end-to-end functionality

**Dependencies:** Phase 9 complete

**Blast Radius:** `cargo test -p sniff-lib && cargo test -p sniff`

**Files to create:**
- `sniff/lib/tests/integration.rs` - Integration tests for library
- `sniff/lib/tests/fixtures.rs` - Test fixture helpers
- `sniff/cli/tests/cli.rs` - CLI integration tests

**Files to modify:**
- `sniff/lib/Cargo.toml` - Add tempfile to dev-dependencies

**Deliverables:**
- Integration tests for `detect()` function
- Fixture helpers for creating temporary git repos
- CLI tests using `assert_cmd` crate
- All tests passing

**Technical Details:**
```rust
// sniff/lib/tests/fixtures.rs
use git2::Repository;
use std::path::PathBuf;
use tempfile::TempDir;

/// Create a temporary git repo for testing
pub fn create_test_git_repo() -> (TempDir, PathBuf) {
    let dir = TempDir::new().unwrap();
    let _repo = Repository::init(dir.path()).unwrap();
    let path = dir.path().to_path_buf();
    (dir, path)
}

/// Create a Cargo workspace structure
pub fn create_cargo_workspace() -> (TempDir, PathBuf) {
    let dir = TempDir::new().unwrap();
    std::fs::write(
        dir.path().join("Cargo.toml"),
        "[workspace]\nmembers = [\"pkg1\", \"pkg2\"]\n",
    ).unwrap();
    std::fs::create_dir(dir.path().join("pkg1")).unwrap();
    std::fs::create_dir(dir.path().join("pkg2")).unwrap();
    let path = dir.path().to_path_buf();
    (dir, path)
}

// sniff/lib/tests/integration.rs
use sniff_lib::{detect, detect_with_config, SniffConfig};
use std::path::PathBuf;

mod fixtures;

#[test]
fn test_detect_returns_hardware_info() {
    let result = detect().unwrap();
    assert!(!result.hardware.os.name.is_empty());
    assert!(result.hardware.memory.total_bytes > 0);
}

#[test]
fn test_detect_with_custom_base_dir() {
    let config = SniffConfig::new().base_dir(PathBuf::from("."));
    let result = detect_with_config(config).unwrap();
    assert!(result.filesystem.is_some());
}

#[test]
fn test_detect_in_git_repo() {
    let (_dir, path) = fixtures::create_test_git_repo();
    let config = SniffConfig::new().base_dir(path);
    let result = detect_with_config(config).unwrap();
    let fs = result.filesystem.unwrap();
    assert!(fs.git.is_some());
}

#[test]
fn test_detect_cargo_workspace() {
    let (_dir, path) = fixtures::create_cargo_workspace();
    let config = SniffConfig::new().base_dir(path);
    let result = detect_with_config(config).unwrap();
    let fs = result.filesystem.unwrap();
    assert!(fs.monorepo.is_some());
}

// sniff/cli/tests/cli.rs
use assert_cmd::Command;
use predicates::prelude::*;

#[test]
fn test_help_flag() {
    Command::cargo_bin("sniff")
        .unwrap()
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("Detect system"));
}

#[test]
fn test_json_output() {
    Command::cargo_bin("sniff")
        .unwrap()
        .args(["--format", "json"])
        .assert()
        .success()
        .stdout(predicate::str::contains("\"hardware\""));
}

#[test]
fn test_invalid_base_dir() {
    Command::cargo_bin("sniff")
        .unwrap()
        .args(["--base", "/nonexistent/path/that/does/not/exist"])
        .assert()
        .failure();
}
```

**Test Scenarios:**
- Full detect() on real system completes in <300ms (NFR-1)
- Serialization roundtrip: `serde_json::from_str(&serde_json::to_string(&result))`
- Concurrent calls to `detect()` don't interfere
- Fixture helpers work correctly

**Acceptance Criteria:**
- [ ] File `sniff/lib/tests/integration.rs` exists with >80 lines
- [ ] File `sniff/lib/tests/fixtures.rs` exists with >40 lines
- [ ] File `sniff/cli/tests/cli.rs` exists with >40 lines
- [ ] `grep "tempfile" sniff/lib/Cargo.toml` succeeds
- [ ] `cargo test -p sniff-lib --test integration` runs 6+ tests
- [ ] `cargo test -p sniff --test cli` runs 3+ tests
- [ ] All tests pass
- [ ] `cargo build --release -p sniff` succeeds

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests:** `#[cfg(test)] mod tests` blocks in each module
- **Integration tests:** `tests/` directory for end-to-end workflows
- **Fixture data:** Use tempfile crate for git/filesystem tests
- **Mocking:** Minimal mocking; prefer real system calls for hardware/network
- **Doc tests:** All public APIs have runnable examples

### Cross-Platform Testing (macOS + Linux)

Both platforms are fully supported in v1. Key considerations:

| Area | macOS | Linux | Test Strategy |
|------|-------|-------|---------------|
| Network interfaces | `en0`, `lo0`, `utun0` | `eth0`, `lo`, `wlan0`, `enp0s3` | Test by flags (is_loopback), not names |
| MAC addresses | `AF_LINK` | `AF_PACKET` | getifaddrs handles internally |
| Storage mounts | `/`, `/Volumes/*` | `/`, `/mnt/*`, `/media/*` | sysinfo abstracts; test mount_point is PathBuf |
| OS detection | "macOS", "14.x" | "Ubuntu"/"Fedora", version | Test non-empty strings, not specific values |
| File paths | Unix paths | Unix paths | Both POSIX-compliant, no differences |

**CI Recommendations:**
- Run tests on both macOS and Linux runners (GitHub Actions supports both)
- Use `#[cfg(target_os = "...")]` only if platform-specific behavior is intentional
- Avoid hardcoding interface names, mount paths, or OS names in assertions

### Error Handling

- All errors use `thiserror` with descriptive messages including domain context
- No `unwrap()` or `expect()` in library code
- CLI uses `Box<dyn Error>` for simplicity
- Network permission denied handled gracefully with flag

### Performance Considerations

- Use `sysinfo::RefreshKind` to only refresh needed data
- Early termination in language detection (10k files max, configurable in future)
- Avoid blocking on CPU usage by default
- HashMap to Vec conversion uses IndexMap if ordering needed

### Documentation

- All public items have doc comments
- Examples in doc comments for main APIs
- README.md in each module directory (deferred to v2)

### Tracing (Future)

- Libraries should emit spans, applications configure subscribers
- Consider adding `#[tracing::instrument]` in Phase 8's detect_with_config()
- Deferred to v2 to minimize scope

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 2, 3, 4, 5, 6, 7 | All depend only on Phase 1, no cross-dependencies |
| Group B | Phase 8 | Depends on Group A |
| Group C | Phase 9, 10 | Depend on Phase 8 |

### Parallelization Diagram

```
Timeline:
───────────────────────────────────────────────────────►

Phase 1: ████ (Error types + justfile)
              │
              ├─────┬─────┬─────┬─────┬─────┐
              ▼     ▼     ▼     ▼     ▼     ▼
Group A:    ████  ████  ████  ████  ████  ████
           (Ph2) (Ph3) (Ph4) (Ph5) (Ph6) (Ph7)
              │     │     │     │     │     │
              └─────┴─────┴─────┴─────┴─────┘
                              │
                              ▼
Group B:                    ████ (Phase 8: Aggregate)
                              │
                        ┌─────┴─────┐
                        ▼           ▼
Group C:              ████        ████
                     (Ph9)       (Ph10)
```

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| `hyperpolyglot` may not compile on all platforms | Medium | Fall back to extension-based detection |
| `getifaddrs` may require permissions | Low | Graceful error handling with permission_denied flag |
| Large repos slow down language detection | Medium | Early termination after 10k files |
| GPU detection requires drivers | Low | Feature-gated, graceful degradation |
| Windows not supported in v1 | Medium | Document macOS/Linux only; Windows in v2 |
| Platform-specific interface names | Low | Tests are name-agnostic; primary interface logic checks flags not names |
| macOS vs Linux storage paths | Low | sysinfo abstracts mount point differences |

## Open Questions

- [x] Should dependency detection be fully implemented or stubbed for v1?
  - **Decision:** Stubbed for v1, full implementation in v2
- [x] Should we add `--verbose` flag to CLI?
  - **Decision:** Defer to v2
- [x] Should we support YAML output format?
  - **Decision:** Defer to v2, start with text and JSON
- [x] Windows support?
  - **Decision:** macOS and Linux supported in v1; Windows deferred to v2 (getifaddrs is Unix-only, would need winapi/windows-rs for network enumeration)

## Dependencies to Add

### sniff/lib/Cargo.toml

```toml
[package]
name = "sniff-lib"
version = "0.1.0"
edition = "2021"

[dependencies]
chrono = { version = "0.4", features = ["serde"] }
getifaddrs = "0.6.0"
git2 = "0.20.3"
hyperpolyglot = "0.1.7"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
sysinfo = "0.37.2"
thiserror = "2.0"
toml = "0.8"
walkdir = "2.5"

[dev-dependencies]
tempfile = "3"

[features]
default = []
gpu = ["hardware-query"]

[dependencies.hardware-query]
version = "0.2.1"
features = ["gpu-all"]
optional = true
```

### sniff/cli/Cargo.toml

```toml
[package]
name = "sniff"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "sniff"
path = "src/main.rs"

[dependencies]
clap = { version = "4", features = ["derive"] }
serde_json = "1.0"
sniff-lib = { path = "../lib" }

[dev-dependencies]
assert_cmd = "2"
predicates = "3"
```
