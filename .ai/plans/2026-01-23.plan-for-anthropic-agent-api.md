---
status: "completed"
started_at: "2026-01-23T12:00:00Z"
finished_at:
duration:
tts_gender: male
requirements: |
  Implement the Anthropic Agent API in the schematic package. This includes:
  - Creating the API definition module at schematic/definitions/src/anthropic/
  - Defining comprehensive request and response types for:
    - Messages API (POST /v1/messages) - the core endpoint for agent interactions
    - Count Tokens API (POST /v1/messages/count_tokens)
    - List Models API (GET /v1/models)
    - Retrieve Model API (GET /v1/models/{model_id})
  - Supporting tool use patterns for AI agent loops
  - Following existing schematic patterns from OpenAI and Ollama definitions
required_skills:
  - anthropic-agent-api
  - rust
important_skills: {}
subagents: {}
monorepo_modules_impacted:
  - schematic/definitions
  - schematic/schema
completeness_changes: []
concurrency_changes: []
detail_changes: []
lessons_learned_count: 0
---

# Planning Process

- [x] Prep Started [2026-01-23T12:00:00Z]
    - [x] Identified Skills [2026-01-23T12:00:00Z] - anthropic-agent-api, rust
    - [x] Reviewed existing schematic patterns [2026-01-23T12:00:00Z]
- [x] Requirements gathered from Anthropic API docs [2026-01-23T12:00:00Z]

## Plan

### Phase 1: Create Type Definitions

Create `schematic/definitions/src/anthropic/types.rs` with comprehensive Rust types:

**Core Message Types:**
- `MessageRole` - enum for "user" | "assistant"
- `ContentBlock` - tagged enum for text, image, document, tool_use, tool_result
- `TextBlock` - text content with optional citations
- `ImageBlock` - base64 or URL image source
- `DocumentBlock` - PDF/text document source
- `ToolUseBlock` - tool invocation with id, name, input
- `ToolResultBlock` - tool execution result with id and content
- `ThinkingBlock` - extended thinking content (response only)
- `Message` - role + content blocks

**Tool System Types:**
- `Tool` - name, description, input_schema
- `ToolChoice` - auto | any | tool(name) | none
- `CacheControl` - ephemeral cache with TTL

**Request Types:**
- `CreateMessageBody` - model, messages, max_tokens, system, tools, tool_choice, etc.
- `CountTokensBody` - same as CreateMessageBody minus max_tokens

**Response Types:**
- `MessageResponse` - id, type, role, model, content, stop_reason, usage
- `Usage` - input/output tokens, cache stats
- `CountTokensResponse` - input_tokens count
- `StopReason` - enum for end_turn | max_tokens | stop_sequence | tool_use | pause_turn | refusal

**Models API Types:**
- `ModelInfo` - id, created_at, display_name, type
- `ListModelsResponse` - data array, pagination fields (first_id, last_id, has_more)

### Phase 2: Create API Definition

Create `schematic/definitions/src/anthropic/mod.rs` with:

- `define_anthropic_api()` function returning `RestApi`
- Base URL: `https://api.anthropic.com/v1`
- Auth: `ApiKey { header: "X-Api-Key" }`
- Required header: `anthropic-version: 2023-06-01`
- Env auth: `ANTHROPIC_API_KEY`

**Endpoints:**
1. `CreateMessage` - POST /messages - Core agent loop endpoint
2. `CountTokens` - POST /messages/count_tokens - Token counting
3. `ListModels` - GET /models - List available models
4. `RetrieveModel` - GET /models/{model_id} - Get specific model

### Phase 3: Register in Definitions Crate

Update `schematic/definitions/src/lib.rs`:
- Add `pub mod anthropic;`
- Re-export `define_anthropic_api`
- Add docstring example

### Phase 4: Generate Schema Client

Run code generation:
```bash
cargo build -p schematic-gen
just -f schematic/justfile generate
```

Verify generated client at `schematic/schema/src/anthropic.rs`

### Phase 5: Testing

1. Run definition tests: `cargo test -p schematic-definitions`
2. Run generation tests: `cargo test -p schematic-gen`
3. Run schema compilation: `cargo check -p schematic-schema`
4. Manual verification of generated client structure

## Key Implementation Notes

**Authentication:**
- Anthropic uses `X-Api-Key` header (not Authorization: Bearer)
- Required version header: `anthropic-version: 2023-06-01`

**Response Type Selection:**
- Messages endpoint returns JSON (use `ApiResponse::json_type`)
- Streaming would use Binary but we'll start with non-streaming

**Serde Patterns:**
- Use `#[serde(tag = "type", rename_all = "snake_case")]` for content blocks
- Use `#[serde(skip_serializing_if = "Option::is_none")]` for optional fields
- Use `#[serde(default)]` where appropriate

## Lessons Learned

> Capture discoveries about skills or memory resources that were inaccurate, incomplete, or missing.

(none yet)

## Package Changes in Execution

> Dependencies to be added, updated, or removed during implementation.

(no new dependencies needed - using existing serde, reqwest via schematic-schema)
