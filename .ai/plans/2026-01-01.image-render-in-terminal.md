# Image Render in Terminal

**Created:** 2026-01-01
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Add native image rendering to the `mat` CLI and `shared/markdown` terminal output module. When markdown contains image references (`![alt](path)`), detect terminal graphics protocol support (Kitty/iTerm2/Sixel) via `viuer` and render images inline. Fall back to styled text placeholder (`▉ IMAGE[alt_text]`) when graphics protocols are unsupported.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Parse `![alt](path)` image syntax in markdown content | High | Rust Developer |
| FR-2 | Detect graphics protocol support (Kitty/iTerm2) via viuer | High | Rust Developer |
| FR-3 | Render local images via `viuer::print_from_file()` when graphics available | High | Rust Developer |
| FR-4 | Display styled fallback `▉ IMAGE[alt_text]` when graphics unsupported | High | Rust Developer |
| FR-5 | Resolve relative image paths against markdown file's base directory | Medium | Rust Developer |
| FR-6 | Scale images to fit terminal width (with 4-char padding) | Medium | Rust Developer |
| FR-7 | Validate paths don't escape base directory (path traversal prevention) | High | Rust Developer |
| FR-8 | Reject files larger than 10MB (memory safety) | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Minimal performance impact when images absent | <5ms overhead | Rust Developer |
| NFR-2 | Graceful degradation when image file missing | Display placeholder | Rust Developer |
| NFR-3 | Memory efficient for large images | 10MB file size limit | Rust Developer |
| NFR-4 | Test coverage for image event handling | >80% branch coverage | Feature Tester |
| NFR-5 | Tracing instrumentation for debugging | DEBUG-level logging | Rust Developer |

## Architecture Overview

The implementation extends the existing `pulldown_cmark` event loop in `shared/src/markdown/output/terminal.rs` to handle `Event::Start(Tag::Image)` and `Event::End(TagEnd::Image)` events.

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                           mat CLI                                    │
│  (mat/src/main.rs)                                                  │
│    └── TerminalOptions { render_images, base_path }                 │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     shared/src/markdown/output/terminal.rs           │
│                                                                      │
│  for_terminal() ─────┬──── Event::Start(Tag::Image) ────────────┐   │
│                      │                                           │   │
│                      │     ┌─────────────────────────────────┐   │   │
│                      │     │ ImageRenderer                   │   │   │
│                      │     │  - graphics_supported: bool     │   │   │
│                      │     │  - is_tty: bool                 │   │   │
│                      │     │  - base_path: PathBuf           │   │   │
│                      │     │  - terminal_width: u16          │   │   │
│                      └────►│                                 │   │   │
│                            │  render_image(path, alt) ───────┼───┘   │
│                            │    ├── path validation          │       │
│                            │    ├── viuer::print_from_file() │       │
│                            │    └── fallback placeholder     │       │
│                            └─────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           viuer crate                                │
│                                                                      │
│  get_kitty_support() → KittySupport::{Local, Remote, None}          │
│  is_iterm_supported() → bool                                        │
│  print_from_file(path, &Config) → ViuResult<()>                     │
│  terminal_size() → Option<(u16, u16)>                               │
└─────────────────────────────────────────────────────────────────────┘
```

### Data Flow

1. `mat` CLI invokes `for_terminal(&md, options)`
2. `for_terminal()` creates `ImageRenderer` with:
   - TTY detection via `std::io::IsTerminal`
   - Graphics protocol detection (Kitty OR iTerm2)
   - Terminal width cached
3. `pulldown_cmark` parser emits `Start(Tag::Image)` → `Text(alt)` → `End(TagEnd::Image)`
4. Image path extracted from `dest_url` in `Tag::Image`
5. Alt text accumulated during `Text` and `Code` events while `in_image` flag is true
6. On `End(TagEnd::Image)`:
   - Validate path doesn't escape base directory
   - Check file size < 10MB
   - If graphics supported AND file valid → `viuer::print_from_file()`
   - Else → emit styled fallback text with DEBUG tracing

## Phases

### Phase 1: Add viuer Dependency and Image Types

**Principal Owner:** Rust Developer

**Goal:** Add the `viuer` crate with `print-file` feature and create type definitions for image rendering configuration.

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to create/modify:**
- `shared/Cargo.toml` - Add viuer dependency with `print-file` feature
- `shared/src/markdown/output/terminal.rs` - Add `ImageRenderer` struct and types

**Deliverables:**
- viuer `0.9` with `print-file` feature added to `shared/Cargo.toml`
- `ImageRenderer` struct with:
  - `graphics_supported: bool` (cached from Kitty OR iTerm2 detection)
  - `is_tty: bool` (cached from `std::io::IsTerminal`)
  - `base_path: PathBuf` (for resolving relative image paths)
  - `base_path_canonical: Option<PathBuf>` (cached canonicalized path for security)
  - `terminal_width: u16` (for image sizing)
- Unit tests for `ImageRenderer::new()` initialization

**Technical Details:**
```rust
use std::io::IsTerminal;
use viuer::{get_kitty_support, is_iterm_supported, KittySupport};

/// Maximum image file size (10MB)
const MAX_IMAGE_FILE_SIZE: u64 = 10 * 1024 * 1024;

/// Renderer for inline images in terminal output.
struct ImageRenderer {
    graphics_supported: bool,
    is_tty: bool,
    base_path: PathBuf,
    base_path_canonical: Option<PathBuf>,
    terminal_width: u16,
}

impl ImageRenderer {
    fn new(base_path: Option<&Path>) -> Self {
        let is_tty = std::io::stdout().is_terminal();

        let kitty_supported = matches!(
            get_kitty_support(),
            KittySupport::Local | KittySupport::Remote
        );
        let graphics_supported = is_tty && (kitty_supported || is_iterm_supported());

        let terminal_width = terminal_size()
            .map(|(Width(w), _)| w)
            .unwrap_or(80);

        let base = base_path
            .map(|p| p.to_path_buf())
            .unwrap_or_else(|| std::env::current_dir().unwrap_or_default());

        let base_canonical = base.canonicalize().ok();

        Self {
            graphics_supported,
            is_tty,
            base_path: base,
            base_path_canonical: base_canonical,
            terminal_width,
        }
    }
}
```

**Acceptance Criteria:**
- [ ] `viuer = { version = "0.9", features = ["print-file"] }` in `shared/Cargo.toml`
- [ ] `ImageRenderer` struct exists in `terminal.rs`
- [ ] `graphics_supported` checks both Kitty AND iTerm2
- [ ] `is_tty` check prevents graphics in non-TTY contexts
- [ ] `cargo build -p shared` succeeds with no warnings
- [ ] 5+ unit tests for `ImageRenderer::new()` pass

---

### Phase 2: Implement Image Event Handling

**Principal Owner:** Rust Developer

**Goal:** Add `Tag::Image` event handling to the `for_terminal()` function's event loop.

**Dependencies:** Phase 1

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Add image event handling to parser loop

**Deliverables:**
- Image event tracking state: `in_image: bool`, `current_alt: String`, `current_image_path: String`
- Handle `Event::Start(Tag::Image { dest_url, .. })` - capture path, set flag
- Handle `Event::Text(text)` when `in_image` - accumulate alt text
- Handle `Event::Code(code)` when `in_image` - accumulate inline code in alt text
- Handle `Event::End(TagEnd::Image)` - trigger rendering

**Technical Details:**
```rust
// Add to for_terminal() function state
let mut in_image = false;
let mut current_alt = String::new();
let mut current_image_path = String::new();

// In the match block:
Event::Start(Tag::Image { dest_url, .. }) => {
    in_image = true;
    current_alt.clear();
    current_image_path = dest_url.to_string();
}
Event::Text(text) if in_image => {
    current_alt.push_str(&text);
}
Event::Code(code) if in_image => {
    // Preserve inline code in alt text
    current_alt.push('`');
    current_alt.push_str(&code);
    current_alt.push('`');
}
Event::End(TagEnd::Image) => {
    // Render image (Phase 3)
    in_image = false;
}
```

**Acceptance Criteria:**
- [ ] `Event::Start(Tag::Image` handled in match block
- [ ] `Event::Text` accumulates alt text when `in_image` is true
- [ ] `Event::Code` accumulates inline code in alt text when `in_image` is true
- [ ] `Event::End(TagEnd::Image)` resets state
- [ ] `cargo test -p shared --lib markdown::output::terminal` passes
- [ ] 5+ unit tests for image event handling

---

### Phase 3: Implement Image Rendering Logic

**Principal Owner:** Rust Developer

**Goal:** Implement `ImageRenderer::render_image()` method with path validation, size limits, and graceful fallback.

**Dependencies:** Phase 2

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Add `render_image()` method

**Deliverables:**
- `render_image(&self, image_path: &str, alt_text: &str) -> String` method
- URL rejection (http://, https://)
- Path traversal validation via canonicalize + starts_with
- File size check (reject >10MB)
- viuer rendering with error logging
- Fallback path with tracing

**Technical Details:**
```rust
impl ImageRenderer {
    #[tracing::instrument(skip(self), fields(
        image.path = %image_path,
        image.graphics_supported = %self.graphics_supported
    ))]
    fn render_image(&self, image_path: &str, alt_text: &str) -> String {
        // Reject remote URLs
        if image_path.starts_with("http://") || image_path.starts_with("https://") {
            tracing::debug!("Remote URLs not supported");
            return format!("▉ IMAGE[{}]\n", alt_text);
        }

        let full_path = if Path::new(image_path).is_absolute() {
            PathBuf::from(image_path)
        } else {
            self.base_path.join(image_path)
        };

        // Security: Prevent path traversal
        if let Some(ref base_canonical) = self.base_path_canonical {
            if let Ok(canonical_image) = full_path.canonicalize() {
                if !canonical_image.starts_with(base_canonical) {
                    tracing::warn!(path = %image_path, "Image path escapes base directory");
                    return format!("▉ IMAGE[{}]\n", alt_text);
                }
            }
        }

        // Check file exists
        if !full_path.exists() {
            tracing::debug!(path = %image_path, "Image file not found");
            return format!("▉ IMAGE[{}]\n", alt_text);
        }

        // Check file size
        if let Ok(metadata) = std::fs::metadata(&full_path) {
            if metadata.len() > MAX_IMAGE_FILE_SIZE {
                tracing::warn!(size = metadata.len(), "Image file too large (>10MB)");
                return format!("▉ IMAGE[{}]\n", alt_text);
            }
        }

        // Fallback if graphics unsupported
        if !self.graphics_supported {
            tracing::debug!("Graphics protocol not available");
            return format!("▉ IMAGE[{}]\n", alt_text);
        }

        let config = viuer::Config {
            width: Some((self.terminal_width.saturating_sub(4)) as u32), // 2-char margin each side
            transparent: true,
            truecolor: true,
            ..Default::default()
        };

        match viuer::print_from_file(&full_path, &config) {
            Ok(()) => {
                tracing::debug!(path = %image_path, "Image rendered successfully");
                "\n".to_string()
            }
            Err(e) => {
                tracing::warn!(path = %image_path, error = %e, "Image render failed");
                format!("▉ IMAGE[{}]\n", alt_text)
            }
        }
    }
}
```

**Acceptance Criteria:**
- [ ] `render_image()` method exists and compiles
- [ ] Remote URLs (http/https) produce fallback
- [ ] Path traversal attempts produce fallback with warning
- [ ] Files >10MB produce fallback with warning
- [ ] Missing files produce fallback (not panic)
- [ ] viuer errors produce fallback with warning (not panic)
- [ ] Tracing instrumentation present at DEBUG/WARN levels
- [ ] 10+ unit tests including security edge cases
- [ ] `cargo test -p shared --lib markdown::output::terminal` passes

---

### Phase 4: Integrate ImageRenderer into for_terminal()

**Principal Owner:** Rust Developer

**Goal:** Wire up `ImageRenderer` into the main `for_terminal()` function and add option to disable image rendering.

**Dependencies:** Phase 3

**Blast Radius:** `cargo test -p shared` (full shared crate)

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Integrate ImageRenderer into for_terminal()
- Add `render_images: bool` and `base_path: Option<PathBuf>` fields to `TerminalOptions`

**Deliverables:**
- `TerminalOptions.render_images: bool` field (default: `true`)
- `TerminalOptions.base_path: Option<PathBuf>` field (default: `None`)
- `ImageRenderer` instantiated once at start of `for_terminal()` if images enabled
- `render_image()` called on `End(TagEnd::Image)` and result appended to output

**Technical Details:**
```rust
// TerminalOptions modification
#[non_exhaustive]
pub struct TerminalOptions {
    // ... existing fields ...
    /// Whether to render images (via viuer) or show fallback text.
    /// Default: true
    pub render_images: bool,
    /// Base path for resolving relative image paths.
    /// If None, uses current working directory.
    pub base_path: Option<PathBuf>,
}

impl Default for TerminalOptions {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            render_images: true,
            base_path: None,
        }
    }
}

// In for_terminal():
let image_renderer = if options.render_images {
    Some(ImageRenderer::new(options.base_path.as_deref()))
} else {
    None
};

// In Event::End(TagEnd::Image):
if let Some(ref renderer) = image_renderer {
    output.push_str(&renderer.render_image(&current_image_path, &current_alt));
} else {
    output.push_str(&format!("▉ IMAGE[{}]\n", current_alt));
}
```

**Note on `#[non_exhaustive]`:** External consumers cannot use struct update syntax (`..Default::default()`) and must use `let mut opts = TerminalOptions::default(); opts.render_images = true;` pattern.

**Acceptance Criteria:**
- [ ] `TerminalOptions.render_images` field exists with default `true`
- [ ] `TerminalOptions.base_path` field exists with default `None`
- [ ] Images render when `render_images: true` and graphics available
- [ ] Images show fallback when `render_images: false`
- [ ] ImageRenderer only instantiated when `render_images: true`
- [ ] 5+ integration tests for TerminalOptions image fields
- [ ] `cargo test -p shared` passes (all crate tests)

---

### Phase 5: CLI Integration

**Principal Owner:** Rust Developer

**Goal:** Add `--no-images` flag to `mat` CLI.

**Dependencies:** Phase 4

**Blast Radius:** `cargo test -p mat` + `cargo test -p shared`

**Files to modify:**
- `mat/src/main.rs` - Add `--no-images` CLI flag

**Deliverables:**
- `--no-images` flag in mat CLI
- Flag maps to `TerminalOptions.render_images = false`
- Help text describes behavior
- Base path derived from input file path (if provided) or cwd

**Technical Details:**
```rust
// In mat/src/main.rs Cli struct:
/// Disable image rendering (show placeholders instead)
#[arg(long)]
no_images: bool,

// In main():
options.render_images = !cli.no_images;

// Derive base_path from input file:
if let Some(ref path) = cli.input {
    if path.to_str() != Some("-") {
        options.base_path = path.parent().map(|p| p.to_path_buf());
    }
}
```

**Acceptance Criteria:**
- [ ] `mat --help` shows `--no-images` flag with description
- [ ] `mat --no-images file.md` produces fallback text for images
- [ ] `mat file.md` (without flag) attempts image rendering
- [ ] Base path correctly derived from input file path
- [ ] stdin input (`-`) uses cwd as base path
- [ ] 3+ integration tests for CLI flag behavior
- [ ] `cargo build -p mat` succeeds
- [ ] `cargo test -p mat` passes

---

### Phase 6: Comprehensive Testing

**Principal Owner:** Feature Tester (Rust)

**Goal:** Add comprehensive test coverage for all image rendering scenarios.

**Dependencies:** Phase 5

**Blast Radius:** `cargo test -p shared` + `cargo test -p mat`

**Files to create/modify:**
- `shared/tests/image_rendering_integration.rs` - Integration test file
- `shared/tests/fixtures/images/` - Test fixture directory
- `shared/tests/common/images.rs` - Test helpers

**Test Fixture Requirements:**
```
shared/tests/fixtures/images/
  ├── small.png         (100x100, <10KB)
  ├── medium.jpg        (800x600, ~200KB)
  ├── large.png         (3000x2000, ~2MB for sizing)
  ├── corrupted.png     (invalid header bytes)
  ├── test_doc.md       (markdown with relative image paths)
  └── multi_image.md    (multiple images for state testing)
```

**Test Scenarios:**

**Core Functionality:**
- [ ] Image with local file (relative path) → fallback or render
- [ ] Image with absolute path → resolves correctly
- [ ] Image with missing file → fallback
- [ ] Empty alt text (`![](image.png)`) → fallback shows `▉ IMAGE[]`
- [ ] Alt text with inline code (`![Code `snippet`](img.png)`) → preserved

**Security Tests:**
- [ ] Path traversal (`../../etc/passwd`) → fallback with warning
- [ ] Absolute path outside base → handled safely
- [ ] Symlink outside base → fallback

**Error Handling:**
- [ ] Corrupted image file → fallback (not panic)
- [ ] Permission denied → fallback
- [ ] File >10MB → fallback with warning
- [ ] Remote URL (http://) → fallback

**Context Tests:**
- [ ] Multiple images in one document → each handled independently
- [ ] Images inside list items → renders correctly
- [ ] Images inside blockquotes → renders correctly
- [ ] Images inside table cells → renders correctly

**Terminal Edge Cases:**
- [ ] Narrow terminal (width=10) → scales or fallback
- [ ] Terminal width=0 → uses default 80
- [ ] `terminal_size()` returns None → uses default 80
- [ ] `render_images: false` → always fallback

**CI-Friendly Tests:**
```rust
#[test]
fn test_image_renders_or_fallback_gracefully() {
    // Works in both CI (fallback) and local Kitty (render)
    let md: Markdown = "![Test](./fixtures/images/small.png)".into();
    let output = for_terminal(&md, TerminalOptions::default()).unwrap();

    // Either rendered OR fallback, never panic
    assert!(
        output.contains("\x1b[") || output.contains("▉ IMAGE"),
        "Must render or fallback gracefully"
    );
}
```

**Acceptance Criteria:**
- [ ] `shared/tests/image_rendering_integration.rs` exists with 15+ tests
- [ ] `shared/tests/fixtures/images/` directory exists with fixture files
- [ ] `shared/tests/common/images.rs` exists with helper functions
- [ ] All security test scenarios pass
- [ ] All error handling scenarios pass
- [ ] All context test scenarios pass
- [ ] `cargo test -p shared` passes with all new tests
- [ ] `cargo test -p mat` passes
- [ ] Test coverage for image module >80%

**Manual Testing Checklist:**
Run in Kitty/iTerm2 terminal:
- [ ] `cargo run -p mat -- test_doc_with_images.md` shows actual images
- [ ] `cargo run -p mat -- --no-images test_doc_with_images.md` shows fallback
- [ ] Image scales to terminal width correctly
- [ ] Text after image doesn't overlap

---

## Blast Radius Analysis

| Phase | Change Type | Blast Radius |
|-------|------------|--------------|
| 1 | New dependency + struct | `cargo test -p shared --lib markdown::output::terminal` |
| 2 | Event loop modification | `cargo test -p shared --lib markdown::output::terminal` |
| 3 | New method + security | `cargo test -p shared --lib markdown::output::terminal` |
| 4 | Options struct change | `cargo test -p shared` |
| 5 | CLI flag addition | `cargo test -p mat` + `cargo test -p shared` |
| 6 | Integration tests | `cargo test -p shared` + `cargo test -p mat` |

## Cross-Cutting Concerns

### Testing Strategy
- Unit tests in `#[cfg(test)] mod tests` blocks in `terminal.rs`
- Integration tests in `shared/tests/image_rendering_integration.rs`
- CI tests verify fallback path; manual testing verifies actual rendering
- Snapshot tests (insta) for fallback text format

### Security Considerations
- **Path traversal**: Canonicalize + starts_with validation (implemented in Phase 3)
- **File size**: 10MB limit enforced (implemented in Phase 3)
- **Remote URLs**: Explicitly rejected (implemented in Phase 3)

### Performance Considerations
- **Lazy detection**: Cache graphics support and terminal width once
- **Canonical path caching**: Base path canonicalized once at init
- **Large images**: viuer handles resizing, 10MB limit prevents OOM

### Tracing Integration
Following `docs/tracing.md` conventions:
- DEBUG: Successful renders, fallback reasons
- WARN: Security violations (path traversal), large files, viuer errors

### Error Handling
- **Path traversal**: Log warning, return fallback
- **File not found**: Log debug, return fallback
- **viuer errors**: Log warning with error message, return fallback
- **Never panic**: All error paths return fallback text

## Parallelization Opportunities

This is a sequential feature implementation. Each phase builds on the previous.

| Group | Phases | Can Start After |
|-------|--------|-----------------|
| A | Phase 1 | Plan approval |
| B | Phase 2 | Phase 1 complete |
| C | Phase 3 | Phase 2 complete |
| D | Phase 4 | Phase 3 complete |
| E | Phase 5 | Phase 4 complete |
| F | Phase 6 | Phase 5 complete |

**Within-Phase Parallelization:**
- Phase 6 test creation can be split among multiple developers

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| viuer protocol detection unreliable | Medium | TTY check + fallback; `--no-images` flag |
| Large images slow rendering | Low | 10MB file size limit |
| Path traversal vulnerability | High | Canonicalize + starts_with validation |
| Terminal escapes leak in fallback | Medium | Fallback text is plain (no escapes) |
| pulldown-cmark Image event changes | Low | Pin pulldown-cmark version; test thoroughly |

## Resolved Questions

Based on review feedback, the following decisions were made:

1. **iTerm2/Sixel detection**: YES - Detect iTerm2 in addition to Kitty (field renamed to `graphics_supported`)
2. **Path traversal prevention**: YES - Implemented via canonicalize + starts_with
3. **File size limits**: YES - 10MB limit to prevent OOM
4. **TTY detection**: YES - Skip graphics in non-TTY contexts
5. **Tracing instrumentation**: YES - DEBUG for success, WARN for security/errors
6. **Alt text inline code**: YES - Handle `Event::Code` inside image alt text

## Open Questions

- [ ] Should we support URL images via HTTP fetch? (Deferred - explicitly rejected for now)
- [ ] Should alt text be rendered below image in Kitty mode for accessibility?

## Review Summary

**Reviews Completed:** 2026-01-01

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. **Protocol detection expanded**: Now checks both Kitty AND iTerm2 (field renamed `graphics_supported`)
2. **TTY detection added**: Skip graphics when stdout is not a terminal
3. **Path traversal validation added**: Canonicalize + starts_with check in Phase 3
4. **File size limit added**: 10MB limit prevents OOM on huge images
5. **Tracing instrumentation added**: DEBUG/WARN logging throughout
6. **Event::Code handling added**: Preserve inline code in alt text
7. **Comprehensive test scenarios**: Security tests, edge cases, CI-friendly tests
8. **Test fixtures specified**: Explicit fixture requirements in Phase 6
9. **Config improvements**: Added `truecolor: true` to viuer Config

**Resolved Concerns:**
- Path traversal vulnerability → Canonicalize + starts_with validation
- Non-TTY context handling → `is_tty` check before graphics
- Memory safety → 10MB file size limit
- Debugging difficulty → Tracing instrumentation added
- CI testing → CI-friendly test approach documented
