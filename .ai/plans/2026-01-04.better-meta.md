# Better Meta - Research Metadata Improvements

**Created:** 2026-01-04
**Status:** Reviewed - Ready for Implementation

## Executive Summary

This plan improves the Research Area's metadata capture system to support multiple research types beyond `library`. It includes moving the Z.ai provider to the shared library, adding ZenMux provider support, refactoring `ResearchMetadata` with type-specific details, implementing schema migration (v0→v1), adding a new `api` command, and renaming the `tool` field to `allowed_tools` in `SkillFrontmatter`.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Move Z.ai provider from research/lib to shared library | High | Rust Developer |
| FR-2 | Add ZenMux custom rig provider with bearer token auth | High | Rust Developer |
| FR-3 | Refactor ResearchMetadata to use ResearchDetails enum | High | Schema Architect |
| FR-4 | Add schema migration from v0 to v1 (auto-upgrade on read) | High | Rust Developer |
| FR-5 | Add `research api <name> [...prompt]` command | Medium | Rust Developer |
| FR-6 | Rename `tool` to `allowed_tools` in SkillFrontmatter | Medium | Rust Developer |
| FR-7 | Ensure `library` command works after refactoring | High | Feature Tester (Rust) |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Backward compatibility for existing metadata.json files | 100% seamless | Rust Developer |
| NFR-2 | No breaking changes to public API (except FR-6) | Minimal disruption | Rust Architect |
| NFR-3 | Comprehensive test coverage for migration | >90% branch coverage | Feature Tester (Rust) |

## Architecture Overview

### Current State

```
research/lib/src/
├── providers/
│   └── zai.rs           # Z.ai provider (TO BE MOVED)
├── lib.rs               # ResearchMetadata, ResearchKind (TO BE REFACTORED)
└── validation/
    └── frontmatter.rs   # SkillFrontmatter with `tool` field (TO BE RENAMED)

shared/src/providers/
├── base.rs              # Provider enum, PROVIDER_AUTH, PROVIDER_BASE_URLS
├── types.rs             # LlmEntry, discovery types
└── mod.rs               # Module exports
```

### Target State

```
research/lib/src/
├── providers/
│   └── mod.rs           # Re-export from shared (zai removed)
├── lib.rs               # ResearchMetadata with details: ResearchDetails
├── metadata/
│   ├── mod.rs           # Module entry
│   ├── types.rs         # ResearchDetails enum, detail structs
│   ├── migration.rs     # v0→v1 migration logic
│   └── v0.rs            # Legacy MetadataV0 struct for migration
└── validation/
    └── frontmatter.rs   # SkillFrontmatter with `allowed_tools` field

shared/src/providers/
├── base.rs              # Provider enum (unchanged)
├── zai.rs               # Z.ai rig provider (MOVED FROM research)
├── zenmux.rs            # ZenMux rig provider (NEW)
└── mod.rs               # Updated exports
```

### Data Flow

```
metadata.json (v0 or v1)
       │
       ▼
┌─────────────────────┐
│ ResearchMetadata::  │
│      load()         │
│ ┌─────────────────┐ │
│ │ Check schema_   │ │
│ │ version         │ │
│ └────────┬────────┘ │
│          │          │
│    v0    │    v1    │
│    ▼     │     │    │
│ ┌────────┴───┐ │    │
│ │ migrate_   │ │    │
│ │ v0_to_v1() │ │    │
│ └────────────┘ │    │
│          │     │    │
│          ▼     ▼    │
│   ResearchMetadata  │
│   (schema_version:1)│
└─────────────────────┘
       │
       ▼
   Save back to disk
   (auto-upgrade)
```

## Phases

### Phase 1: Move Z.ai Provider to Shared Library

**Principal Owner:** Rust Developer

**Goal:** Relocate Z.ai rig provider from research/lib to shared library for reuse

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib providers && cargo test -p research-lib`

**Files to Create:**
- `shared/src/providers/zai.rs` - Z.ai rig provider implementation (~108 lines)

**Files to Modify:**
- `shared/src/providers/mod.rs` - Add `pub mod zai;` export
- `shared/Cargo.toml` - Add rig dependency if not present

**Files to Delete:**
- `research/lib/src/providers/zai.rs` - Original implementation

**Files to Update (imports):**
- `research/lib/src/lib.rs` - Change `use crate::providers::zai` to `use shared::providers::zai`
- `research/lib/src/providers/mod.rs` - Remove `pub mod zai;` if present

**Technical Details:**
- Copy `research/lib/src/providers/zai.rs` (108 lines) to `shared/src/providers/zai.rs`
- Reconcile URL discrepancy: research uses `https://api.z.ai/api/paas/v4`, shared/base uses `https://api.zai.chat`
  - **Decision made**: Use the working URL from research (`https://api.z.ai/api/paas/v4`)
  - Update `PROVIDER_BASE_URLS` in `shared/src/providers/base.rs` line 134
- Ensure rig-core dependency is available in shared
- **Review feedback**: Refactor `ClientBuilder::build()` to return `Result<Client, ProviderError>` instead of using `expect()` - no panics in library code

**Acceptance Criteria:**
- [ ] File `shared/src/providers/zai.rs` exists with >100 lines
- [ ] `grep "pub mod zai" shared/src/providers/mod.rs` succeeds
- [ ] `grep "api.z.ai/api/paas/v4" shared/src/providers/base.rs` succeeds (URL updated)
- [ ] File `research/lib/src/providers/zai.rs` does NOT exist
- [ ] `cargo test -p shared --lib providers` passes
- [ ] `cargo test -p research-lib` passes
- [ ] `cargo build -p research-cli` succeeds

---

### Phase 2: Add ZenMux Custom Provider

**Principal Owner:** Rust Developer

**Goal:** Create ZenMux rig provider using existing metadata from shared/providers

**Dependencies:** Phase 1 (for provider pattern reference)

**Blast Radius:** `cargo test -p shared --lib providers`

**Files to Create:**
- `shared/src/providers/zenmux.rs` - ZenMux rig provider implementation (~100 lines)

**Files to Modify:**
- `shared/src/providers/mod.rs` - Add `pub mod zenmux;` export
- `shared/src/providers/base.rs` - Update `PROVIDER_AUTH` at line 106 from `None` to `BearerToken`

**Technical Details:**
- Model ZenMux provider after Z.ai implementation (OpenAI-compatible wrapper)
- Use constants from `PROVIDER_BASE_URLS[ZenMux]` = `"https://zenmux.ai/api"`
- Use env vars from `PROVIDER_ENV_VARIABLES[ZenMux]` = `["ZENMUX_API_KEY", "ZEN_MUX_API_KEY"]`
- Authentication: `BearerToken` (standard `Authorization: Bearer <key>` header)
- Include: `Client`, `ClientBuilder`, `from_env()`, `agent()` methods

**Structs to Create:**
```rust
// shared/src/providers/zenmux.rs
pub struct Client {
    inner: openai::CompletionsClient,
}

pub struct ClientBuilder {
    api_key: String,
    base_url: String,
}
```

**Acceptance Criteria:**
- [ ] File `shared/src/providers/zenmux.rs` exists with >80 lines
- [ ] `grep "pub mod zenmux" shared/src/providers/mod.rs` succeeds
- [ ] `grep "pub struct Client" shared/src/providers/zenmux.rs` succeeds
- [ ] `grep "BearerToken" shared/src/providers/base.rs | grep -i zenmux` shows ZenMux uses BearerToken
- [ ] `cargo test -p shared --lib providers` passes
- [ ] `cargo build -p shared` succeeds

---

### Phase 3: Refactor ResearchMetadata with ResearchDetails

**Principal Owner:** Schema Architect

**Goal:** Restructure ResearchMetadata to support type-specific details via ResearchDetails enum

**Dependencies:** None (can run in parallel with Phase 1 & 2)

**Blast Radius:** `cargo test -p research-lib`

**Files to Create:**
- `research/lib/src/metadata/mod.rs` - Module entry point (~20 lines)
- `research/lib/src/metadata/types.rs` - ResearchDetails enum and detail structs (~150 lines)
- `research/lib/src/metadata/v0.rs` - Legacy MetadataV0 struct for migration (~80 lines)

**Files to Modify:**
- `research/lib/src/lib.rs` - Update ResearchMetadata struct, add `pub mod metadata;`

**Technical Details:**

**ResearchDetails enum** (in `metadata/types.rs`):
```rust
#[non_exhaustive]  // Signal that this enum will grow over time (per review)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ResearchDetails {
    Library(LibraryDetails),
    SolutionSpace(SolutionSpaceDetails),
    Cli(CliDetails),
    App(AppDetails),
    CloudProvider(CloudProviderDetails),
    Standard(StandardDetails),
    Api(ApiDetails),
    Person(PersonDetails),
    People(PeopleDetails),
    Place(PlaceDetails),
    Product(ProductDetails),
    Company(CompanyDetails),
    CompanyCategory(CompanyCategoryDetails),
    News(NewsDetails),
    SkillSet(SkillSetDetails),
}

// All detail structs start as unit-like structs with no fields
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct LibraryDetails {
    // Existing library_info fields will be moved here during migration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub package_manager: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ApiDetails {}  // Empty struct (not unit-like) for proper JSON serialization

// ... other detail structs as empty defaults with {} not ;
```

**Important Note from Review:** Use empty structs with braces (`{}`) not unit-like structs (`;`) because:
- Unit structs serialize as `null` in JSON
- Empty braced structs serialize as `{}` which is more extensible
- Both require `Default` derive differently

**Updated ResearchMetadata** (in `lib.rs`):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResearchMetadata {
    #[serde(default = "default_schema_version")]
    pub schema_version: u32,
    pub kind: ResearchKind,
    pub details: ResearchDetails,  // NEW
    // library_info REMOVED (moved to LibraryDetails)
    #[serde(default)]
    pub additional_files: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub brief: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub when_to_use: Option<String>,
}

fn default_schema_version() -> u32 { 1 }
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/metadata/mod.rs` exists
- [ ] File `research/lib/src/metadata/types.rs` exists with >100 lines
- [ ] `grep "pub enum ResearchDetails" research/lib/src/metadata/types.rs` succeeds
- [ ] `grep "Library(LibraryDetails)" research/lib/src/metadata/types.rs` succeeds
- [ ] `grep "Api(ApiDetails)" research/lib/src/metadata/types.rs` succeeds
- [ ] `grep "pub details: ResearchDetails" research/lib/src/lib.rs` succeeds
- [ ] ResearchMetadata no longer has `library_info` field directly
- [ ] `cargo build -p research-lib` succeeds

---

### Phase 4: Implement Schema Migration (v0 → v1)

**Principal Owner:** Rust Developer

**Goal:** Auto-upgrade existing metadata.json files from v0 to v1 format on read

**Dependencies:** Phase 3 (ResearchDetails enum must exist)

**Blast Radius:** `cargo test -p research-lib`

**Files to Create:**
- `research/lib/src/metadata/migration.rs` - Migration logic (~120 lines)

**Files to Modify:**
- `research/lib/src/metadata/mod.rs` - Add `pub mod migration;`
- `research/lib/src/lib.rs` - Update `ResearchMetadata::load()` to use migration

**Technical Details:**

**MetadataV0 struct** (in `metadata/v0.rs`):
```rust
/// Legacy metadata format (schema_version: 0 or missing)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataV0 {
    #[serde(default)]
    pub schema_version: u32,
    pub kind: ResearchKind,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub library_info: Option<LibraryInfoMetadata>,
    #[serde(default)]
    pub additional_files: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub brief: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub when_to_use: Option<String>,
}
```

**Migration function** (in `metadata/migration.rs`):
```rust
pub fn migrate_v0_to_v1(v0: MetadataV0) -> ResearchMetadata {
    let details = match v0.kind {
        ResearchKind::Library => {
            let lib_details = v0.library_info.map(|info| LibraryDetails {
                package_manager: Some(info.package_manager),
                language: Some(info.language),
                url: Some(info.url),
                repository: info.repository,
            }).unwrap_or_default();
            ResearchDetails::Library(lib_details)
        }
        // Future kinds will have their own migration logic
    };

    ResearchMetadata {
        schema_version: 1,
        kind: v0.kind,
        details,
        additional_files: v0.additional_files,
        created_at: v0.created_at,
        updated_at: Utc::now(), // Updated due to migration
        brief: v0.brief,
        summary: v0.summary,
        when_to_use: v0.when_to_use,
    }
}
```

**Updated load() method** (with backup per review):
```rust
pub async fn load(output_dir: &Path) -> Option<Self> {
    let path = output_dir.join("metadata.json");
    let content = fs::read_to_string(&path).await.ok()?;

    // First try to parse as Value to check schema version
    let value: serde_json::Value = serde_json::from_str(&content).ok()?;
    let version = value.get("schema_version")
        .and_then(|v| v.as_u64())
        .unwrap_or(0) as u32;

    if version == 0 {
        // Parse as v0 and migrate
        let v0: MetadataV0 = serde_json::from_str(&content).ok()?;
        let v1 = migrate_v0_to_v1(v0);

        // Create backup before overwriting (per review recommendation)
        let backup_path = output_dir.join("metadata.v0.json.backup");
        if let Err(e) = fs::copy(&path, &backup_path).await {
            tracing::warn!("Failed to create v0 backup: {}", e);
        }

        // Auto-save the upgraded version
        if let Err(e) = v1.save(output_dir).await {
            tracing::warn!("Failed to save migrated metadata: {}", e);
        }
        Some(v1)
    } else {
        serde_json::from_str(&content).ok()
    }
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/metadata/migration.rs` exists with >80 lines
- [ ] `grep "pub fn migrate_v0_to_v1" research/lib/src/metadata/migration.rs` succeeds
- [ ] `grep "schema_version: 1" research/lib/src/metadata/migration.rs` succeeds
- [ ] `grep "MigrationError" research/lib/src/metadata/migration.rs` succeeds
- [ ] `cargo test -p research-lib migrate` runs 8+ tests covering: happy path, missing schema_version, null library_info, malformed JSON, auto-save verification, timestamp handling, idempotency, and backup creation
- [ ] Loading a v0 metadata.json produces a v1 ResearchMetadata
- [ ] Loading a v0 metadata.json creates `metadata.v0.json.backup` before saving
- [ ] Loading a v0 metadata.json auto-saves the migrated version
- [ ] `cargo test -p research-lib` passes all existing tests

---

### Phase 5: Rename `tool` to `allowed_tools` in SkillFrontmatter

**Principal Owner:** Rust Developer

**Goal:** Rename the `tool` field to `allowed_tools` (breaking change, no deprecation)

**Dependencies:** None (can run in parallel with Phases 1-4)

**Blast Radius:** `cargo test -p research-lib --lib validation && grep -r "tools:" .claude/skills/`

**Files to Modify:**
- `research/lib/src/validation/frontmatter.rs` - Rename field from `tools` to `allowed_tools`

**Files to Search & Update:**
- Documentation files mentioning `tool:` or `tools:` property
- Skill files using the old property name

**Technical Details:**

**Current** (line 50-52 of frontmatter.rs):
```rust
#[serde(alias = "allowed-tools", skip_serializing_if = "Option::is_none")]
pub tools: Option<Vec<String>>,
```

**New**:
```rust
/// Optional list of tools the skill is allowed to use
#[serde(alias = "tools", skip_serializing_if = "Option::is_none")]
pub allowed_tools: Option<Vec<String>>,
```

**Note:** Keep `alias = "tools"` for backward compatibility during transition (can be removed later).

**Code Updates Required:**
- Any code accessing `.tools` must change to `.allowed_tools`
- Test files referencing `tools:` can stay (alias handles it)

**Acceptance Criteria:**
- [ ] `grep "pub allowed_tools:" research/lib/src/validation/frontmatter.rs` succeeds
- [ ] `grep 'alias = "tools"' research/lib/src/validation/frontmatter.rs` succeeds (backward compat)
- [ ] `cargo test -p research-lib --lib validation` passes
- [ ] Skill files with `tools:` still parse correctly (alias)
- [ ] Skill files with `allowed_tools:` parse correctly (new name)
- [ ] Serialization test: `serde_yaml::to_string()` produces `allowed_tools:` (not `tools:`)

---

### Phase 6: Add `research api` Command

**Principal Owner:** Rust Developer

**Goal:** Add new CLI command for API research (`research api <api-name> [...prompt]`)

**Dependencies:** Phase 3 & 4 (ResearchDetails::Api must exist)

**Blast Radius:** `cargo test -p research-cli && cargo test -p research-lib`

**Files to Modify:**
- `research/cli/src/main.rs` - Add `Api` subcommand to Commands enum
- `research/lib/src/lib.rs` - Add `research_api()` function or extend `research()`

**Technical Details:**

**CLI Addition** (in `main.rs`):
```rust
#[derive(Subcommand)]
enum Commands {
    // ... existing commands

    /// Research a public API
    Api {
        /// The API name (e.g., "stripe", "github", "openai")
        #[arg(required = true)]
        api_name: String,

        /// Additional research questions
        #[arg(trailing_var_arg = true)]
        questions: Vec<String>,

        /// Output directory (defaults to $RESEARCH_DIR/.research/api/<api-name>)
        #[arg(short, long)]
        output: Option<PathBuf>,

        /// Force recreation even if research exists
        #[arg(short, long)]
        force: bool,
    },
}
```

**ResearchKind Extension:**
- Add `Api` variant to `ResearchKind` enum in `research/lib/src/lib.rs` (line 270):
  ```rust
  pub enum ResearchKind {
      Library,
      Api,  // NEW
      // Future: Software, Standard, Company, etc.
  }
  ```

**Research Function:**
- Structure similar to `research()` for libraries
- Use `ResearchKind::Api`
- Initialize `ResearchDetails::Api(ApiDetails::default())`
- Add `new_api()` constructor method similar to `new_library()`
- Phase 1 prompts adapted for API research:
  - Overview: API purpose, endpoints, authentication
  - Similar APIs: Alternatives in the space
  - Integration: Common use cases, SDKs
  - Changelog: API versioning history

**Acceptance Criteria:**
- [ ] `research api --help` shows usage
- [ ] `grep "Api {" research/cli/src/main.rs` succeeds
- [ ] `grep "ResearchKind::Api" research/lib/src/lib.rs` succeeds
- [ ] `cargo build -p research-cli` succeeds
- [ ] Running `research api test-api` creates output in `.research/api/test-api/`

---

### Phase 7: Integration Testing & Validation

**Principal Owner:** Feature Tester (Rust)

**Goal:** Ensure all changes work together and existing functionality is preserved

**Dependencies:** Phases 1-6 complete

**Blast Radius:** `cargo test` (full test suite)

**Tests to Add/Verify:**

1. **Provider Tests** (shared):
   - Z.ai client creation from env
   - ZenMux client creation from env
   - Provider URL constants are correct

2. **Migration Tests** (research-lib):
   - v0 → v1 migration preserves all data
   - v0 file is auto-upgraded on read
   - v1 files load without migration
   - Missing schema_version treated as v0

3. **ResearchDetails Tests** (research-lib):
   - All variants serialize/deserialize correctly
   - LibraryDetails from existing library_info
   - ApiDetails defaults correctly

4. **CLI Tests** (research-cli):
   - `library` command still works
   - `api` command accepts arguments
   - Help text is correct

5. **Frontmatter Tests** (research-lib):
   - `allowed_tools` field works
   - `tools` alias still works
   - Serialization uses `allowed_tools`

**Acceptance Criteria:**
- [ ] `cargo test -p shared` passes (10+ provider tests)
- [ ] `cargo test -p research-lib` passes (all existing + 15+ new tests)
- [ ] `cargo test -p research-cli` passes
- [ ] `cargo build --workspace` succeeds
- [ ] Manual test: `research library clap` produces valid output
- [ ] Manual test: existing metadata.json files are migrated on read

---

## Blast Radius Analysis

| Phase | Change Type | Blast Radius Command |
|-------|-------------|---------------------|
| 1 | Provider relocation | `cargo test -p shared --lib providers && cargo test -p research-lib` |
| 2 | New provider | `cargo test -p shared --lib providers` |
| 3 | Type refactoring | `cargo test -p research-lib` |
| 4 | Migration logic | `cargo test -p research-lib` |
| 5 | Field rename | `cargo test -p research-lib --lib validation` |
| 6 | New CLI command | `cargo test -p research-cli && cargo test -p research-lib` |
| 7 | Integration | `cargo test` (full suite) |

---

## Cross-Cutting Concerns

### Testing Strategy
- Unit tests in `#[cfg(test)] mod tests` blocks for each new module
- Integration tests in `tests/` for migration and CLI
- Test fixtures: Create v0 metadata.json samples for migration testing
- All tests use `#[tokio::test]` for async functions

### Error Handling
- Use `thiserror` for new error types (MigrationError, ProviderError)
- Preserve error context with `#[source]` attribute
- Migration failures should warn but not fail (graceful degradation)

**MigrationError Definition** (add to `metadata/migration.rs`):
```rust
#[derive(Debug, Error)]
pub enum MigrationError {
    #[error("Failed to read metadata: {0}")]
    Read(#[from] std::io::Error),

    #[error("Failed to parse v0 metadata: {0}")]
    ParseV0(#[source] serde_json::Error),

    #[error("Failed to save migrated metadata: {0}")]
    Save(#[source] std::io::Error),

    #[error("Unknown schema version: {version}")]
    UnknownVersion { version: u32 },
}
```

### Security Considerations
- API keys read from environment only
- No hardcoded credentials in provider implementations

### Performance Considerations
- Migration runs once per metadata.json (auto-save prevents re-migration)
- Provider clients are lightweight wrappers (no connection pooling needed)

---

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | 1, 2, 5 | Independent: providers and frontmatter are separate concerns |
| Group B | 3 | Can run with Group A: schema work is independent |
| Group C | 4 | Depends on Phase 3 (needs ResearchDetails enum) |
| Group D | 6 | Depends on Phases 3 & 4 (needs Api kind and migration) |
| Group E | 7 | Depends on all phases |

### Parallelization Diagram

```
Timeline:
──────────────────────────────────────────────────────────►

Group A: ██████████████ (Phase 1 + Phase 2 + Phase 5 in parallel)
Group B: ██████████████ (Phase 3 in parallel with Group A)
                      │
                      └─── Sync Point: Types ready
                              │
Group C:                      ████████ (Phase 4: Migration)
                                     │
Group D:                             ████████ (Phase 6: API command)
                                            │
Group E:                                    ████████ (Phase 7: Integration)
```

### Synchronization Points

1. **After Group A+B:** Core types and providers must be finalized
2. **After Group C:** Migration logic must be complete before new command
3. **After Group D:** All features complete before integration testing

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| URL discrepancy breaks Z.ai | High | Use known-working URL from research module |
| Migration corrupts data | High | Test with fixtures; keep original v0 backup logic |
| Breaking change in SkillFrontmatter | Medium | Keep `tools` as alias for transition |
| ZenMux API undocumented | Medium | Start with minimal OpenAI-compatible impl |
| Test coverage gaps | Medium | Phase 7 dedicated to testing |

---

## Open Questions

- [x] Z.ai URL: Use `https://api.z.ai/api/paas/v4` (confirmed working in research)
- [x] ZenMux: Does it support all OpenAI-compatible endpoints? (verify during Phase 2)
- [x] Migration: Should we backup original metadata.json before overwriting? **Decision: YES** - Create `metadata.v0.json.backup` before first migration for recovery
- [ ] API research: What prompts are most useful for API documentation? (to be designed in Phase 6)

---

## Review Summary

**Reviews Completed:** 2026-01-04

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

### Key Changes from Review

1. **Use empty braced structs** (`{}`) instead of unit-like structs (`;`) for detail types to ensure proper JSON serialization
2. **Add MigrationError type** with proper thiserror variants (Read, ParseV0, Save, UnknownVersion)
3. **Remove `expect()` usage** in Z.ai client - refactor `ClientBuilder::build()` to return `Result`
4. **Add backup before migration** - create `metadata.v0.json.backup` before auto-save
5. **Add `ResearchKind::Api` variant** to the enum in Phase 6 (must extend `ResearchKind`)
6. **Add `#[non_exhaustive]` to ResearchDetails** - signal that enum will grow over time
7. **Consider deriving `kind` from `details`** - add validation or derive method to prevent inconsistency

### Resolved Concerns

| Concern | Resolution |
|---------|------------|
| URL discrepancy for Z.ai | Use working `https://api.z.ai/api/paas/v4`, update `PROVIDER_BASE_URLS` |
| Auto-save silent failure | Log warning, continue with in-memory v1 data; add backup first |
| Empty struct serialization | Use `{}` not `;` for proper JSON output |
| ZenMux auth mismatch | Update `PROVIDER_AUTH` from `None` to `BearerToken` |
| `expect()` in provider code | Refactor to `Result` return type |

### Additional Test Scenarios from Review

**Migration Tests (Phase 4):**
- v0 with `library_info: null` (explicit null) → `LibraryDetails::default()`
- v0 with malformed timestamp → graceful failure
- Preserve original `created_at`, only update `updated_at`
- Idempotency: multiple migrations produce same result

**Provider Tests (Phases 1 & 2):**
- Use `#[serial_test::serial]` for env var tests
- Test 401, 429, 500 error handling distinctly

**Serialization Tests (Phase 3):**
- Round-trip JSON → ResearchDetails → JSON
- Verify `"type": "Library"` tag appears in output
- Verify empty `ApiDetails {}` serializes correctly

**Frontmatter Tests (Phase 5):**
- Verify serialization produces `allowed_tools:` (not `tools:`)
- Test both alias parsing still works

**CLI Tests (Phase 6):**
- `research api stripe` - parses correctly
- `research api stripe "auth flow"` - captures questions
- `research api` without name → shows error

### Test Fixtures to Create

Add these fixture files for migration testing:
- `research/lib/tests/fixtures/metadata_v0_complete.json`
- `research/lib/tests/fixtures/metadata_v0_minimal.json`
- `research/lib/tests/fixtures/metadata_v0_missing_schema.json`
- `research/lib/tests/fixtures/metadata_v0_null_library_info.json`
