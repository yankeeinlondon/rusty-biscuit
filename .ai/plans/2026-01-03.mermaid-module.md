# Mermaid Module Implementation Plan

**Created:** 2026-01-03
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2026-01-03

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. Fixed Phase 1/2 parallelization - they are sequential (Phase 2 depends on Phase 1)
2. Added `MermaidHtml` return type struct instead of bare tuple for `render_for_html()`
3. Added URL length validation (2KB limit for mermaid.ink)
4. Added `tempfile::NamedTempFile` for RAII-based temp file cleanup
5. Upgraded hash from XXH32 to XXH64 to reduce collision probability
6. Added explicit test specifications for each phase
7. Added test fixtures directory structure
8. Added tracing instrumentation requirements
9. Removed cached `hash` field from struct - compute on demand
10. Removed unnecessary `html_header` field from struct
11. Added snapshot testing with insta for HTML output
12. Added explicit `From<String>` and `From<&str>` implementations instead of generic

**Resolved Concerns:**
- resvg API usage → Corrected to include `usvg::FitTo::Original` parameter
- Theme storage optimization → Store `ThemePair` enum, resolve lazily
- Async runtime in md CLI → Verified tokio runtime needed, added to deliverables
- Color validation → Deferred to Phase 1 with `CssColor` newtype (optional, can be String initially)

---

## Executive Summary

Implement a `mermaid` module in the shared library that enables rendering Mermaid diagrams for both HTML output (client-side JS) and terminal output (via mermaid.ink service + resvg). The module provides theme support with light/dark mode switching, hash-based caching, and accessibility features.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Create `Mermaid` struct that holds diagram instructions, themes, title/footer | High | Rust Developer |
| FR-2 | Create `MermaidTheme` struct with named color properties | High | Schema Architect |
| FR-3 | Implement `From<String>` and `From<&str>` traits for `Mermaid` | High | Rust Developer |
| FR-4 | Implement `Default` trait with simple flowchart example | Medium | Rust Developer |
| FR-5 | Builder pattern: `with_theme()`, `with_title()`, `with_footer()`, `use_syntect_theme()` | High | Rust Developer |
| FR-6 | Implement `render_for_html()` returning `MermaidHtml` struct | High | Rust Developer |
| FR-7 | Implement `render_for_terminal()` using mermaid.ink + resvg pipeline | High | Rust Developer |
| FR-8 | Content hashing using XXH64 for cache keys (blank lines stripped) | Medium | Rust Developer |
| FR-9 | Implement `TryFrom<String/&str/Value>` for `MermaidTheme` to parse JSON | Medium | Schema Architect |
| FR-10 | Statically define default themes in `lazy_static!` block | High | Rust Developer |
| FR-11 | Add `--mermaid` CLI switch to `md` binary for terminal rendering | Medium | Rust Developer |
| FR-12 | Auto-render mermaid diagrams in HTML output (`--html`/`--show-html`) | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Hash computation < 1ms for typical diagrams | < 1ms | Rust Developer |
| NFR-2 | Terminal rendering fallback if mermaid.ink unavailable | Graceful degradation | Rust Developer |
| NFR-3 | All public APIs documented with rustdoc examples | 100% coverage | Rust Developer |
| NFR-4 | CSS variables for theme customization in HTML output | Core colors abstracted | Rust Developer |
| NFR-5 | Accessibility: ARIA attributes, alt text, high contrast support | WCAG 2.1 AA | Rust Developer |
| NFR-6 | Minimum 4.5:1 contrast ratio for NEUTRAL_THEME | WCAG 2.1 AA | Schema Architect |
| NFR-7 | URL length validation (<2KB) before mermaid.ink requests | Prevent silent failures | Rust Developer |
| NFR-8 | Tracing instrumentation for all public methods | Observability | Rust Developer |

## Architecture Overview

The mermaid module integrates with existing infrastructure:

```
shared/
├── src/
│   ├── lib.rs                    # Add: pub mod mermaid;
│   └── mermaid/
│       ├── mod.rs                # Main Mermaid struct and traits
│       ├── theme.rs              # MermaidTheme struct and static themes
│       ├── render_html.rs        # HTML rendering with CSS variables
│       ├── render_terminal.rs    # Terminal rendering via mermaid.ink + resvg
│       └── hash.rs               # XXH64 hashing utilities
├── tests/
│   └── fixtures/
│       └── mermaid/
│           ├── valid/            # Valid diagram fixtures
│           └── invalid/          # Edge case fixtures
```

### Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      Mermaid Module                         │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │   Mermaid    │  │ MermaidTheme │  │   Static Themes  │  │
│  │    struct    │  │    struct    │  │   (lazy_static)  │  │
│  └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘  │
│         │                 │                    │            │
│  ┌──────▼─────────────────▼────────────────────▼──────┐    │
│  │            render_for_html() -> MermaidHtml         │    │
│  │  - Produces <script> tag with mermaid.js            │    │
│  │  - Produces CSS variables for theme switching       │    │
│  │  - Returns MermaidHtml { head, body }               │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                 render_for_terminal()               │    │
│  │  - Validate URL length (<2KB)                       │    │
│  │  - Base64 encode instructions                       │    │
│  │  - Fetch SVG from mermaid.ink                       │    │
│  │  - Convert SVG to PNG via resvg                     │    │
│  │  - Display with viuer (tempfile::NamedTempFile)     │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                     hash.rs                          │    │
│  │  - Strip blank lines from instructions               │    │
│  │  - Compute XXH64 hash for cache key                  │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow

1. **Mermaid instructions** → `Mermaid::from()` → struct with theme pair enum
2. **Hash computation**: instructions → strip blanks → XXH64 → u64 cache key (computed on demand)
3. **HTML rendering**: Mermaid → MermaidHtml { head: JS + CSS vars, body: diagram div }
4. **Terminal rendering**: Mermaid → validate length → base64 → mermaid.ink → SVG → resvg PNG → viuer

## Phases

### Phase 1: Core Type Definitions

**Principal Owner:** Schema Architect

**Goal:** Define the `MermaidTheme` struct with all color properties and implement JSON parsing.

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib mermaid::theme`

**Files to create:**
- `shared/src/mermaid/mod.rs` - Module entry point, re-exports
- `shared/src/mermaid/theme.rs` - `MermaidTheme` struct, `TryFrom` implementations

**Deliverables:**
- `MermaidTheme` struct with all 40+ Mermaid theme variables from mermaid-theming.md
- `TryFrom<String>`, `TryFrom<&str>`, `TryFrom<serde_json::Value>` implementations
- Error type `MermaidThemeError` using thiserror
- Unit tests for JSON parsing

**Technical Details:**

```rust
// shared/src/mermaid/theme.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MermaidThemeError {
    #[error("Invalid JSON: {0}")]
    InvalidJson(#[from] serde_json::Error),
    #[error("Invalid color value for '{field}': {value}")]
    InvalidColor { field: String, value: String },
}

/// A Mermaid theme configuration.
///
/// All color values should be valid CSS color strings (hex, rgb, hsl, named colors).
///
/// ## Examples
///
/// ```
/// use shared::mermaid::MermaidTheme;
/// use std::convert::TryFrom;
///
/// let json = r#"{"background": "#ffffff", "primaryColor": "#fff4dd"}"#;
/// let theme = MermaidTheme::try_from(json).unwrap();
/// assert_eq!(theme.background, "#ffffff");
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MermaidTheme {
    // General Theme Variables
    #[serde(default = "default_background")]
    pub background: String,
    #[serde(default = "default_primary_color")]
    pub primary_color: String,
    #[serde(default)]
    pub primary_text_color: Option<String>,
    #[serde(default)]
    pub primary_border_color: Option<String>,
    #[serde(default)]
    pub secondary_color: Option<String>,
    #[serde(default)]
    pub secondary_text_color: Option<String>,
    #[serde(default)]
    pub secondary_border_color: Option<String>,
    #[serde(default)]
    pub tertiary_color: Option<String>,
    #[serde(default)]
    pub tertiary_text_color: Option<String>,
    #[serde(default)]
    pub tertiary_border_color: Option<String>,
    #[serde(default)]
    pub note_bkg_color: Option<String>,
    #[serde(default)]
    pub note_text_color: Option<String>,
    #[serde(default)]
    pub note_border_color: Option<String>,
    #[serde(default)]
    pub line_color: Option<String>,
    #[serde(default)]
    pub text_color: Option<String>,
    #[serde(default)]
    pub main_bkg: Option<String>,
    #[serde(default)]
    pub font_family: Option<String>,
    #[serde(default)]
    pub font_size: Option<String>,

    // Flowchart-Specific Variables
    #[serde(default)]
    pub node_border: Option<String>,
    #[serde(default)]
    pub cluster_bkg: Option<String>,
    #[serde(default)]
    pub cluster_border: Option<String>,
    #[serde(default)]
    pub default_link_color: Option<String>,
    #[serde(default)]
    pub title_color: Option<String>,
    #[serde(default)]
    pub edge_label_background: Option<String>,
    #[serde(default)]
    pub node_text_color: Option<String>,

    // Sequence Diagram Variables
    #[serde(default)]
    pub actor_bkg: Option<String>,
    #[serde(default)]
    pub actor_border: Option<String>,
    #[serde(default)]
    pub actor_text_color: Option<String>,
    #[serde(default)]
    pub actor_line_color: Option<String>,
    #[serde(default)]
    pub signal_color: Option<String>,
    #[serde(default)]
    pub signal_text_color: Option<String>,
    #[serde(default)]
    pub label_box_bkg_color: Option<String>,
    #[serde(default)]
    pub label_box_border_color: Option<String>,
    #[serde(default)]
    pub label_text_color: Option<String>,
    #[serde(default)]
    pub loop_text_color: Option<String>,
    #[serde(default)]
    pub activation_border_color: Option<String>,
    #[serde(default)]
    pub activation_bkg_color: Option<String>,
    #[serde(default)]
    pub sequence_number_color: Option<String>,
}

fn default_background() -> String { "#f4f4f4".into() }
fn default_primary_color() -> String { "#fff4dd".into() }
```

**Unit Tests (Phase 1):**
- `test_theme_from_valid_json()` - parses complete theme
- `test_theme_from_partial_json()` - handles optional fields with defaults
- `test_theme_from_empty_json()` - uses all defaults
- `test_theme_invalid_json_syntax()` - returns MermaidThemeError::InvalidJson
- `test_theme_try_from_string()` - TryFrom<String> works
- `test_theme_try_from_str()` - TryFrom<&str> works
- `test_theme_try_from_value()` - TryFrom<serde_json::Value> works

**Acceptance Criteria:**
- [ ] File `shared/src/mermaid/mod.rs` exists with >20 lines
- [ ] File `shared/src/mermaid/theme.rs` exists with >200 lines
- [ ] `grep "pub struct MermaidTheme" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "impl TryFrom<String>" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "impl TryFrom<&str>" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "impl TryFrom<serde_json::Value>" shared/src/mermaid/theme.rs` succeeds
- [ ] Count of `pub` fields in `MermaidTheme` is >= 30
- [ ] `cargo test -p shared --lib mermaid::theme` runs 7+ tests
- [ ] All tests pass

---

### Phase 2: Static Theme Definitions

**Principal Owner:** Rust Developer

**Goal:** Define default light/dark theme pairs in a `lazy_static!` block and integrate with existing `ThemePair` infrastructure.

**Dependencies:** Phase 1 (requires MermaidTheme struct)

**Blast Radius:** `cargo test -p shared --lib mermaid`

**Files to modify:**
- `shared/src/mermaid/theme.rs` - Add `lazy_static!` block with default themes
- `shared/src/mermaid/mod.rs` - Re-export theme constants

**Dependencies to add:**
- None (already have `lazy_static = "1.5.0"` in Cargo.toml)

**Deliverables:**
- `DEFAULT_LIGHT_THEME: MermaidTheme` - optimized for light backgrounds
- `DEFAULT_DARK_THEME: MermaidTheme` - optimized for dark backgrounds
- `NEUTRAL_THEME: MermaidTheme` - high contrast for accessibility (4.5:1+)
- Function `mermaid_theme_for_syntect(theme_pair: ThemePair, mode: ColorMode) -> &'static MermaidTheme`

**Technical Details:**

```rust
// In shared/src/mermaid/theme.rs

use lazy_static::lazy_static;
use crate::markdown::highlighting::{ThemePair, ColorMode};

lazy_static! {
    /// Default light theme matching common documentation sites
    pub static ref DEFAULT_LIGHT_THEME: MermaidTheme = MermaidTheme {
        background: "#ffffff".into(),
        primary_color: "#fff4dd".into(),
        primary_text_color: Some("#333333".into()),
        primary_border_color: Some("#666666".into()),
        secondary_color: Some("#e8f5e9".into()),
        tertiary_color: Some("#e3f2fd".into()),
        line_color: Some("#333333".into()),
        text_color: Some("#333333".into()),
        ..Default::default()
    };

    /// Default dark theme for dark mode interfaces
    pub static ref DEFAULT_DARK_THEME: MermaidTheme = MermaidTheme {
        background: "#1a1a2e".into(),
        primary_color: "#4a5568".into(),
        primary_text_color: Some("#e2e8f0".into()),
        primary_border_color: Some("#718096".into()),
        line_color: Some("#a0aec0".into()),
        text_color: Some("#e2e8f0".into()),
        ..Default::default()
    };

    /// High contrast neutral theme for accessibility (WCAG 2.1 AA)
    /// Ensures minimum 4.5:1 contrast ratio for text/background
    pub static ref NEUTRAL_THEME: MermaidTheme = MermaidTheme {
        background: "#ffffff".into(),
        primary_color: "#ffffff".into(),
        primary_text_color: Some("#000000".into()),
        primary_border_color: Some("#000000".into()),
        line_color: Some("#000000".into()),
        text_color: Some("#000000".into()),
        ..Default::default()
    };
}

/// Returns the appropriate MermaidTheme for a syntect ThemePair.
///
/// ## Examples
///
/// ```
/// use shared::mermaid::mermaid_theme_for_syntect;
/// use shared::markdown::highlighting::{ThemePair, ColorMode};
///
/// let theme = mermaid_theme_for_syntect(ThemePair::Github, ColorMode::Dark);
/// assert!(theme.background.starts_with("#"));
/// ```
pub fn mermaid_theme_for_syntect(theme_pair: ThemePair, mode: ColorMode) -> &'static MermaidTheme {
    // Future: Map specific ThemePairs to custom Mermaid themes
    match mode {
        ColorMode::Light => &*DEFAULT_LIGHT_THEME,
        ColorMode::Dark => &*DEFAULT_DARK_THEME,
    }
}
```

**Unit Tests (Phase 2):**
- `test_default_light_theme_has_required_fields()` - all fields populated
- `test_default_dark_theme_has_required_fields()` - all fields populated
- `test_neutral_theme_high_contrast()` - text is black on white
- `test_theme_for_syntect_light_mode()` - returns DEFAULT_LIGHT_THEME
- `test_theme_for_syntect_dark_mode()` - returns DEFAULT_DARK_THEME
- `test_static_themes_serialize_to_json()` - serde serialization works

**Acceptance Criteria:**
- [ ] `grep "lazy_static!" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "DEFAULT_LIGHT_THEME" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "DEFAULT_DARK_THEME" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "NEUTRAL_THEME" shared/src/mermaid/theme.rs` succeeds
- [ ] `grep "fn mermaid_theme_for_syntect" shared/src/mermaid/theme.rs` succeeds
- [ ] `cargo test -p shared --lib mermaid::theme` runs 13+ tests (Phase 1 + Phase 2)
- [ ] All tests pass

---

### Phase 3: Mermaid Struct and Builder Pattern

**Principal Owner:** Rust Developer

**Goal:** Create the main `Mermaid` struct with builder pattern and trait implementations.

**Dependencies:** Phase 1, Phase 2

**Blast Radius:** `cargo test -p shared --lib mermaid`

**Files to create/modify:**
- `shared/src/mermaid/mod.rs` - Main `Mermaid` struct and implementations
- `shared/src/mermaid/hash.rs` - XXH64 hashing utility

**Dependencies to add:**
- Add `xxhash-rust = { version = "0.8", features = ["xxh64"] }` to `shared/Cargo.toml`

**Deliverables:**
- `Mermaid` struct (without cached hash - compute on demand)
- `From<String>` and `From<&str>` implementations (NOT generic)
- `Default` implementation with simple flowchart
- Builder methods: `with_theme()`, `with_title()`, `with_footer()`, `use_syntect_theme()`
- `hash()` method returning XXH64 of normalized instructions
- `#[derive(Debug, Clone)]` for usability

**Technical Details:**

```rust
// shared/src/mermaid/mod.rs

mod hash;
mod theme;

pub use theme::{
    MermaidTheme, MermaidThemeError,
    DEFAULT_LIGHT_THEME, DEFAULT_DARK_THEME, NEUTRAL_THEME,
    mermaid_theme_for_syntect,
};

use crate::markdown::highlighting::{ThemePair, ColorMode};

/// A Mermaid diagram with theming support.
///
/// ## Examples
///
/// ```
/// use shared::mermaid::Mermaid;
///
/// let diagram = Mermaid::new("flowchart LR\n    A --> B")
///     .with_title("My Diagram");
///
/// assert_eq!(diagram.alt_text(), "My Diagram");
/// ```
#[derive(Debug, Clone)]
pub struct Mermaid {
    /// The Mermaid diagram instructions
    instructions: String,
    /// Theme pair enum for lazy resolution
    theme_pair: ThemePair,
    /// Custom themes override (if set, ignores theme_pair)
    custom_theme: Option<(MermaidTheme, MermaidTheme)>,
    /// Optional diagram title
    title: Option<String>,
    /// Optional diagram footer
    footer: Option<String>,
}

impl Mermaid {
    /// Creates a new Mermaid diagram with the given instructions.
    ///
    /// Uses the default theme pair (OneHalf) for light/dark mode.
    #[tracing::instrument(skip(instructions), fields(instructions_len = %instructions.as_ref().len()))]
    pub fn new<S: Into<String>>(instructions: S) -> Self {
        Self {
            instructions: instructions.into(),
            theme_pair: ThemePair::OneHalf,
            custom_theme: None,
            title: None,
            footer: None,
        }
    }

    /// Sets custom themes for light and dark modes.
    pub fn with_theme(mut self, light: MermaidTheme, dark: MermaidTheme) -> Self {
        self.custom_theme = Some((light, dark));
        self
    }

    /// Sets the diagram title (also used for alt text).
    pub fn with_title<S: Into<String>>(mut self, title: S) -> Self {
        self.title = Some(title.into());
        self
    }

    /// Sets the diagram footer.
    pub fn with_footer<S: Into<String>>(mut self, footer: S) -> Self {
        self.footer = Some(footer.into());
        self
    }

    /// Uses a syntect ThemePair for theme resolution.
    pub fn use_syntect_theme(mut self, theme_pair: ThemePair) -> Self {
        self.theme_pair = theme_pair;
        self.custom_theme = None; // Clear custom theme
        self
    }

    /// Returns the XXH64 hash of the normalized instructions.
    ///
    /// Hash is computed on demand (not cached) for simplicity.
    pub fn hash(&self) -> u64 {
        hash::compute_hash(&self.instructions)
    }

    /// Returns the raw instructions.
    pub fn instructions(&self) -> &str {
        &self.instructions
    }

    /// Returns the theme for the given color mode.
    pub fn theme(&self, mode: ColorMode) -> &MermaidTheme {
        if let Some((ref light, ref dark)) = self.custom_theme {
            match mode {
                ColorMode::Light => light,
                ColorMode::Dark => dark,
            }
        } else {
            mermaid_theme_for_syntect(self.theme_pair, mode)
        }
    }
}

impl Default for Mermaid {
    fn default() -> Self {
        Self::new(r#"flowchart LR
    A[Start] --> B{Decision}
    B -->|Yes| C[Action]
    B -->|No| D[End]"#)
    }
}

impl From<String> for Mermaid {
    fn from(instructions: String) -> Self {
        Self::new(instructions)
    }
}

impl From<&str> for Mermaid {
    fn from(instructions: &str) -> Self {
        Self::new(instructions)
    }
}
```

```rust
// shared/src/mermaid/hash.rs

use xxhash_rust::xxh64::xxh64;

/// Computes XXH64 hash of instructions with blank lines removed.
///
/// ## Examples
///
/// ```
/// use shared::mermaid::hash::compute_hash;
///
/// let hash1 = compute_hash("A --> B\n\nC --> D");
/// let hash2 = compute_hash("A --> B\nC --> D");
/// assert_eq!(hash1, hash2); // Blank lines don't affect hash
/// ```
pub fn compute_hash(instructions: &str) -> u64 {
    let normalized: String = instructions
        .lines()
        .filter(|line| !line.trim().is_empty())
        .collect::<Vec<_>>()
        .join("\n");
    xxh64(normalized.as_bytes(), 0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hash_ignores_blank_lines() {
        let with_blanks = "flowchart LR\n\n    A --> B\n\n";
        let without_blanks = "flowchart LR\n    A --> B";
        assert_eq!(compute_hash(with_blanks), compute_hash(without_blanks));
    }

    #[test]
    fn test_hash_different_content() {
        let a = "flowchart LR\n    A --> B";
        let b = "flowchart LR\n    A --> C";
        assert_ne!(compute_hash(a), compute_hash(b));
    }

    #[test]
    fn test_hash_deterministic() {
        let content = "flowchart LR\n    A --> B";
        assert_eq!(compute_hash(content), compute_hash(content));
    }

    #[test]
    fn test_hash_empty_string() {
        let hash = compute_hash("");
        assert_eq!(hash, compute_hash("   \n\n  ")); // All blank = empty
    }
}
```

**Unit Tests (Phase 3):**
- `test_mermaid_new_stores_instructions()`
- `test_mermaid_from_string()`
- `test_mermaid_from_str()`
- `test_mermaid_default_has_flowchart()`
- `test_mermaid_with_title()`
- `test_mermaid_with_footer()`
- `test_mermaid_with_theme_custom()`
- `test_mermaid_use_syntect_theme()`
- `test_mermaid_hash_computed_on_demand()`
- `test_mermaid_theme_resolution_light()`
- `test_mermaid_theme_resolution_dark()`
- `test_mermaid_clone()`

**Acceptance Criteria:**
- [ ] File `shared/src/mermaid/hash.rs` exists with >40 lines
- [ ] `grep "pub struct Mermaid" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "impl Default for Mermaid" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "impl From<String>" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "impl From<&str>" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "fn with_theme" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "fn with_title" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "fn use_syntect_theme" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "xxhash-rust" shared/Cargo.toml` succeeds
- [ ] `cargo test -p shared --lib mermaid` runs 20+ tests
- [ ] All tests pass

---

### Phase 4: HTML Rendering + Accessibility

**Principal Owner:** Rust Developer

**Goal:** Implement `render_for_html()` returning `MermaidHtml` struct with CSS variables and ARIA attributes.

**Dependencies:** Phase 3

**Blast Radius:** `cargo test -p shared --lib mermaid`

**Files to create/modify:**
- `shared/src/mermaid/render_html.rs` - HTML rendering implementation
- `shared/src/mermaid/mod.rs` - Add `render_for_html()` and `alt_text()` methods

**Deliverables:**
- `MermaidHtml` struct with `head` and `body` fields
- `render_for_html(&self) -> MermaidHtml` method
- `alt_text(&self) -> String` method for accessibility
- Dynamic header with mermaid.js CDN and CSS variable definitions
- Body content with diagram container and ARIA attributes
- Snapshot tests with insta

**Technical Details:**

```rust
// shared/src/mermaid/render_html.rs

use super::Mermaid;
use crate::markdown::highlighting::ColorMode;

/// HTML output from mermaid rendering.
#[derive(Debug, Clone, PartialEq)]
pub struct MermaidHtml {
    /// Content for the <head> section (scripts, styles)
    pub head: String,
    /// Content for the <body> section (diagram container)
    pub body: String,
}

impl Mermaid {
    /// Renders the diagram for HTML output.
    ///
    /// Returns a `MermaidHtml` struct with separate head and body content.
    ///
    /// ## Examples
    ///
    /// ```
    /// use shared::mermaid::Mermaid;
    ///
    /// let diagram = Mermaid::new("flowchart LR\n    A --> B");
    /// let html = diagram.render_for_html();
    /// assert!(html.head.contains("mermaid"));
    /// assert!(html.body.contains("role=\"img\""));
    /// ```
    #[tracing::instrument(skip(self), fields(hash = %self.hash()))]
    pub fn render_for_html(&self) -> MermaidHtml {
        MermaidHtml {
            head: self.render_html_head(),
            body: self.render_html_body(),
        }
    }

    fn render_html_head(&self) -> String {
        let light = self.theme(ColorMode::Light);
        let dark = self.theme(ColorMode::Dark);

        format!(
            r#"<script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({{ startOnLoad: true, theme: 'base', themeVariables: getMermaidTheme() }});

function getMermaidTheme() {{
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    return isDark ? {{
        primaryColor: '{dark_primary}',
        primaryTextColor: '{dark_text}',
        primaryBorderColor: '{dark_border}',
        background: '{dark_bg}'
    }} : {{
        primaryColor: '{light_primary}',
        primaryTextColor: '{light_text}',
        primaryBorderColor: '{light_border}',
        background: '{light_bg}'
    }};
}}
</script>
<style>
:root {{
    --mermaid-bg-light: {light_bg};
    --mermaid-primary-light: {light_primary};
    --mermaid-bg-dark: {dark_bg};
    --mermaid-primary-dark: {dark_primary};
}}
.mermaid {{
    text-align: center;
}}
</style>"#,
            light_bg = &light.background,
            light_primary = &light.primary_color,
            light_text = light.primary_text_color.as_deref().unwrap_or("#333"),
            light_border = light.primary_border_color.as_deref().unwrap_or("#666"),
            dark_bg = &dark.background,
            dark_primary = &dark.primary_color,
            dark_text = dark.primary_text_color.as_deref().unwrap_or("#fff"),
            dark_border = dark.primary_border_color.as_deref().unwrap_or("#888"),
        )
    }

    fn render_html_body(&self) -> String {
        let alt_text = self.alt_text();
        let title_attr = self.title.as_ref()
            .map(|t| format!(r#" title="{}""#, html_escape::encode_text(t)))
            .unwrap_or_default();

        format!(
            r#"<pre class="mermaid" role="img" aria-label="{alt}"{title}>
{instructions}
</pre>"#,
            alt = html_escape::encode_text(&alt_text),
            title = title_attr,
            instructions = html_escape::encode_text(&self.instructions),
        )
    }

    /// Generates accessible alt text for the diagram.
    ///
    /// Priority:
    /// 1. Explicit title if provided via `with_title()`
    /// 2. Diagram type detected from first line of instructions
    /// 3. Fallback: "Mermaid diagram"
    pub fn alt_text(&self) -> String {
        if let Some(ref title) = self.title {
            return title.clone();
        }

        self.instructions
            .lines()
            .next()
            .map(|line| {
                let line = line.trim().to_lowercase();
                if line.starts_with("flowchart") || line.starts_with("graph") {
                    "Flowchart diagram"
                } else if line.starts_with("sequencediagram") {
                    "Sequence diagram"
                } else if line.starts_with("classdiagram") {
                    "Class diagram"
                } else if line.starts_with("statediagram") {
                    "State diagram"
                } else if line.starts_with("erdiagram") {
                    "Entity relationship diagram"
                } else if line.starts_with("pie") {
                    "Pie chart"
                } else if line.starts_with("gantt") {
                    "Gantt chart"
                } else if line.starts_with("journey") {
                    "User journey diagram"
                } else if line.starts_with("gitgraph") {
                    "Git graph diagram"
                } else if line.starts_with("mindmap") {
                    "Mind map diagram"
                } else if line.starts_with("timeline") {
                    "Timeline diagram"
                } else {
                    "Mermaid diagram"
                }
            })
            .unwrap_or("Mermaid diagram")
            .to_string()
    }
}
```

**Unit Tests (Phase 4):**
- `test_render_html_contains_mermaid_esm()` - head has mermaid import
- `test_render_html_has_aria_attributes()` - body has role="img" and aria-label
- `test_render_html_escapes_instructions()` - XSS prevention
- `test_render_html_escapes_title()` - XSS prevention for title attribute
- `test_alt_text_with_explicit_title()` - uses provided title
- `test_alt_text_flowchart()` - detects flowchart
- `test_alt_text_sequence()` - detects sequenceDiagram
- `test_alt_text_class()` - detects classDiagram
- `test_alt_text_unknown_type()` - falls back to "Mermaid diagram"
- Snapshot tests: `test_html_head_snapshot()`, `test_html_body_snapshot()`

**Acceptance Criteria:**
- [ ] File `shared/src/mermaid/render_html.rs` exists with >100 lines
- [ ] `grep "pub struct MermaidHtml" shared/src/mermaid/render_html.rs` succeeds
- [ ] `grep "fn render_for_html" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "fn alt_text" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "mermaid.esm" shared/src/mermaid/render_html.rs` succeeds
- [ ] `grep "role=\"img\"" shared/src/mermaid/render_html.rs` succeeds
- [ ] `grep "aria-label" shared/src/mermaid/render_html.rs` succeeds
- [ ] `grep "insta::assert_snapshot" shared/src/mermaid/render_html.rs` succeeds (snapshot tests)
- [ ] `cargo test -p shared --lib mermaid::render_html` runs 10+ tests
- [ ] All tests pass

---

### Phase 5: Terminal Rendering

**Principal Owner:** Rust Developer

**Goal:** Implement `render_for_terminal()` using mermaid.ink service with URL validation and RAII temp files.

**Dependencies:** Phase 3

**Blast Radius:** `cargo test -p shared --lib mermaid`

**Files to create/modify:**
- `shared/src/mermaid/render_terminal.rs` - Terminal rendering implementation
- `shared/src/mermaid/mod.rs` - Add `render_for_terminal()` method

**Dependencies to add:**
- Add `base64 = "0.22"` to `shared/Cargo.toml`
- Already have: `resvg`, `reqwest`, `viuer`, `tempfile`

**Deliverables:**
- `MermaidRenderError` enum for terminal rendering errors
- `render_for_terminal(&self) -> Result<(), MermaidRenderError>` async method
- URL length validation (< 2KB)
- Base64 encoding for mermaid.ink API
- SVG to PNG via resvg with `usvg::FitTo::Original`
- Display via viuer with `tempfile::NamedTempFile` for RAII cleanup
- Fallback to code block on error

**Technical Details:**

```rust
// shared/src/mermaid/render_terminal.rs

use base64::{Engine, engine::general_purpose::STANDARD};
use resvg::usvg::{self, FitTo};
use tempfile::NamedTempFile;
use thiserror::Error;
use std::io::Write;

/// Maximum URL length for mermaid.ink (base64-encoded content)
const MAX_MERMAID_INK_LENGTH: usize = 2000;

#[derive(Error, Debug)]
pub enum MermaidRenderError {
    #[error("Diagram too large for mermaid.ink ({size} bytes, max {max})")]
    ContentTooLarge { size: usize, max: usize },
    #[error("Failed to fetch from mermaid.ink: {0}")]
    FetchError(#[from] reqwest::Error),
    #[error("mermaid.ink returned status {0}")]
    ServiceError(u16),
    #[error("Failed to parse SVG: {0}")]
    SvgParseError(String),
    #[error("Failed to render image: {0}")]
    RenderError(String),
    #[error("Terminal image rendering not supported")]
    NotSupported,
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}

impl Mermaid {
    /// Renders the diagram to the terminal.
    ///
    /// Uses mermaid.ink to convert instructions to SVG, then resvg
    /// to convert to PNG, and viuer to display in the terminal.
    ///
    /// Falls back to displaying the raw mermaid code block if rendering fails.
    ///
    /// ## Errors
    ///
    /// Returns `MermaidRenderError::ContentTooLarge` if the diagram exceeds 2KB.
    /// Returns other errors if the mermaid.ink service fails.
    #[tracing::instrument(skip(self), fields(hash = %self.hash(), instructions_len = %self.instructions.len()))]
    pub async fn render_for_terminal(&self) -> Result<(), MermaidRenderError> {
        // Validate content size before encoding
        let encoded = STANDARD.encode(&self.instructions);
        if encoded.len() > MAX_MERMAID_INK_LENGTH {
            tracing::warn!(
                size = encoded.len(),
                max = MAX_MERMAID_INK_LENGTH,
                "Diagram too large, falling back to code block"
            );
            self.render_fallback();
            return Err(MermaidRenderError::ContentTooLarge {
                size: encoded.len(),
                max: MAX_MERMAID_INK_LENGTH,
            });
        }

        // Try to render via mermaid.ink
        match self.fetch_svg_from_mermaid_ink(&encoded).await {
            Ok(svg_data) => self.render_svg_to_terminal(&svg_data),
            Err(e) => {
                tracing::warn!(?e, "mermaid.ink failed, falling back to code block");
                self.render_fallback();
                Ok(())
            }
        }
    }

    async fn fetch_svg_from_mermaid_ink(&self, encoded: &str) -> Result<String, MermaidRenderError> {
        let url = format!("https://mermaid.ink/svg/base64:{}", encoded);

        tracing::debug!(%url, "Fetching SVG from mermaid.ink");
        let response = reqwest::get(&url).await?;

        if !response.status().is_success() {
            return Err(MermaidRenderError::ServiceError(response.status().as_u16()));
        }

        Ok(response.text().await?)
    }

    fn render_svg_to_terminal(&self, svg_data: &str) -> Result<(), MermaidRenderError> {
        // Parse SVG
        let tree = usvg::Tree::from_data(svg_data.as_bytes(), &usvg::Options::default())
            .map_err(|e| MermaidRenderError::SvgParseError(e.to_string()))?;

        // Create pixmap
        let size = tree.size();
        let mut pixmap = tiny_skia::Pixmap::new(size.width() as u32, size.height() as u32)
            .ok_or_else(|| MermaidRenderError::RenderError("Invalid dimensions".into()))?;

        // Render with FitTo::Original
        resvg::render(&tree, FitTo::Original, tiny_skia::Transform::identity(), &mut pixmap.as_mut());

        // Use NamedTempFile for RAII cleanup
        let mut temp_file = NamedTempFile::with_suffix(".png")?;
        let png_data = pixmap.encode_png()
            .map_err(|e| MermaidRenderError::RenderError(e.to_string()))?;
        temp_file.write_all(&png_data)?;
        temp_file.flush()?;

        // Display via viuer
        viuer::print_from_file(temp_file.path(), &viuer::Config::default())
            .map_err(|e| MermaidRenderError::RenderError(e.to_string()))?;

        // temp_file automatically cleaned up on drop
        Ok(())
    }

    fn render_fallback(&self) {
        println!("```mermaid");
        println!("{}", self.instructions);
        println!("```");
    }
}
```

**Unit Tests (Phase 5):**
- `test_content_too_large_error()` - validates size limit
- `test_fallback_renders_code_block()` - fallback output format
- `test_base64_encoding()` - encoding produces valid base64
- Wiremock tests:
  - `test_fetch_svg_success()` - 200 response
  - `test_fetch_svg_rate_limit()` - 429 response
  - `test_fetch_svg_server_error()` - 500 response
  - `test_fetch_svg_timeout()` - network timeout

**Acceptance Criteria:**
- [ ] File `shared/src/mermaid/render_terminal.rs` exists with >120 lines
- [ ] `grep "async fn render_for_terminal" shared/src/mermaid/mod.rs` succeeds
- [ ] `grep "mermaid.ink" shared/src/mermaid/render_terminal.rs` succeeds
- [ ] `grep "MAX_MERMAID_INK_LENGTH" shared/src/mermaid/render_terminal.rs` succeeds
- [ ] `grep "NamedTempFile" shared/src/mermaid/render_terminal.rs` succeeds
- [ ] `grep "FitTo::Original" shared/src/mermaid/render_terminal.rs` succeeds
- [ ] `grep "base64" shared/Cargo.toml` succeeds
- [ ] `grep "MermaidRenderError" shared/src/mermaid/render_terminal.rs` succeeds
- [ ] `cargo test -p shared --lib mermaid::render_terminal` runs 8+ tests
- [ ] All tests pass

---

### Phase 6: CLI Integration + Integration Tests

**Principal Owner:** Rust Developer

**Goal:** Add `--mermaid` CLI switch to `md` binary, wire up HTML integration, and add integration test suite.

**Dependencies:** Phase 4, Phase 5

**Blast Radius:** `cargo test -p md` + `cargo test -p shared`

**Files to modify/create:**
- `md/src/main.rs` - Add `--mermaid` and `--mermaid-alt` flags
- `md/Cargo.toml` - Ensure tokio runtime features
- `shared/src/markdown/output/html.rs` - Integrate mermaid header injection
- `shared/tests/fixtures/mermaid/` - Test fixture files
- `shared/tests/mermaid_integration.rs` - Integration test suite

**Deliverables:**
- `--mermaid` CLI flag for terminal rendering
- `--mermaid-alt` CLI flag for text fallback
- Auto-detection of mermaid code blocks in markdown
- Integration with `--html` and `--show-html` flags
- Test fixtures directory with valid/invalid diagrams
- Integration test suite

**Technical Details:**

```rust
// In md/src/main.rs - add to Args struct

/// Render mermaid diagrams to terminal as images.
/// Falls back to code blocks if terminal doesn't support images.
#[arg(long, default_value = "false")]
mermaid: bool,

/// Display mermaid diagrams as text (code blocks) instead of images.
/// Useful for terminals that don't support inline images.
#[arg(long, default_value = "false")]
mermaid_alt: bool,
```

**Test Fixtures:**
```
shared/tests/fixtures/mermaid/
├── valid/
│   ├── simple_flowchart.mmd
│   ├── complex_sequence.mmd
│   ├── all_types.mmd
│   └── with_title.mmd
└── invalid/
    ├── empty.mmd
    ├── too_large.mmd  # >2KB
    └── whitespace_only.mmd
```

**Integration Tests:**
```rust
// shared/tests/mermaid_integration.rs

use shared::mermaid::Mermaid;

#[test]
fn test_fixture_simple_flowchart() {
    let content = include_str!("fixtures/mermaid/valid/simple_flowchart.mmd");
    let diagram = Mermaid::from(content);
    let html = diagram.render_for_html();
    assert!(html.body.contains("flowchart"));
}

#[tokio::test]
async fn test_terminal_render_with_mocked_service() {
    // Use wiremock to mock mermaid.ink
}
```

**Acceptance Criteria:**
- [ ] `grep "\-\-mermaid" md/src/main.rs` succeeds
- [ ] `grep "mermaid_alt" md/src/main.rs` succeeds
- [ ] `cargo build -p md` succeeds
- [ ] `./target/debug/md --help` shows mermaid flags
- [ ] Directory `shared/tests/fixtures/mermaid/valid/` exists with 3+ files
- [ ] File `shared/tests/mermaid_integration.rs` exists with >50 lines
- [ ] `cargo test -p shared --test mermaid_integration` succeeds
- [ ] `cargo test -p md` succeeds
- [ ] All tests pass

---

## Blast Radius Analysis

| Phase | Change Type | Blast Radius |
|-------|-------------|--------------|
| 1 | New module (types) | `cargo test -p shared --lib mermaid::theme` |
| 2 | Static definitions | `cargo test -p shared --lib mermaid::theme` |
| 3 | Main struct + hash | `cargo test -p shared --lib mermaid` |
| 4 | HTML + accessibility | `cargo test -p shared --lib mermaid` |
| 5 | Terminal rendering | `cargo test -p shared --lib mermaid` |
| 6 | CLI + integration | `cargo test -p md` + `cargo test -p shared` |

---

## Cross-Cutting Concerns

### Testing Strategy
- **Unit tests**: `#[cfg(test)] mod tests` blocks in each module
- **Integration tests**: `shared/tests/mermaid_integration.rs` for end-to-end rendering
- **Property-based tests**: proptest for hash determinism (Phase 3)
- **Snapshot tests**: insta for HTML output stability (Phase 4)
- **Doc tests**: Examples in rustdoc comments for all public APIs
- **HTTP mocks**: wiremock for mermaid.ink service testing (Phase 5)
- **Test fixtures**: `shared/tests/fixtures/mermaid/` with valid/invalid diagrams

### Security Considerations
- **Input validation**: URL length validation before mermaid.ink requests
- **HTML escaping**: All user content escaped with `html_escape::encode_text()`
- **No arbitrary code execution**: Instructions are data, not code
- **XSS prevention**: Title and instructions escaped in HTML output

### Performance Considerations
- **Hash on demand**: No cached hash field, compute when needed (XXH64 is fast)
- **Lazy theme loading**: Static themes via lazy_static, resolved lazily
- **Async rendering**: Terminal rendering is async for network calls
- **RAII cleanup**: tempfile::NamedTempFile auto-deletes on drop

### Error Handling
- `MermaidThemeError` for theme parsing (Phase 1)
- `MermaidRenderError` for terminal rendering (Phase 5)
- Graceful fallback to code block on render failure
- All errors use thiserror for consistency

### Observability
- `#[tracing::instrument]` on all public methods
- Structured fields: `hash`, `instructions_len`, `size`, `max`
- Warn-level logs for fallback scenarios
- Debug-level logs for network requests

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Theme type definitions (Schema Architect) |
| Group B | Phase 2 | Static themes (depends on Phase 1) |
| Group C | Phase 3 | Main struct (depends on Phase 2) |
| Group D | Phase 4, Phase 5 | HTML and terminal rendering are independent |
| Group E | Phase 6 | CLI integration depends on Phases 4 and 5 |

### Corrected Parallelization Diagram

```
Timeline:
────────────────────────────────────────────────────────────────────────►

Phase 1: ████████ (MermaidTheme types)
                │
Phase 2:        └──████████ (Static themes - DEPENDS on Phase 1)
                          │
Phase 3:                  └──████████ (Mermaid struct)
                                    │
Phase 4 + 5:                        └──████████████ (HTML + Terminal in parallel)
                                                  │
Phase 6:                                          └──████████ (CLI + Integration)
```

**Note:** Phase 1 and Phase 2 are sequential because Phase 2 requires `MermaidTheme` from Phase 1.

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| mermaid.ink rate limiting | Medium | Fallback to code block, add exponential backoff |
| mermaid.ink service outage | Medium | Fallback to code block, consider self-hosted option |
| Large diagram exceeds URL limit | Medium | Validate length before request, clear error message |
| Terminal image support varies | Medium | Detect with viuer, fallback to code block |
| Theme color contrast insufficient | Low | Validate NEUTRAL_THEME contrast in tests |
| XXH64 hash collisions | Very Low | 64-bit hash has negligible collision probability |

## Open Questions

- [ ] Should we support self-hosted mermaid rendering service as an option?
- [ ] Should terminal rendering cache PNGs to disk for repeated views?
- [ ] Should we support custom fonts in themes?
- [ ] Should we add a `--mermaid-theme` CLI flag for theme override?

## Dependencies Summary

Add to `shared/Cargo.toml`:

```toml
# Mermaid module dependencies
xxhash-rust = { version = "0.8", features = ["xxh64"] }
base64 = "0.22"
# Already present: resvg, reqwest, viuer, html-escape, thiserror, lazy_static, tempfile
```
