# Fix Research Library Command - SKILL.md Generation Quality

**Created:** 2025-12-29
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Fix the `research library` command to generate well-formed SKILL.md files with proper YAML frontmatter and add a `when_to_use` field to ResearchMetadata to improve skill discovery and activation.

## Review Summary

**Reviews Completed:** 2025-12-29

**Reviewers:**
- Rust Developer: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Overall Consensus:** Plan is fundamentally sound with excellent root cause analysis and comprehensive testing strategy. Key changes needed:

1. **Add serde_yaml dependency** to Cargo.toml (BLOCKER for Phase 2)
2. **Fix file splitting logic** to handle first file correctly (no separator before SKILL.md)
3. **Skip normalization for SKILL.md** instead of trying to preserve frontmatter during normalization
4. **Enhance SkillFrontmatter struct** with observed fields (last_updated, hash) and serde alias for tools/allowed-tools
5. **Add comprehensive unit tests** for file splitting and normalization functions
6. **Avoid double YAML parsing** by returning parsed frontmatter from validation
7. **Add regression test** for the original bug (LLM output with file separator)

**Key Changes from Review:**

1. **Phase 0 (NEW)**: Add `serde_yaml = "0.9"` to research/lib/Cargo.toml
2. **Phase 1**: Add optional `schema_version: u32` field for future evolution
3. **Phase 2**:
   - Enhance SkillFrontmatter with `last_updated`, `hash` fields
   - Use `#[serde(alias = "allowed-tools")]` on tools field
   - Return both frontmatter and body from validation to avoid double parsing
   - Add InvalidToolsField error variant
   - Increase test count to 10+ (separate tests for each required field)
4. **Phase 4**:
   - Skip normalization entirely for SKILL.md
   - Fix split_into_files to handle implicit first file
   - Add robust error handling (no silent failures)
   - Add unit tests for splitting and normalization functions
5. **Phase 6**:
   - Add regression test for original bug
   - Add whitespace variation tests
   - Clarify proptest is optional
   - Add test fixtures directory

**Resolved Concerns:**

- **serde_yaml missing** → Add as Phase 0 prerequisite
- **tools vs allowed-tools confusion** → Use serde alias to support both
- **File splitting first-file bug** → Explicitly handle implicit first file
- **Double YAML parsing** → Return parsed frontmatter from validation function
- **Normalization complexity** → Skip normalization for SKILL.md entirely
- **Insufficient test coverage** → Add unit tests for new functions, regression test, whitespace tests

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Generate SKILL.md files with valid YAML frontmatter (proper `---` delimiters) | High | Rust Developer |
| FR-2 | Ensure frontmatter contains required `name` field matching library name | High | Rust Developer |
| FR-3 | Ensure frontmatter contains effective `description` field describing when to use skill | High | Rust Developer |
| FR-4 | Support optional `allowed-tools` or `tools` list in frontmatter | Medium | Rust Developer |
| FR-5 | Add `when_to_use` property to ResearchMetadata struct | High | Schema Architect |
| FR-6 | Mirror skill frontmatter `description` content in metadata `when_to_use` | High | Rust Developer |
| FR-7 | Validate SKILL.md frontmatter format after generation | High | Rust Developer |
| FR-8 | Preserve existing file splitting functionality for multi-file skills | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | No regression in library research quality | 100% | Feature Tester (Rust) |
| NFR-2 | Backward compatibility with existing metadata.json files | 100% | Rust Developer |
| NFR-3 | Clear error messages when frontmatter validation fails | User-friendly | Rust Developer |
| NFR-4 | Maintain existing research command performance | <5% overhead | Rust Developer |

## Root Cause Analysis

### Current Problems

Based on exploration of the codebase and generated files:

1. **LLM outputs file separator in content**: The prompt instructs LLMs to use `--- FILE: filename.md ---` separators, but the LLM includes this in the first file (SKILL.md)

2. **LLM doesn't use proper YAML frontmatter**: Generated files have `## name:` instead of proper YAML frontmatter with `---` delimiters

3. **`normalize_markdown()` mangles output**: The normalization function (research/lib/src/lib.rs:739-772) uses pulldown_cmark to re-serialize markdown, converting intended frontmatter delimiters into headings

4. **File splitting occurs after normalization**: The code splits files based on `--- FILE:` markers, but normalization has already converted these to `## --- FILE:`

5. **No frontmatter validation**: No validation ensures SKILL.md has valid YAML frontmatter with required fields

### Example of Current (Broken) Output

```markdown
## --- FILE: SKILL.md ---

## name: clap
description: Build robust Rust CLI interfaces...
```

### Expected Output

```markdown
---
name: clap
description: Build robust Rust CLI interfaces with clap v4...
tools: [Read, Write, Edit, Grep, Glob, Bash]
---

# clap (Rust CLI Argument Parsing)
```

## Architecture Overview

### Components Affected

1. **Prompt Template** (`research/lib/prompts/skill.md`)
   - Needs clearer instructions about frontmatter format
   - Should specify exact frontmatter structure with examples

2. **Library Command Logic** (`research/lib/src/lib.rs:1648-1703`)
   - File splitting logic needs to run BEFORE normalization
   - Normalization should preserve frontmatter

3. **ResearchMetadata Struct** (`research/lib/src/lib.rs:231-250`)
   - Add `when_to_use` field
   - Maintain backward compatibility with serde attributes

4. **Normalization Function** (`research/lib/src/lib.rs:739-772`)
   - Add frontmatter preservation logic OR
   - Skip normalization for SKILL.md OR
   - Normalize only body content (after frontmatter)

5. **Validation Logic** (New)
   - Parse and validate YAML frontmatter
   - Verify required fields exist
   - Provide actionable error messages

### Data Flow

```
User runs `research library <name>`
    ↓
Phase 1: Parallel research prompts → question_N.md files
    ↓
Phase 2: Parallel SKILL.md + deep_dive.md generation
    ↓
LLM generates SKILL.md content with frontmatter
    ↓
[NEW] Validate frontmatter before processing
    ↓
[FIXED] Split files BEFORE normalization
    ↓
[FIXED] Normalize body content (preserve frontmatter)
    ↓
Write SKILL.md to skill/SKILL.md
    ↓
[NEW] Extract `description` from frontmatter
    ↓
[NEW] Save to metadata.when_to_use
    ↓
Save metadata.json
```

## Phases

### Phase 0: Add serde_yaml Dependency

**Principal Owner:** Rust Developer

**Goal:** Add required serde_yaml dependency before parallel development begins

**Dependencies:** None

**Blast Radius:** `cargo build` (verify dependency resolves correctly)

**Files to Modify:**
- `research/lib/Cargo.toml`

**Deliverables:**
- Add `serde_yaml = "0.9"` to dependencies section

**Technical Details:**
```toml
[dependencies]
# ... existing dependencies ...
serde_yaml = "0.9"
```

**Acceptance Criteria:**
- [ ] `grep "serde_yaml" research/lib/Cargo.toml` succeeds
- [ ] `cargo build` succeeds without dependency resolution errors
- [ ] `cargo tree | grep serde_yaml` shows dependency is resolved

---

### Phase 1: Add `when_to_use` to ResearchMetadata

**Principal Owner:** Schema Architect

**Goal:** Extend ResearchMetadata struct to store when-to-use guidance

**Dependencies:** None

**Blast Radius:** `cargo test --lib` (all library tests, as this is a foundational struct change)

**Files to Modify:**
- `research/lib/src/lib.rs` (lines 231-250: ResearchMetadata struct)

**Deliverables:**
- Add `when_to_use: Option<String>` field to ResearchMetadata
- Add `schema_version: u32` field with `#[serde(default)]` for future evolution
- Add `#[serde(skip_serializing_if = "Option::is_none")]` for backward compatibility
- Update the `Default` implementation to set `when_to_use: None` and `schema_version: 0`

**Technical Details:**
```rust
pub struct ResearchMetadata {
    #[serde(default)]
    pub schema_version: u32,  // Defaults to 0 for backward compat, future versions can increment

    pub kind: ResearchKind,
    pub library_info: Option<LibraryInfoMetadata>,
    pub additional_files: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub brief: Option<String>,
    pub summary: Option<String>,

    // NEW FIELD
    #[serde(skip_serializing_if = "Option::is_none")]
    pub when_to_use: Option<String>,
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/lib.rs` contains `pub when_to_use: Option<String>` field (line ~248)
- [ ] Field has `#[serde(skip_serializing_if = "Option::is_none")]` attribute
- [ ] `cargo build` succeeds
- [ ] `cargo test --lib` passes all tests
- [ ] Existing metadata.json files can be deserialized without errors

---

### Phase 2: Create Frontmatter Validation Module

**Principal Owner:** Rust Developer

**Goal:** Create a validation module to parse and validate SKILL.md frontmatter

**Dependencies:** Phase 0 complete (needs serde_yaml dependency)

**Blast Radius:** `cargo test --lib validation` (new module tests only)

**Files to Create:**
- `research/lib/src/validation.rs` (new module)
- `research/lib/src/validation/frontmatter.rs` (frontmatter parsing/validation logic)

**Files to Modify:**
- `research/lib/src/lib.rs` (add `mod validation;` and `pub use validation::*;`)

**Deliverables:**
- YAML frontmatter parser using `serde_yaml` crate
- Validation function that checks:
  - Frontmatter exists (starts with `---` on line 1)
  - Frontmatter has closing `---`
  - Required field `name` exists and is non-empty
  - Required field `description` exists and is non-empty
  - Optional field `tools` is valid array if present
- Custom error type for validation failures (using `thiserror`)

**Technical Details:**
```rust
// research/lib/src/validation/frontmatter.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum FrontmatterError {
    #[error("SKILL.md must start with YAML frontmatter (---) on line 1")]
    MissingFrontmatter,

    #[error("YAML frontmatter is missing closing delimiter (---)")]
    UnclosedFrontmatter,

    #[error("YAML parsing failed: {0}")]
    InvalidYaml(#[from] serde_yaml::Error),

    #[error("Missing required field '{field}' in frontmatter")]
    MissingRequiredField { field: String },

    #[error("Field '{field}' cannot be empty")]
    EmptyField { field: String },
}

#[derive(Debug, Deserialize, Serialize)]
pub struct SkillFrontmatter {
    pub name: String,
    pub description: String,

    // Handle both "tools" and "allowed-tools" field names via serde alias
    #[serde(alias = "allowed-tools", skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<String>>,

    // Observed fields in real SKILL.md files
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash: Option<String>,
}

/// Parse and validate frontmatter, returning both the frontmatter struct and body content
/// This avoids double YAML parsing
pub fn parse_and_validate_frontmatter(content: &str) -> Result<(SkillFrontmatter, String), FrontmatterError> {
    // 1. Check content starts with ---
    // 2. Find closing ---
    // 3. Parse YAML between delimiters
    // 4. Validate required fields
    // 5. Return (SkillFrontmatter, body_content) to avoid re-parsing
}

pub fn extract_frontmatter(content: &str) -> Option<(String, String)> {
    // Returns (frontmatter_yaml, body_content)
    // Used internally by parse_and_validate_frontmatter
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/src/validation.rs` exists
- [ ] File `research/lib/src/validation/frontmatter.rs` exists with >150 lines
- [ ] `grep "pub struct SkillFrontmatter" research/lib/src/validation/frontmatter.rs` succeeds
- [ ] `grep "pub fn parse_and_validate_frontmatter" research/lib/src/validation/frontmatter.rs` succeeds
- [ ] `cargo test --lib validation` runs 10+ tests covering:
  - Valid frontmatter parsing (with all fields)
  - Valid frontmatter parsing (minimal: name + description only)
  - Missing frontmatter detection
  - Unclosed frontmatter detection
  - Missing required field: name
  - Missing required field: description
  - Empty field: name
  - Empty field: description
  - Optional tools field (both "tools" and "allowed-tools" via alias)
  - Invalid YAML syntax
  - Extraction of frontmatter vs body (returns both from validation function)
  - Whitespace variations (CRLF line endings, trailing spaces after ---)
- [ ] All validation tests pass

---

### Phase 3: Improve LLM Prompt for SKILL.md Generation

**Principal Owner:** Rust Developer

**Goal:** Update the SKILL.md generation prompt to produce valid YAML frontmatter

**Dependencies:** None (can run in parallel with Phases 1-2)

**Blast Radius:** Manual testing only (prompt changes don't affect code tests)

**Files to Modify:**
- `research/lib/prompts/skill.md` (entire file structure)

**Deliverables:**
- Clearer prompt instructions for frontmatter format
- Multiple examples showing correct format
- Explicit instruction NOT to include file separator in first file
- Template for frontmatter with all fields

**Technical Details:**

Update the prompt to include:

1. **More explicit frontmatter example**:
```markdown
SKILL.md MUST start with this EXACT format (no code fences):

---
name: {{library_name}}
description: Expert knowledge for [technology/library] - [key capabilities]. Use when [specific scenarios].
tools: [Read, Write, Edit, Grep, Glob, Bash]
---

# {{library_name}}

[Rest of content...]
```

2. **Clear instruction about file separators**:
```markdown
IMPORTANT: Do NOT include "--- FILE: SKILL.md ---" at the start of SKILL.md.
The file separator is ONLY used BETWEEN files, not before the first file.

If you're creating multiple files, structure like this:

[SKILL.md content starts here - no separator]
---
name: library-name
description: ...
---

# Content...

--- FILE: advanced-usage.md ---
# Advanced Usage
...

--- FILE: examples.md ---
# Examples
...
```

3. **Better description guidance**:
```markdown
The `description` field should:
- Start with action verb (e.g., "Build", "Expert knowledge for", "Use when")
- Describe WHAT the skill provides (capabilities, expertise)
- Describe WHEN to activate it (use cases, scenarios)
- Be 1-2 sentences, concise but informative
- Help Claude decide if this skill is relevant to the current task

GOOD: "Expert knowledge for building Rust CLI interfaces with clap v4, covering derive macros, subcommands, argument validation, and shell completions. Use when designing CLI argument parsing, implementing commands, or troubleshooting clap issues."

BAD: "A skill about clap" (too vague)
BAD: "This skill covers everything about clap including installation, configuration, usage, examples, best practices, troubleshooting, and more." (too verbose)
```

**Acceptance Criteria:**
- [ ] File `research/lib/prompts/skill.md` contains updated frontmatter example (no ```yaml fences)
- [ ] File contains explicit instruction about NOT using file separator in first file
- [ ] File contains 2+ examples of GOOD vs BAD descriptions
- [ ] `grep "name: {{" research/lib/prompts/skill.md` succeeds
- [ ] `grep "tools: \[" research/lib/prompts/skill.md` succeeds
- [ ] Manual test: Generate SKILL.md for a test library and verify frontmatter is valid

---

### Phase 4: Fix File Splitting and Normalization Order

**Principal Owner:** Rust Developer

**Goal:** Split files BEFORE normalization and skip normalization for SKILL.md entirely

**Dependencies:** Phase 0, Phase 2 complete (needs serde_yaml and validation module)

**Blast Radius:** `cargo test --lib` + `cargo test --test library_integration_test`

**Files to Modify:**
- `research/lib/src/lib.rs` (lines 1672-1703: file splitting logic)
- `research/lib/src/lib.rs` (lines 739-772: normalize_markdown function)

**Deliverables:**
- Refactor file splitting to occur BEFORE normalization
- Skip normalization entirely for SKILL.md (preserve exact LLM output)
- Apply normalization only to supporting documentation files (advanced-usage.md, examples.md, etc.)
- Fix `split_into_files()` logic to handle implicit first file correctly
- Add robust error handling (no silent failures)

**Technical Details:**

**Current Flow** (broken):
```rust
// Phase 2: Generate SKILL.md
let skill_content = run_prompt_task(...).await?;
let normalized = normalize_markdown(&skill_content);  // ← Mangles frontmatter!

if normalized.contains("--- FILE:") {  // ← Now broken, became ## --- FILE:
    // Split files
}
```

**New Flow** (fixed):
```rust
// Phase 2: Generate SKILL.md
let skill_content = run_prompt_task(...).await?;

// Step 1: Split files BEFORE normalization
let files = if skill_content.contains("--- FILE:") {
    split_into_files(&skill_content)
} else {
    vec![("SKILL.md".to_string(), skill_content)]
};

// Step 2: Selectively normalize files (skip SKILL.md, normalize others)
for (filename, content) in files {
    let final_content = if filename == "SKILL.md" {
        // Don't normalize SKILL.md - preserve frontmatter exactly as LLM generated it
        content
    } else {
        // Normalize supporting documentation files
        normalize_markdown(&content)
    };

    let file_path = skill_dir.join(&filename);
    fs::write(&file_path, final_content).await.map_err(|e| {
        tracing::error!("Failed to write {}: {}", filename, e);
        e
    })?;
}
```

**New function to add**:
```rust
/// Split multi-file LLM output into separate files
/// Handles the implicit first file (SKILL.md) that doesn't have a separator before it
fn split_into_files(content: &str) -> Vec<(String, String)> {
    let mut files = Vec::new();
    let mut current_filename = "SKILL.md".to_string();  // First file is implicitly SKILL.md
    let mut current_content = String::new();

    for line in content.lines() {
        if line.starts_with("--- FILE:") && line.ends_with("---") {
            // Save previous file
            if !current_content.trim().is_empty() {
                files.push((current_filename.clone(), current_content.trim().to_string()));
            }

            // Extract new filename from separator
            current_filename = line.trim_start_matches("--- FILE:")
                .trim_end_matches("---")
                .trim()
                .to_string();
            current_content = String::new();
        } else {
            current_content.push_str(line);
            current_content.push('\n');
        }
    }

    // Don't forget the last file
    if !current_content.trim().is_empty() {
        files.push((current_filename, current_content.trim().to_string()));
    }

    files
}
```

**Acceptance Criteria:**
- [ ] Function `split_into_files` exists in research/lib/src/lib.rs
- [ ] File splitting occurs BEFORE normalization in library command (line ~1674)
- [ ] SKILL.md is NOT normalized (exact LLM output preserved)
- [ ] Supporting files (advanced-usage.md, etc.) ARE normalized
- [ ] File writes use proper error handling (no `let _ = fs::write()`)
- [ ] Unit tests for `split_into_files()` covering:
  - Single file (no separators) → returns vec with one entry
  - Multiple files (2-3 separators) → returns correct number of files
  - Empty content between separators → skipped (not added to vec)
  - Separator at end of content → last file captured correctly
  - LLM output starting with separator (current bug scenario) → first file is SKILL.md
- [ ] `cargo test --lib` passes all tests
- [ ] `cargo test --test library_integration_test` passes
- [ ] Manual test: Generated SKILL.md has valid `---` delimiters (not `##`)
- [ ] Manual test: Multi-file skills still work (files are correctly split)

---

### Phase 5: Integrate Validation and Populate `when_to_use`

**Principal Owner:** Rust Developer

**Goal:** Validate SKILL.md frontmatter after generation and populate metadata.when_to_use

**Dependencies:** Phase 1, Phase 2, Phase 4 complete

**Blast Radius:** `cargo test --lib` + `cargo test --test library_integration_test`

**Files to Modify:**
- `research/lib/src/lib.rs` (lines 1648-1703: library command, after SKILL.md generation)

**Deliverables:**
- Call validation function after SKILL.md is written
- Extract `description` field from frontmatter
- Populate `metadata.when_to_use` with description content
- Save updated metadata
- Log validation errors with actionable guidance

**Technical Details:**

```rust
// After writing SKILL.md
let skill_md_path = skill_dir.join("SKILL.md");
let skill_content = fs::read_to_string(&skill_md_path)?;

// Validate frontmatter (returns both frontmatter and body to avoid double parsing)
match parse_and_validate_frontmatter(&skill_content) {
    Ok((frontmatter, _body)) => {
        tracing::info!("✓ SKILL.md frontmatter is valid");

        // Extract description for metadata (no need to re-parse)
        metadata.when_to_use = Some(frontmatter.description.clone());
        metadata.updated_at = Utc::now();
        metadata.save()?;

        tracing::info!("✓ Updated metadata.when_to_use");
    }
    Err(e) => {
        tracing::error!("✗ SKILL.md frontmatter validation failed: {}", e);
        tracing::error!("  File: {}", skill_md_path.display());
        tracing::error!("  Please manually fix the frontmatter in SKILL.md");

        // Don't fail the entire command, but warn user
        eprintln!("\n⚠️  Warning: SKILL.md frontmatter is invalid");
        eprintln!("   {}", e);
        eprintln!("   File: {}", skill_md_path.display());
        eprintln!("   The skill may not activate correctly until this is fixed.\n");
    }
}
```

**Acceptance Criteria:**
- [ ] After SKILL.md is written, validation function is called (line ~1700)
- [ ] If validation succeeds, `metadata.when_to_use` is populated with description
- [ ] If validation fails, error is logged with file path and actionable message
- [ ] Validation failure does NOT crash the command (warns but continues)
- [ ] `cargo test --lib` passes all tests
- [ ] `cargo test --test library_integration_test` passes
- [ ] Test case: Valid frontmatter → `metadata.when_to_use` populated
- [ ] Test case: Invalid frontmatter → Warning logged, command completes
- [ ] Manual test: Run `research library <test-lib>` and verify metadata.json has `when_to_use` field

---

### Phase 6: Add Tests for New Functionality

**Principal Owner:** Feature Tester (Rust)

**Goal:** Comprehensive test coverage for all new validation and processing logic

**Dependencies:** Phases 1-5 complete

**Blast Radius:** `cargo test` (full test suite to ensure no regressions)

**Files to Create:**
- `research/lib/tests/skill_validation_test.rs` (integration tests)
- `research/lib/tests/fixtures/skill/` (test fixture directory with example SKILL.md files)

**Files to Modify:**
- `research/lib/src/validation/frontmatter.rs` (add doc tests)
- `research/lib/src/lib.rs` (add unit tests for split_into_files in #[cfg(test)] mod)

**Deliverables:**
- Unit tests for frontmatter validation (already in Phase 2)
- Unit tests for file splitting (already in Phase 4)
- Integration test: Full library workflow with validation
- Integration test: ResearchMetadata serialization with `when_to_use`
- Regression test: Original bug (LLM output with file separator at start)
- Whitespace variation tests: CRLF line endings, trailing spaces, tabs
- Property-based tests (OPTIONAL): Frontmatter parsing edge cases (proptest)
- Doc tests: Examples in SkillFrontmatter documentation
- Test fixtures: Valid and invalid SKILL.md examples

**Technical Details:**

**Integration Test Structure**:
```rust
// research/lib/tests/skill_validation_test.rs

#[test]
fn test_valid_skill_frontmatter_parsing() {
    let content = r#"---
name: test-library
description: Expert knowledge for testing
tools: [Read, Write]
---

# Test Library
"#;

    let result = parse_and_validate_frontmatter(content);
    assert!(result.is_ok());

    let frontmatter = result.unwrap();
    assert_eq!(frontmatter.name, "test-library");
    assert_eq!(frontmatter.description, "Expert knowledge for testing");
    assert_eq!(frontmatter.tools, Some(vec!["Read".to_string(), "Write".to_string()]));
}

#[test]
fn test_missing_frontmatter_error() {
    let content = "# No frontmatter here\n\nJust content.";
    let result = parse_and_validate_frontmatter(content);
    assert!(matches!(result, Err(FrontmatterError::MissingFrontmatter)));
}

#[test]
fn test_metadata_with_when_to_use_serialization() {
    let metadata = ResearchMetadata {
        when_to_use: Some("Use when building CLIs".to_string()),
        ..Default::default()
    };

    let json = serde_json::to_string(&metadata).unwrap();
    assert!(json.contains("when_to_use"));

    let deserialized: ResearchMetadata = serde_json::from_str(&json).unwrap();
    assert_eq!(deserialized.when_to_use, Some("Use when building CLIs".to_string()));
}

#[test]
fn test_backward_compatibility_missing_when_to_use() {
    // Old metadata.json without when_to_use field
    let old_json = r#"{"kind":"library","created_at":"2025-01-01T00:00:00Z","updated_at":"2025-01-01T00:00:00Z"}"#;

    let result: Result<ResearchMetadata, _> = serde_json::from_str(old_json);
    assert!(result.is_ok());
    assert_eq!(result.unwrap().when_to_use, None);
}
```

**Regression Test** (for original bug):
```rust
#[test]
fn test_regression_llm_output_with_file_separator_at_start() {
    // Simulate broken LLM output that caused the original bug
    // LLM incorrectly includes "--- FILE: SKILL.md ---" at the start
    let broken_llm_output = r#"--- FILE: SKILL.md ---
---
name: test-lib
description: Test library for regression testing
---

# Test Library

Some content here.

--- FILE: examples.md ---
# Examples

Example content.
"#;

    // After splitting, first file should be SKILL.md (implicit)
    let files = split_into_files(broken_llm_output);
    assert_eq!(files.len(), 2);
    assert_eq!(files[0].0, "SKILL.md");
    assert_eq!(files[1].0, "examples.md");

    // SKILL.md content should NOT contain the file separator
    assert!(!files[0].1.contains("--- FILE:"), "SKILL.md should not contain file separator");

    // SKILL.md should have valid frontmatter
    let (frontmatter, _body) = parse_and_validate_frontmatter(&files[0].1).unwrap();
    assert_eq!(frontmatter.name, "test-lib");
    assert_eq!(frontmatter.description, "Test library for regression testing");
}

#[test]
fn test_whitespace_variations_in_frontmatter() {
    // CRLF line endings
    let content_crlf = "---\r\nname: test\r\ndescription: Test lib\r\n---\r\n\r\n# Content";
    let (fm, _) = parse_and_validate_frontmatter(content_crlf).unwrap();
    assert_eq!(fm.name, "test");

    // Trailing whitespace after ---
    let content_trailing = "---   \nname: test\ndescription: Test lib\n---   \n\n# Content";
    let (fm, _) = parse_and_validate_frontmatter(content_trailing).unwrap();
    assert_eq!(fm.name, "test");

    // Extra blank lines in frontmatter
    let content_blanks = "---\n\nname: test\n\ndescription: Test lib\n\n---\n\n# Content";
    let (fm, _) = parse_and_validate_frontmatter(content_blanks).unwrap();
    assert_eq!(fm.name, "test");
}
```

**Property-based Tests** (OPTIONAL - using proptest):
```rust
#[cfg(test)]
#[cfg(feature = "proptest")]  // Make proptest optional
mod proptests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_frontmatter_roundtrip(
            name in "[a-z-]+",
            description in ".{10,200}"
        ) {
            let frontmatter = SkillFrontmatter {
                name: name.clone(),
                description: description.clone(),
                tools: None,
                last_updated: None,
                hash: None,
            };

            let yaml = serde_yaml::to_string(&frontmatter).unwrap();
            let content = format!("---\n{}---\n\n# Content", yaml);

            let (parsed, _body) = parse_and_validate_frontmatter(&content).unwrap();
            assert_eq!(parsed.name, name);
            assert_eq!(parsed.description, description);
        }
    }
}
```

**Acceptance Criteria:**
- [ ] File `research/lib/tests/skill_validation_test.rs` exists with >150 lines
- [ ] Directory `research/lib/tests/fixtures/skill/` exists with valid/invalid SKILL.md examples
- [ ] Test suite includes 20+ tests covering:
  - Valid frontmatter parsing (minimal: name + description only)
  - Valid frontmatter parsing (with all fields: tools, last_updated, hash)
  - Valid frontmatter parsing (with "allowed-tools" instead of "tools")
  - Missing frontmatter error
  - Unclosed frontmatter error
  - Missing required field: name
  - Missing required field: description
  - Empty field: name
  - Empty field: description
  - Optional fields (tools, last_updated, hash)
  - Invalid YAML syntax
  - metadata.when_to_use serialization
  - metadata.schema_version defaults to 0
  - Backward compatibility (old metadata.json without when_to_use)
  - File splitting: single file (no separators)
  - File splitting: multiple files (2-3 separators)
  - File splitting: LLM output starting with separator (regression test)
  - Whitespace variations (CRLF, trailing spaces, extra blank lines)
  - Integration: full library workflow with validation
  - Property-based (OPTIONAL): frontmatter roundtrip
  - Doc tests in frontmatter.rs (3+ examples)
- [ ] `cargo test` passes all tests (full suite)
- [ ] `cargo test --test skill_validation_test` runs 18+ tests (excluding optional proptest)
- [ ] All tests pass

---

## Cross-Cutting Concerns

### Error Handling

**Strategy**: Use `thiserror` for validation errors, graceful degradation for non-critical failures

**Implementation**:
- Validation errors (FrontmatterError) are logged but don't fail the command
- Users get clear, actionable error messages with file paths
- Tracing logs capture validation success/failure for debugging

**Example Error Message**:
```
⚠️  Warning: SKILL.md frontmatter is invalid
   Missing required field 'description' in frontmatter
   File: /Users/ken/.research/library/test-lib/skill/SKILL.md
   The skill may not activate correctly until this is fixed.
```

### Logging and Observability

**Strategy**: Use existing `tracing` integration for validation events

**Key Log Points**:
- Before SKILL.md generation: Log prompt parameters
- After SKILL.md generation: Log file size, line count
- Validation: Log success/failure with details
- File splitting: Log number of files created
- Metadata update: Log when_to_use field populated

**Log Levels**:
- `info`: Successful operations (validation passed, metadata updated)
- `warn`: Non-critical issues (validation failed but continuing)
- `error`: Critical failures (file write errors, prompt failures)
- `debug`: Detailed info (frontmatter content, split file names)

### Testing Strategy

**Unit Tests**:
- Frontmatter parsing (8+ tests in validation module)
- File splitting logic (edge cases: no separators, empty files)
- Normalization preservation (frontmatter intact after normalization)

**Integration Tests**:
- Full library workflow with validation
- Metadata serialization roundtrip
- Multi-file skill generation

**Property-Based Tests** (proptest):
- Frontmatter YAML roundtrip (generate random valid frontmatter, ensure parsing works)
- File splitting with random separators
- Normalization preserves structure

**Manual Testing**:
- Generate SKILL.md for 3 real libraries (clap, serde, tokio)
- Verify frontmatter is valid YAML
- Verify metadata.when_to_use is populated
- Verify multi-file skills still work

### Backward Compatibility

**ResearchMetadata**:
- `when_to_use` field is `Option<String>`
- Has `#[serde(skip_serializing_if = "Option::is_none")]` attribute
- Old metadata.json files deserialize successfully (when_to_use = None)
- New metadata.json files include when_to_use when present

**SKILL.md Format**:
- New format is valid YAML frontmatter (standard markdown)
- Old format (broken) can be manually fixed by users
- No automatic migration (users can regenerate if needed)

**File Splitting**:
- Multi-file skills continue to work
- Separator detection works with raw content (before normalization)

### Dependencies

**New Crate (Phase 0)**:
- `serde_yaml = "0.9"` - For parsing YAML frontmatter (NOT currently in Cargo.toml, must be added)

**Verify Existing**:
- `serde` with derive feature ✓ (already present)
- `thiserror` for error types ✓ (already present)
- `tracing` for logging ✓ (already present)

### Performance Considerations

**Minimal Overhead**:
- Frontmatter validation is fast (parse ~10 lines of YAML)
- File splitting happens once (not in a loop)
- Normalization still runs (same as before, but preserves frontmatter)

**No Regression**:
- Existing research workflow unchanged
- Parallel prompt execution unchanged
- Only adds validation after SKILL.md write (negligible time)

**Estimated Overhead**: <100ms per library research (validation + metadata update)

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Pre-work | Phase 0 | Add serde_yaml dependency (BLOCKER for Group A) |
| Group A | Phase 1, Phase 2, Phase 3 | Depend only on Phase 0 - can all be developed simultaneously |
| Group B | Phase 4 | Depends on Phase 0, Phase 2 (needs serde_yaml and validation module) |
| Group C | Phase 5 | Depends on Phase 1, 2, 4 (needs all components) |
| Group D | Phase 6 | Depends on all previous phases (testing everything) |

**Implementation Strategy**:
- **Pre-sprint**: Add serde_yaml dependency (5 minutes)
  - Single PR to update Cargo.toml
  - Verify `cargo build` succeeds
- **Sprint 1**: Develop Group A in parallel (3 developers)
  - Developer 1: ResearchMetadata struct changes (Phase 1)
  - Developer 2: Validation module (Phase 2)
  - Developer 3: Prompt improvements (Phase 3)
- **Sprint 2**: Develop Group B (1 developer)
  - Fix file splitting and normalization (Phase 4)
- **Sprint 3**: Develop Group C (1 developer)
  - Integration and metadata population (Phase 5)
- **Sprint 4**: Develop Group D (1 developer or QA)
  - Comprehensive testing (Phase 6)

**Timeline Note**: Implementation steps, not duration estimates

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| LLM still generates invalid frontmatter despite prompt improvements | Medium | Medium | Validation catches this and warns user; can manually fix or regenerate |
| `normalize_markdown()` refactor breaks existing content | High | Low | Comprehensive tests + manual testing on real files before merge |
| Backward compatibility issues with old metadata.json | Medium | Low | Use Option<String> with serde skip_serializing_if; test deserialization |
| File splitting logic regression (multi-file skills break) | Medium | Low | Integration tests + manual testing with multi-file examples |
| Performance regression from validation overhead | Low | Very Low | Validation is fast (YAML parsing); measure before/after |
| serde_yaml dependency conflicts | Low | Very Low | Likely already in Cargo.toml; check versions |

## Open Questions

- [ ] Should we auto-fix invalid frontmatter (e.g., add missing fields with defaults)?
  - **Recommendation**: No - better to warn user and let them regenerate

- [ ] Should `when_to_use` be required or optional in ResearchMetadata?
  - **Recommendation**: Optional - backward compatibility and graceful degradation

- [ ] Should we migrate existing SKILL.md files to new format?
  - **Recommendation**: No automatic migration - users can regenerate if needed

- [ ] Should validation be blocking (fail command) or warning (continue)?
  - **Recommendation**: Warning - don't break user workflow, let them fix later

- [ ] Should we support both `tools` and `allowed-tools` or standardize on one?
  - **Recommendation**: Support both for flexibility, document preferred convention

## Implementation Notes

### File Locations Summary

| File | Purpose | Changes |
|------|---------|---------|
| `research/lib/src/lib.rs` | Main library logic | Add validation module, refactor file splitting, update library command |
| `research/lib/src/validation.rs` | New module | Entry point for validation submodules |
| `research/lib/src/validation/frontmatter.rs` | New module | Frontmatter parsing and validation logic |
| `research/lib/prompts/skill.md` | LLM prompt template | Improve frontmatter instructions and examples |
| `research/lib/tests/skill_validation_test.rs` | New test file | Integration tests for validation workflow |
| `research/lib/Cargo.toml` | Dependencies | Verify serde_yaml is present |

### Key Functions to Implement

1. **Validation Module**:
   - `parse_and_validate_frontmatter(content: &str) -> Result<SkillFrontmatter, FrontmatterError>`
   - `extract_frontmatter(content: &str) -> Option<(String, String)>`

2. **File Processing**:
   - `split_into_files(content: &str) -> Vec<(String, String)>`
   - `normalize_markdown_preserving_frontmatter(content: &str) -> String`

3. **Integration**:
   - Update `research()` function in lib.rs to call validation after SKILL.md write
   - Populate `metadata.when_to_use` from frontmatter.description

### Testing Checklist

Before marking complete:
- [ ] Unit tests pass: `cargo test --lib validation`
- [ ] Integration tests pass: `cargo test --test skill_validation_test`
- [ ] Full test suite passes: `cargo test`
- [ ] Manual test: Generate SKILL.md for clap → frontmatter valid
- [ ] Manual test: Generate SKILL.md for serde → frontmatter valid
- [ ] Manual test: Check metadata.json has `when_to_use` field
- [ ] Manual test: Old metadata.json deserializes successfully
- [ ] Manual test: Multi-file skill (if available) splits correctly

## Success Criteria

This plan is successful when:

1. **SKILL.md files have valid YAML frontmatter**:
   - Start with `---` on line 1
   - Contain `name` and `description` fields
   - Optionally contain `tools` or `allowed_tools` array
   - Close with `---`

2. **Validation provides clear feedback**:
   - Invalid frontmatter is detected
   - Error messages are actionable
   - Users know exactly what to fix

3. **Metadata captures when-to-use guidance**:
   - `when_to_use` field populated from skill description
   - Backward compatible with old metadata files
   - Serialization/deserialization works

4. **No regressions**:
   - Existing library research still works
   - Multi-file skills still split correctly
   - Performance is maintained
   - All tests pass

5. **Developer experience improved**:
   - Clear error messages
   - Easy to debug validation failures
   - Good test coverage for future changes
