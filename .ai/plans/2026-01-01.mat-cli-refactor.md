# Mat CLI Refactor

**Created:** 2026-01-01
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Refactor the `mat` CLI from a subcommand-based interface to a direct file-first interface with optional flags, align the theme system with the documented `ThemePair` strategy, and ensure prose/code block highlighting follows the theme-strategy document. This includes implementing stdin support, theme listing, and frontmatter manipulation commands.

## Review Summary

**Reviews Completed:** 2026-01-01

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. Changed `From<&str>` to `TryFrom<&str>` for ThemePair with proper error handling, plus convenience `from_str_or_default()` method
2. Added `atty` crate dependency for reliable stdin TTY detection
3. Added clap `ArgGroup` for mutually exclusive output flags
4. Use `std::sync::OnceLock` instead of `lazy_static` for `CODE_THEME_LOOKUP`
5. Added property-based tests (proptest) for theme parsing roundtrips
6. Added snapshot tests (insta) for ANSI/HTML output validation
7. Added test fixtures directory structure
8. Specified ScopeStack management using functional style (no mutation, compute on-demand)
9. Added terminal reset `\x1b[0m` to end of output
10. Added explicit handling for documents without frontmatter

**Resolved Open Questions:**

1. `--fm-defaults` color-coding: Inherit from theme's prose colors for consistency
2. `--show-html` blocking: Return immediately (non-blocking, standard CLI behavior)
3. `--output` flag: Skip it - use shell redirection (idiomatic Unix)

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Remove subcommands; use `mat <filename> [options]` syntax | High | Rust Developer |
| FR-2 | Default behavior: render markdown to terminal with prose formatting (no background) | High | Rust Developer |
| FR-3 | Support stdin input when no filename provided (`cat foo.md \| mat`) | High | Rust Developer |
| FR-4 | `--theme <name>` flag to select prose ThemePair | High | Rust Developer |
| FR-5 | `--code-theme <name>` flag to override derived code theme | Medium | Rust Developer |
| FR-6 | `--list-themes` flag to display available theme pairs with descriptions | High | Rust Developer |
| FR-7 | Implement `TryFrom<&str>` for `ThemePair` with kebab-case parsing and proper errors | High | Rust Developer |
| FR-8 | `--clean` flag to cleanup document and output to stdout | Medium | Rust Developer |
| FR-9 | `--clean-save` flag to cleanup and save back to file | Medium | Rust Developer |
| FR-10 | `--fm-merge-with <JSON>` flag to merge JSON into frontmatter (JSON wins) | Medium | Rust Developer |
| FR-11 | `--fm-defaults <JSON>` flag to set default frontmatter (document wins) | Medium | Rust Developer |
| FR-12 | `--html` flag to output HTML to stdout | Medium | Rust Developer |
| FR-13 | `--show-html` flag to generate HTML, save to temp file, open in browser (non-blocking) | Low | Rust Developer |
| FR-14 | `--ast` flag to output MDAST JSON representation | Low | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Theme selection follows documented strategy (ENV → explicit override) | Compliance | Rust Developer |
| NFR-2 | Code block theme derived from prose theme via lookup table | Compliance | Rust Developer |
| NFR-3 | Terminal prose uses theme colors but NOT background color | Compliance | Rust Developer |
| NFR-4 | HTML output includes both light/dark mode styling | Compliance | Rust Developer |
| NFR-5 | `ThemePair::description()` output matches documented format | Compliance | Rust Developer |

## Architecture Overview

The refactor touches three main areas:

1. **CLI Layer (`mat/src/main.rs`)** - Complete rewrite from subcommand to flag-based interface
2. **Theme System (`shared/src/markdown/highlighting/themes.rs`)** - Add `TryFrom<&str>` trait, fix `description()` output format, add `CODE_THEME_LOOKUP`
3. **Terminal Output (`shared/src/markdown/output/terminal.rs`)** - Implement prose highlighting without background colors

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        mat CLI                                   │
│  ┌──────────────┐  ┌─────────────┐  ┌────────────────────────┐  │
│  │ Arg Parser   │  │ Input       │  │ Output                 │  │
│  │ (clap)       │──│ Handler     │──│ Router                 │  │
│  │ + ArgGroups  │  │ file/stdin  │  │ term/html/ast/clean    │  │
│  └──────────────┘  └─────────────┘  └────────────────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────┴────────────────────────────────────┐
│                      shared library                              │
│  ┌──────────────────┐  ┌───────────────┐  ┌──────────────────┐  │
│  │ Markdown struct  │  │ highlighting/ │  │ output/          │  │
│  │ - cleanup()      │  │ - ThemePair   │  │ - terminal       │  │
│  │ - fm_merge_with  │  │ - Theme       │  │ - html           │  │
│  │ - fm_defaults    │  │ - load_theme  │  │ - ast            │  │
│  │ - as_string()    │  │ - ScopeCache  │  │ - string         │  │
│  │ - has_frontmatter│  │ - ProseHigh.  │  │                  │  │
│  └──────────────────┘  └───────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

1. **Input**: File path or stdin (with `atty` TTY detection) → `Markdown` struct
2. **Theme Resolution**: ENV vars → CLI flags → defaults → `ThemePair` → `Theme`
3. **Code Theme Derivation**: `CODE_THEME_LOOKUP[prose_theme]` unless `--code-theme` specified
4. **Rendering**: Based on flags, route to terminal/html/ast/string output
5. **Terminal Reset**: Always emit `\x1b[0m` at end of terminal output

## Phases

### Phase 1: Theme System Fixes

**Principal Owner:** Rust Developer

**Goal:** Align `ThemePair` with the documented design, including `TryFrom<&str>` trait, proper description format, and `CODE_THEME_LOOKUP` table.

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib highlighting`

**Files to create/modify:**
- `shared/src/markdown/highlighting/themes.rs` - Add `TryFrom<&str>`, `from_str_or_default()`, fix `description()`, add `CODE_THEME_LOOKUP`

**Deliverables:**
- `InvalidThemeName` error type with helpful error message listing valid theme names
- `impl TryFrom<&str> for ThemePair` with kebab-case parsing (e.g., "one-half" → `ThemePair::OneHalf`)
- `ThemePair::from_str_or_default(&str) -> ThemePair` convenience method (defaults to OneHalf)
- `CODE_THEME_LOOKUP` using `std::sync::OnceLock` (not lazy_static)
- Fix `ThemePair::description()` to return formatted output per docs (lines 152-162 of themes.md)
- Add `ThemePair::kebab_name(self) -> &'static str` (const fn) for reverse mapping

**Technical Details:**
```rust
use std::convert::TryFrom;

#[derive(Debug, Clone)]
pub struct InvalidThemeName(pub String);

impl std::error::Error for InvalidThemeName {}
impl std::fmt::Display for InvalidThemeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Invalid theme name: '{}'. Valid names: github, one-half, base16-ocean, gruvbox, solarized, nord, dracula, monokai, vs-dark", self.0)
    }
}

impl TryFrom<&str> for ThemePair {
    type Error = InvalidThemeName;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        match s.to_lowercase().replace('_', "-").as_str() {
            "github" => Ok(ThemePair::Github),
            "base-16-ocean" | "base16-ocean" => Ok(ThemePair::Base16Ocean),
            "gruvbox" => Ok(ThemePair::Gruvbox),
            "one-half" | "onehalf" => Ok(ThemePair::OneHalf),
            "solarized" => Ok(ThemePair::Solarized),
            "nord" => Ok(ThemePair::Nord),
            "dracula" => Ok(ThemePair::Dracula),
            "monokai" => Ok(ThemePair::Monokai),
            "visual-studio-dark" | "vs-dark" => Ok(ThemePair::VisualStudioDark),
            _ => Err(InvalidThemeName(s.to_string())),
        }
    }
}

impl ThemePair {
    pub fn from_str_or_default(s: &str) -> Self {
        Self::try_from(s).unwrap_or(ThemePair::OneHalf)
    }

    pub const fn kebab_name(self) -> &'static str {
        match self {
            ThemePair::Github => "github",
            ThemePair::Base16Ocean => "base16-ocean",
            ThemePair::Gruvbox => "gruvbox",
            ThemePair::OneHalf => "one-half",
            ThemePair::Solarized => "solarized",
            ThemePair::Nord => "nord",
            ThemePair::Dracula => "dracula",
            ThemePair::Monokai => "monokai",
            ThemePair::VisualStudioDark => "vs-dark",
        }
    }
}

// Use OnceLock instead of lazy_static
use std::sync::OnceLock;
use std::collections::HashMap;

fn code_theme_lookup() -> &'static HashMap<ThemePair, ThemePair> {
    static LOOKUP: OnceLock<HashMap<ThemePair, ThemePair>> = OnceLock::new();
    LOOKUP.get_or_init(|| {
        let mut map = HashMap::new();
        map.insert(ThemePair::OneHalf, ThemePair::Monokai);
        map.insert(ThemePair::Base16Ocean, ThemePair::Github);
        map.insert(ThemePair::Github, ThemePair::Monokai);
        map.insert(ThemePair::Gruvbox, ThemePair::Github);
        map.insert(ThemePair::Solarized, ThemePair::Github);
        map.insert(ThemePair::Nord, ThemePair::Github);
        map.insert(ThemePair::Dracula, ThemePair::Github);
        map.insert(ThemePair::Monokai, ThemePair::Monokai); // Self-reference
        map.insert(ThemePair::VisualStudioDark, ThemePair::Monokai);
        map
    })
}
```

**Acceptance Criteria:**
- [ ] `ThemePair::try_from("one-half")` returns `Ok(ThemePair::OneHalf)`
- [ ] `ThemePair::try_from("unknown")` returns `Err(InvalidThemeName("unknown"))`
- [ ] `ThemePair::from_str_or_default("unknown")` returns `ThemePair::OneHalf`
- [ ] `code_theme_lookup()` exists with all 9 ThemePair mappings
- [ ] `ThemePair::Github.description(ColorMode::Dark)` returns properly formatted string
- [ ] `ThemePair::kebab_name()` is const and returns correct kebab-case names
- [ ] Proptest: `ThemePair::try_from(pair.kebab_name()) == Ok(pair)` for all variants
- [ ] Proptest: case-insensitive parsing works ("GitHub", "github", "GITHUB")
- [ ] `cargo test -p shared --lib highlighting` passes with 15+ new tests
- [ ] Doc tests for `TryFrom`, `from_str_or_default`, and `kebab_name`

---

### Phase 2: Theme Environment Variable Support

**Principal Owner:** Rust Developer

**Goal:** Implement environment variable detection for theme selection per the theme-strategy document.

**Dependencies:** Phase 1

**Blast Radius:** `cargo test -p shared --lib highlighting`

**Files to create/modify:**
- `shared/src/markdown/highlighting/themes.rs` - Add env var detection functions
- `shared/src/markdown/highlighting/mod.rs` - Export new functions

**Deliverables:**
- `fn detect_prose_theme() -> ThemePair` - checks `THEME` env var, defaults to OneHalf
- `fn detect_code_theme(prose_theme: ThemePair) -> ThemePair` - checks `CODE_THEME` env var, falls back to lookup table
- `fn detect_color_mode() -> ColorMode` - checks `COLORFGBG` env var or uses `termbg` crate for terminal detection

**Technical Details:**
```rust
pub fn detect_prose_theme() -> ThemePair {
    std::env::var("THEME")
        .ok()
        .map(|s| ThemePair::from_str_or_default(&s))
        .unwrap_or(ThemePair::OneHalf)
}

pub fn detect_code_theme(prose_theme: ThemePair) -> ThemePair {
    std::env::var("CODE_THEME")
        .ok()
        .map(|s| ThemePair::from_str_or_default(&s))
        .unwrap_or_else(|| {
            code_theme_lookup()
                .get(&prose_theme)
                .copied()
                .unwrap_or(ThemePair::Monokai)
        })
}

pub fn detect_color_mode() -> ColorMode {
    // Check NO_COLOR first (respect user preference)
    if std::env::var("NO_COLOR").is_ok() {
        return ColorMode::Dark; // Fallback for no-color mode
    }

    // Check COLORFGBG (format: "fg;bg" where bg < 7 is dark)
    if let Ok(colorfgbg) = std::env::var("COLORFGBG") {
        if let Some(bg) = colorfgbg.split(';').last() {
            if let Ok(bg_num) = bg.parse::<u8>() {
                return if bg_num < 7 { ColorMode::Dark } else { ColorMode::Light };
            }
        }
    }

    // Default to dark mode (more common in terminal environments)
    ColorMode::Dark
}
```

**Acceptance Criteria:**
- [ ] `detect_prose_theme()` returns `ThemePair::Github` when `THEME=github` is set
- [ ] `detect_prose_theme()` returns `ThemePair::OneHalf` when `THEME` is unset
- [ ] `detect_prose_theme()` returns `ThemePair::OneHalf` when `THEME=invalid` (uses from_str_or_default)
- [ ] `detect_code_theme(ThemePair::OneHalf)` returns `ThemePair::Monokai` per lookup table
- [ ] `detect_code_theme()` respects `CODE_THEME` env var override
- [ ] `detect_color_mode()` parses `COLORFGBG` correctly
- [ ] 8+ tests covering env var scenarios (use `serial_test::serial` and `ScopedEnv` helper)
- [ ] Doc tests for all public detection functions

---

### Phase 3: Prose Highlighting Infrastructure

**Principal Owner:** Rust Developer

**Goal:** Implement the scope-mapping approach for prose highlighting as documented in highlighting-the-prose.md.

**Dependencies:** Phase 1

**Blast Radius:** `cargo test -p shared --lib markdown::highlighting`

**Files to create/modify:**
- `shared/src/markdown/highlighting/scope_cache.rs` - Add ScopeCache struct per design doc
- `shared/src/markdown/highlighting/prose.rs` (NEW) - ProseHighlighter implementation
- `shared/src/markdown/highlighting/mod.rs` - Export new modules

**Deliverables:**
- `ScopeCache` struct with pre-parsed syntect scopes (use `expect()` for hardcoded strings)
- `ProseHighlighter` using functional style (no ScopeStack mutation, compute styles on-demand)
- `style_for_tag()` that takes parent scopes and computes style without mutation

**Technical Details:**
```rust
// scope_cache.rs
use syntect::parsing::Scope;

pub struct ScopeCache {
    pub base: Scope,
    pub heading: Scope,
    pub bold: Scope,
    pub italic: Scope,
    pub quote: Scope,
    pub link: Scope,
    pub code_inline: Scope,
    pub list: Scope,
}

impl ScopeCache {
    pub fn new() -> Self {
        Self {
            base: Scope::new("text.html.markdown")
                .expect("Invalid hardcoded scope: text.html.markdown"),
            heading: Scope::new("markup.heading.markdown")
                .expect("Invalid hardcoded scope: markup.heading.markdown"),
            bold: Scope::new("markup.bold.markdown")
                .expect("Invalid hardcoded scope: markup.bold.markdown"),
            italic: Scope::new("markup.italic.markdown")
                .expect("Invalid hardcoded scope: markup.italic.markdown"),
            quote: Scope::new("markup.quote.markdown")
                .expect("Invalid hardcoded scope: markup.quote.markdown"),
            link: Scope::new("markup.underline.link.markdown")
                .expect("Invalid hardcoded scope: markup.underline.link.markdown"),
            code_inline: Scope::new("markup.raw.inline.markdown")
                .expect("Invalid hardcoded scope: markup.raw.inline.markdown"),
            list: Scope::new("markup.list.markdown")
                .expect("Invalid hardcoded scope: markup.list.markdown"),
        }
    }

    pub fn scope_for_tag(&self, tag: &Tag) -> Option<Scope> {
        match tag {
            Tag::Heading { .. } => Some(self.heading),
            Tag::Strong => Some(self.bold),
            Tag::Emphasis => Some(self.italic),
            Tag::BlockQuote(_) => Some(self.quote),
            Tag::Link { .. } => Some(self.link),
            Tag::List(_) => Some(self.list),
            _ => None,
        }
    }
}

// prose.rs - Functional style, no ScopeStack mutation
use syntect::highlighting::{Highlighter, Style, Theme as SyntectTheme};
use pulldown_cmark::Tag;

pub struct ProseHighlighter<'a> {
    theme: &'a SyntectTheme,
    scope_cache: ScopeCache,
    highlighter: Highlighter<'a>,
}

impl<'a> ProseHighlighter<'a> {
    pub fn new(theme: &'a SyntectTheme) -> Self {
        Self {
            theme,
            scope_cache: ScopeCache::new(),
            highlighter: Highlighter::new(theme),
        }
    }

    /// Returns the style for a tag, given the current parent scope stack.
    /// Uses functional style - does not mutate any state.
    pub fn style_for_tag(&self, tag: &Tag, parent_scopes: &[Scope]) -> Style {
        let mut stack_vec: Vec<Scope> = parent_scopes.to_vec();

        if let Some(scope) = self.scope_cache.scope_for_tag(tag) {
            stack_vec.push(scope);
        }

        self.highlighter.style_for_stack(&stack_vec)
    }

    /// Returns the base scope for the document
    pub fn base_scope(&self) -> Scope {
        self.scope_cache.base
    }
}
```

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/highlighting/scope_cache.rs` exists with >60 lines
- [ ] File `shared/src/markdown/highlighting/prose.rs` exists with >80 lines
- [ ] `ScopeCache::new()` creates valid pre-parsed scopes (panics with helpful message on invalid)
- [ ] `ScopeCache::scope_for_tag()` returns correct scopes for heading, bold, italic, quote, link, list
- [ ] `ProseHighlighter::style_for_tag()` returns valid styles without mutating any state
- [ ] `ProseHighlighter::new()` initialization takes <1ms (benchmark in tests)
- [ ] 10+ tests covering scope mapping for all tag types
- [ ] Doc tests for `ScopeCache` and `ProseHighlighter`

---

### Phase 4: Terminal Output with Prose Highlighting

**Principal Owner:** Rust Developer

**Goal:** Update terminal output to use prose highlighting for non-code content, without background colors for prose.

**Dependencies:** Phase 3

**Blast Radius:** `cargo test -p shared --lib output::terminal`

**Files to create/modify:**
- `shared/src/markdown/output/terminal.rs` - Integrate ProseHighlighter, remove background for prose

**Deliverables:**
- Terminal output applies theme colors to prose (headings, bold, italic, links, etc.)
- Prose text does NOT have background color (no `\x1b[48;2` codes)
- Code blocks retain background color
- `TerminalOptions` uses `detect_prose_theme()` and `detect_code_theme()` for defaults
- Always emit `\x1b[0m` reset at end of output
- Helper functions: `emit_prose_text()` and `emit_code_text()` for separation of concerns

**Technical Details:**
```rust
/// Emits prose text with foreground color only (no background)
fn emit_prose_text(text: &str, style: Style) -> String {
    let fg = style.foreground;
    format!("\x1b[38;2;{};{};{}m{}\x1b[0m", fg.r, fg.g, fg.b, text)
}

/// Emits code text with both foreground and background colors
fn emit_code_text(text: &str, style: Style, bg_color: Color) -> String {
    let fg = style.foreground;
    format!(
        "\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m{}\x1b[0m",
        bg_color.r, bg_color.g, bg_color.b,
        fg.r, fg.g, fg.b,
        text
    )
}

// In for_terminal():
// 1. Create ProseHighlighter alongside CodeHighlighter
// 2. Track scope stack as Vec<Scope> (not ScopeStack mutation)
// 3. Use emit_prose_text() for prose events
// 4. Use emit_code_text() for code block content
// 5. Emit \x1b[0m at the very end of output
```

**Acceptance Criteria:**
- [ ] `for_terminal()` renders headings with theme foreground color
- [ ] `for_terminal()` renders **bold** text with theme styling
- [ ] `for_terminal()` renders *italic* text with theme styling
- [ ] `for_terminal()` renders links with theme styling
- [ ] Prose output does NOT contain `\x1b[48;2` (background color) ANSI codes
- [ ] Code blocks still have `\x1b[48;2` (background color) ANSI codes
- [ ] Output ends with `\x1b[0m` reset code
- [ ] `strip_ansi_codes(output)` for prose matches source content
- [ ] Insta snapshot tests for ANSI output of all ThemePair variants
- [ ] Insta snapshot test verifying prose has no background codes
- [ ] 12+ tests for prose highlighting scenarios
- [ ] ColorDepth::None still returns plain text (no ANSI codes)

---

### Phase 5: CLI Refactor - Remove Subcommands

**Principal Owner:** Rust Developer

**Goal:** Refactor CLI from subcommand-based to flag-based interface with `mat <filename> [options]`.

**Dependencies:** Phase 2

**Blast Radius:** `cargo test -p mat` (all mat tests)

**Files to create/modify:**
- `mat/src/main.rs` - Complete rewrite of CLI argument structure
- `mat/Cargo.toml` - Add `atty` and `assert_cmd` dependencies

**Deliverables:**
- Remove `Commands` enum entirely
- `input` becomes optional (None = stdin, with atty TTY detection)
- Add all flags with `ArgGroup` for mutually exclusive output modes
- Default behavior (no flags) renders to terminal

**Technical Details:**
```rust
use clap::{Parser, ArgGroup};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "mat", about = "Markdown Awesome Tool", version)]
#[command(group = ArgGroup::new("output-mode")
    .args(["html", "show_html", "ast", "clean", "clean_save"])
    .multiple(false))]
struct Cli {
    /// Input file path (reads from stdin if not provided)
    input: Option<PathBuf>,

    /// Theme for prose content (kebab-case name)
    #[arg(long, value_parser = parse_theme_name)]
    theme: Option<ThemePair>,

    /// Theme for code blocks (overrides derived theme)
    #[arg(long, value_parser = parse_theme_name)]
    code_theme: Option<ThemePair>,

    /// List available themes
    #[arg(long)]
    list_themes: bool,

    /// Clean up markdown formatting
    #[arg(long, group = "output-mode")]
    clean: bool,

    /// Clean up and save back to file
    #[arg(long, group = "output-mode")]
    clean_save: bool,

    /// Output as HTML
    #[arg(long, group = "output-mode")]
    html: bool,

    /// Generate HTML and open in browser
    #[arg(long, group = "output-mode")]
    show_html: bool,

    /// Output MDAST JSON
    #[arg(long, group = "output-mode")]
    ast: bool,

    /// Merge JSON into frontmatter (JSON wins on conflicts)
    #[arg(long, value_name = "JSON")]
    fm_merge_with: Option<String>,

    /// Set default frontmatter values (document wins on conflicts)
    #[arg(long, value_name = "JSON")]
    fm_defaults: Option<String>,
}

fn parse_theme_name(s: &str) -> Result<ThemePair, String> {
    ThemePair::try_from(s).map_err(|e| e.to_string())
}

fn load_markdown(path: Option<&PathBuf>) -> Result<Markdown> {
    use atty::Stream;

    if let Some(p) = path {
        if p.to_str() == Some("-") {
            // Explicit stdin marker
            read_from_stdin()
        } else {
            Markdown::try_from(p.as_path())
                .wrap_err_with(|| format!("Failed to read file: {:?}", p))
        }
    } else {
        // No path provided - check if stdin has data
        if atty::is(Stream::Stdin) {
            // Interactive terminal - no input available
            Err(eyre!("No input file provided. Use `mat --help` for usage."))
        } else {
            // Piped input available
            read_from_stdin()
        }
    }
}

fn read_from_stdin() -> Result<Markdown> {
    let mut buffer = String::new();
    std::io::stdin().read_to_string(&mut buffer)
        .wrap_err("Failed to read from stdin")?;
    Ok(buffer.into())
}
```

**Acceptance Criteria:**
- [ ] `mat foo.md` renders to terminal (default)
- [ ] `mat --help` shows all flags without subcommands
- [ ] `mat -` reads from stdin explicitly
- [ ] `echo "# Test" | mat` works (piped stdin mode)
- [ ] `mat` with no args and no stdin produces helpful error
- [ ] `mat --html --ast foo.md` produces clap error (conflicting flags)
- [ ] `mat --clean --html foo.md` produces clap error (conflicting flags)
- [ ] `mat --clean-save` without file produces error
- [ ] `mat --theme invalid foo.md` produces error with valid theme list
- [ ] `cargo build -p mat` succeeds
- [ ] 10+ integration tests for CLI interface using `assert_cmd`
- [ ] Test fixture files in `mat/tests/fixtures/` directory

---

### Phase 6: CLI Feature Implementation

**Principal Owner:** Rust Developer

**Goal:** Implement all CLI flag behaviors.

**Dependencies:** Phase 4, Phase 5

**Blast Radius:** `cargo test -p mat`

**Files to create/modify:**
- `mat/src/main.rs` - Implement each flag's behavior

**Deliverables:**
- `--list-themes` outputs theme pairs with descriptions
- `--theme` overrides detected prose theme (with clap validation)
- `--code-theme` overrides derived code theme (with clap validation)
- `--clean` outputs cleaned markdown to stdout
- `--clean-save` saves cleaned markdown back to file
- `--html` outputs HTML to stdout
- `--show-html` saves HTML to temp file and opens in default browser (non-blocking, graceful error handling)
- `--ast` outputs MDAST JSON
- `--fm-merge-with` merges JSON into frontmatter (JSON wins), creates frontmatter if missing
- `--fm-defaults` sets default frontmatter values (document wins), creates frontmatter if missing

**Technical Details:**
```rust
fn main() -> Result<()> {
    color_eyre::install()?;
    let cli = Cli::parse();

    // Handle --list-themes first (no input needed)
    if cli.list_themes {
        list_themes();
        return Ok(());
    }

    // Load markdown from input or stdin
    let mut md = load_markdown(cli.input.as_ref())?;

    // Handle frontmatter operations
    if let Some(json) = &cli.fm_merge_with {
        let data: serde_json::Value = serde_json::from_str(json)
            .wrap_err("Invalid JSON in --fm-merge-with argument")?;

        if !md.frontmatter().has_data() {
            // Create new frontmatter from JSON
            md.frontmatter_mut().set_from_json(&data)?;
        } else {
            md.fm_merge_with(&data, MergeStrategy::PreferNew)?;
        }

        // Output YAML frontmatter to stdout
        println!("{}", md.frontmatter().to_yaml()?);
        return Ok(());
    }

    if let Some(json) = &cli.fm_defaults {
        let data: serde_json::Value = serde_json::from_str(json)
            .wrap_err("Invalid JSON in --fm-defaults argument")?;
        md.fm_set_defaults(&data)?;
        // Output YAML with color coding (inherit from theme colors)
        output_frontmatter_diff(&md)?;
        return Ok(());
    }

    // Handle clean operations
    if cli.clean {
        md.cleanup();
        println!("{}", md.as_string());
        return Ok(());
    }

    if cli.clean_save {
        let path = cli.input
            .ok_or_else(|| eyre!("--clean-save requires a file path, not stdin"))?;
        md.cleanup();
        std::fs::write(&path, md.as_string())
            .wrap_err_with(|| format!("Failed to write to {:?}", path))?;
        eprintln!("Saved cleaned content to {:?}", path);
        return Ok(());
    }

    // Resolve themes
    let prose_theme = cli.theme.unwrap_or_else(detect_prose_theme);
    let code_theme = cli.code_theme.unwrap_or_else(|| detect_code_theme(prose_theme));

    // Handle output modes
    if cli.ast {
        let ast = md.as_ast()?;
        println!("{}", serde_json::to_string_pretty(&ast)?);
        return Ok(());
    }

    if cli.html {
        let options = HtmlOptions {
            prose_theme,
            code_theme,
            ..Default::default()
        };
        let html = md.as_html(options)?;
        println!("{}", html);
        return Ok(());
    }

    if cli.show_html {
        let options = HtmlOptions {
            prose_theme,
            code_theme,
            ..Default::default()
        };
        let html = md.as_html(options)?;
        let temp_path = std::env::temp_dir().join("mat-preview.html");
        std::fs::write(&temp_path, &html)
            .wrap_err("Failed to write temp HTML file")?;

        // Non-blocking open, graceful error handling
        if let Err(e) = open::that(&temp_path) {
            eprintln!("Failed to open browser: {}", e);
            eprintln!("Preview available at: {}", temp_path.display());
        }
        return Ok(());
    }

    // Default: render to terminal
    let options = TerminalOptions {
        prose_theme,
        code_theme,
        ..Default::default()
    };
    let output = for_terminal(&md, options)?;
    println!("{}", output);

    Ok(())
}

fn list_themes() {
    println!("Available themes:");
    println!();
    for theme_pair in ThemePair::all() {
        println!("  {} - {}",
            theme_pair.kebab_name(),
            theme_pair.description(ColorMode::Dark)
        );
    }
}
```

**Acceptance Criteria:**
- [ ] `mat --list-themes` shows all 9 theme pairs with proper formatting
- [ ] `mat --theme github foo.md` uses GitHub theme
- [ ] `mat --code-theme monokai foo.md` overrides derived code theme
- [ ] `mat --clean foo.md` outputs cleaned content to stdout
- [ ] `mat --clean-save foo.md` modifies file in place and prints confirmation
- [ ] `mat --html foo.md` outputs valid HTML with syntax highlighting
- [ ] `mat --show-html foo.md` creates temp file and attempts to open browser
- [ ] `mat --show-html foo.md` prints temp file path if browser open fails
- [ ] `mat --ast foo.md` outputs valid MDAST JSON
- [ ] `mat --fm-merge-with '{"key":"val"}' foo.md` outputs merged YAML
- [ ] `mat --fm-merge-with` creates frontmatter if document has none
- [ ] `mat --fm-defaults '{"key":"val"}' foo.md` outputs YAML with color coding
- [ ] `mat --fm-defaults` creates frontmatter if document has none
- [ ] Invalid JSON in `--fm-merge-with` produces helpful error
- [ ] Invalid JSON in `--fm-defaults` produces helpful error
- [ ] Insta snapshot tests for HTML output
- [ ] 18+ tests covering all flag behaviors

---

## Test Fixtures

Create `mat/tests/fixtures/` directory with sample markdown files:

| File | Purpose |
|------|---------|
| `simple.md` | Basic heading and paragraph |
| `code-blocks.md` | Multiple languages with titles, line numbers |
| `with-frontmatter.md` | YAML frontmatter test data |
| `without-frontmatter.md` | No frontmatter (for fm-merge/defaults tests) |
| `edge-cases.md` | Empty code blocks, nested structures |
| `all-themes.md` | Content to test all prose highlighting scenarios |

---

## Blast Radius Analysis

| Phase | Blast Radius | Reason |
|-------|--------------|--------|
| Phase 1 | `cargo test -p shared --lib highlighting` | Theme system changes |
| Phase 2 | `cargo test -p shared --lib highlighting` | Theme env var changes |
| Phase 3 | `cargo test -p shared --lib markdown::highlighting` | New highlighting module |
| Phase 4 | `cargo test -p shared --lib output::terminal` | Terminal output changes |
| Phase 5 | `cargo test -p mat` | CLI structure changes |
| Phase 6 | `cargo test -p mat` | CLI behavior changes |

---

## Cross-Cutting Concerns

### Testing Strategy
- Unit tests: `#[cfg(test)] mod tests` blocks in each module
- Integration tests: `mat/tests/` directory for CLI end-to-end tests
- Use `serial_test::serial` for environment variable tests
- Use `ScopedEnv` helper (from shared/src/providers/base.rs) for RAII env cleanup
- Use `assert_cmd` crate for CLI testing
- Snapshot tests with `insta` for ANSI and HTML output validation
- Property tests with `proptest` for theme parsing roundtrips
- Test fixtures in `mat/tests/fixtures/` for consistent test data
- Doc tests for all public APIs

### Dependencies to Add

**mat/Cargo.toml:**
```toml
[dependencies]
atty = "0.2"
open = "5"

[dev-dependencies]
assert_cmd = "2"
predicates = "3"
insta = "1"
proptest = "1"
```

**shared/Cargo.toml:**
```toml
[dev-dependencies]
insta = "1"
proptest = "1"
```

### Error Handling
- All errors use `color_eyre` for nice CLI output with `.wrap_err()` context
- Library errors use `thiserror` via `MarkdownError`
- Theme parsing returns `Result` with `InvalidThemeName` error (helpful message)
- JSON parsing errors include the invalid JSON in the message
- Browser open failures print path as fallback

### Performance Considerations
- `ScopeCache` avoids parsing scope strings in hot loops
- `code_theme_lookup()` uses `OnceLock` for one-time initialization
- `ProseHighlighter::new()` initialization <1ms (benchmark verified)
- Terminal output pre-allocates string buffers
- Functional style for ScopeStack avoids mutation overhead

---

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1, Phase 2 | Independent theme system work |
| Group B | Phase 3 | Depends on Phase 1 for ThemePair |
| Group C | Phase 4, Phase 5 | Parallel - terminal output + CLI structure |
| Group D | Phase 6 | Depends on all prior phases |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────────────────────►

Group A: ████████████████ (Phase 1 + Phase 2 in parallel)
                        │
Group B:                └──████████ (Phase 3)
                                  │
Group C:                          └──████████████████ (Phase 4 + Phase 5)
                                                    │
Group D:                                            └──████████ (Phase 6)
```

### Synchronization Points

1. **After Group A:** ThemePair traits and env var detection must be finalized
2. **After Group B:** ProseHighlighter and ScopeCache must be ready for terminal integration
3. **After Group C:** Both terminal output and CLI structure ready for feature implementation
4. **Final:** Full integration testing across all phases

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Scope mapping doesn't match themes | High | Insta snapshot tests with multiple themes, visual verification |
| Stdin detection breaks on some platforms | Medium | Use `atty` crate for reliable cross-platform TTY detection |
| Browser opening fails | Low | Graceful error message, print temp file path |
| ThemePair parsing breaks existing users | Medium | Use TryFrom with helpful errors, from_str_or_default for env vars |
| ScopeStack API changes in syntect | Low | Use functional style (no mutation), less dependent on internal API |
| Terminal reset codes not applied | Low | Always emit `\x1b[0m` at end, verify in tests |

---

## Implementation Notes

### From Review Feedback

1. **ScopeStack Safety**: Use functional style - compute styles on-demand without mutating ScopeStack. Pass parent scopes as `&[Scope]` slice.

2. **Terminal Reset**: Always emit `\x1b[0m` at the end of `for_terminal()` output to reset terminal state.

3. **Frontmatter Edge Cases**: Handle documents without frontmatter in `--fm-merge-with` and `--fm-defaults` by creating frontmatter block.

4. **Browser Open Failure**: Print temp file path when `open::that()` fails, don't panic.

5. **Color Depth Respect**: When `ColorDepth::None`, return plain text without any ANSI codes.

6. **NO_COLOR Support**: Check `NO_COLOR` env var in `detect_color_mode()` per https://no-color.org.

### Code Quality

- No `unwrap()` in production code - use `?`, `expect()` with context, or `wrap_err()`
- All public APIs have rustdoc with examples
- Clippy warnings are errors (`#![deny(clippy::all)]`)
- Format with `cargo fmt` before committing

