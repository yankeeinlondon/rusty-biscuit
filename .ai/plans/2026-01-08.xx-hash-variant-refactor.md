---
status: "ready"
started_at: null
finished_at: null
duration: null
tts_gender: male
requirements: |
  Refactor the xx_hash module to consolidate deprecated functions into a single
  `xx_hash_variant()` function that accepts a vector of `HashVariant` enums.

  ## Goals
  - Replace `xx_hash_trimmed`, `xx_hash_normalized`, and `xx_hash_semantic` with `xx_hash_variant()`
  - Implement all `HashVariant` enum variants with defined application order
  - Maintain backward compatibility during migration
  - Update all callers to use the new API
  - Delete deprecated functions after migration

  ## Review Findings Incorporated
  - CRITICAL: Fixed semantic mapping (was incorrectly including InteriorWhitespace)
  - HIGH: README.md documentation bug (swapped Leading/Trailing descriptions)
  - HIGH: Defined variant application order
  - HIGH: Phase 4 parallelization enabled
  - MEDIUM: Added backward compatibility tests

required_skills:
  - rust
important_skills: []
subagents:
  rust-developer: Implementation (Sonnet)
  feature-tester-rust: Test coverage (Sonnet)
monorepo_modules_impacted:
  - shared
completeness_changes: []
concurrency_changes:
  - "Phase 4 can parallelize 3 independent file migrations"
detail_changes: []
lessons_learned_count: 0
---

# xx_hash_variant Refactoring Plan

## Summary

7 phases to consolidate deprecated hash functions into a unified `xx_hash_variant()` API.

| Phase | Name | Subagent | Complexity | Dependencies | Parallelizable |
|-------|------|----------|------------|--------------|----------------|
| 1 | Core Implementation | rust-developer | Medium | None | No |
| 2 | Unit Tests | feature-tester-rust | Medium | 1 | No |
| 3 | Delete Invalid Comparison | rust-developer | Low | 2 | No |
| 4 | Migrate Callers | rust-developer | Low | 2 | Yes (3 parallel tasks) |
| 5 | Delete Deprecated Functions | rust-developer | Low | 3, 4 | No |
| 6 | Update Documentation | rust-developer | Low | 5 | No |
| 7 | Final Verification | feature-tester-rust | Low | 6 | No |

---

## Phase 1: Implement xx_hash_variant Core

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | rust |
| **Complexity** | Medium |
| **Dependencies** | None |
| **Parallelizable** | No |
| **Estimated Duration** | 15 minutes |

**Objective:** Implement the `xx_hash_variant()` function with all `HashVariant` enum support.

**File:** `shared/src/hashing/xx_hash.rs`

**Variant Application Order (DEFINED):**

The variants MUST be applied in this specific order to ensure consistent behavior:

1. **BlockTrimming** - Trim entire block first (affects overall content boundaries)
2. **BlankLine** - Remove empty lines (reduces line count)
3. **LeadingWhitespace** - Remove leading whitespace per line
4. **TrailingWhitespace** - Remove trailing whitespace per line
5. **InteriorWhitespace** - Collapse interior whitespace per line (after other whitespace ops)
6. **ReplacementMap** - Apply text substitutions
7. **DropChars** - Remove specific characters

**Implementation:**

```rust
/// Produces an xxHash of a _mutated_ version of the content/data passed in.
///
/// The caller provides one or more `HashVariant` enum variants which are applied
/// in a deterministic order (see below) before hashing.
///
/// ## Variant Application Order
///
/// Variants are always applied in this fixed order, regardless of the order
/// specified in the input vector:
///
/// 1. BlockTrimming
/// 2. BlankLine
/// 3. LeadingWhitespace
/// 4. TrailingWhitespace
/// 5. InteriorWhitespace
/// 6. ReplacementMap
/// 7. DropChars
///
/// ## Examples
///
/// ```rust
/// use shared::hashing::{xx_hash_variant, HashVariant};
///
/// // Equivalent to xx_hash_trimmed()
/// let hash = xx_hash_variant("  hello  ", vec![HashVariant::BlockTrimming]);
///
/// // Multiple variants
/// let hash = xx_hash_variant(
///     "  hello  world  ",
///     vec![HashVariant::LeadingWhitespace, HashVariant::TrailingWhitespace]
/// );
/// ```
pub fn xx_hash_variant(data: &str, variants: Vec<HashVariant>) -> u64 {
    let mut content = data.to_string();

    // 1. BlockTrimming
    if variants.iter().any(|v| matches!(v, HashVariant::BlockTrimming)) {
        content = content.trim().to_string();
    }

    // 2. BlankLine
    if variants.iter().any(|v| matches!(v, HashVariant::BlankLine)) {
        content = content
            .lines()
            .filter(|line| !line.trim().is_empty())
            .collect::<Vec<_>>()
            .join("\n");
    }

    // 3. LeadingWhitespace
    if variants.iter().any(|v| matches!(v, HashVariant::LeadingWhitespace)) {
        content = content
            .lines()
            .map(|line| line.trim_start())
            .collect::<Vec<_>>()
            .join("\n");
    }

    // 4. TrailingWhitespace
    if variants.iter().any(|v| matches!(v, HashVariant::TrailingWhitespace)) {
        content = content
            .lines()
            .map(|line| line.trim_end())
            .collect::<Vec<_>>()
            .join("\n");
    }

    // 5. InteriorWhitespace
    if variants.iter().any(|v| matches!(v, HashVariant::InteriorWhitespace)) {
        content = content
            .lines()
            .map(|line| collapse_interior_whitespace(line))
            .collect::<Vec<_>>()
            .join("\n");
    }

    // 6. ReplacementMap
    for variant in &variants {
        if let HashVariant::ReplacementMap(map) = variant {
            for (find, replace) in map {
                content = content.replace(find, replace);
            }
        }
    }

    // 7. DropChars
    for variant in &variants {
        if let HashVariant::DropChars(chars) = variant {
            content = content.chars().filter(|c| !chars.contains(c)).collect();
        }
    }

    xxh64(content.as_bytes(), 0)
}

/// Collapses runs of whitespace to a single space within a line.
fn collapse_interior_whitespace(line: &str) -> String {
    let trimmed = line.trim();
    if trimmed.is_empty() {
        return String::new();
    }

    let mut result = String::with_capacity(trimmed.len());
    let mut prev_was_whitespace = false;

    for c in trimmed.chars() {
        if c.is_whitespace() {
            if !prev_was_whitespace {
                result.push(' ');
                prev_was_whitespace = true;
            }
        } else {
            result.push(c);
            prev_was_whitespace = false;
        }
    }

    result
}
```

**Acceptance Criteria:**
- [ ] All 7 variant types implemented
- [ ] Variants applied in documented order
- [ ] Helper function for interior whitespace collapse
- [ ] Function compiles with existing crate dependencies

---

## Phase 2: Add Comprehensive Unit Tests

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust |
| **Complexity** | Medium |
| **Dependencies** | Phase 1 |
| **Parallelizable** | No |
| **Estimated Duration** | 20 minutes |

**Objective:** Create comprehensive tests including backward compatibility verification.

**File:** `shared/src/hashing/xx_hash.rs` (tests module)

**Test Categories:**

### A. Individual Variant Tests

```rust
#[test]
fn test_variant_block_trimming() {
    let data = "  hello world  ";
    let hash = xx_hash_variant(data, vec![HashVariant::BlockTrimming]);
    assert_eq!(hash, xx_hash("hello world"));
}

#[test]
fn test_variant_blank_line() {
    let data = "line1\n\nline2";
    let hash = xx_hash_variant(data, vec![HashVariant::BlankLine]);
    assert_eq!(hash, xx_hash("line1\nline2"));
}

#[test]
fn test_variant_leading_whitespace() {
    let data = "  line1\n  line2";
    let hash = xx_hash_variant(data, vec![HashVariant::LeadingWhitespace]);
    assert_eq!(hash, xx_hash("line1\nline2"));
}

#[test]
fn test_variant_trailing_whitespace() {
    let data = "line1  \nline2  ";
    let hash = xx_hash_variant(data, vec![HashVariant::TrailingWhitespace]);
    assert_eq!(hash, xx_hash("line1\nline2"));
}

#[test]
fn test_variant_interior_whitespace() {
    let data = "hello    world";
    let hash = xx_hash_variant(data, vec![HashVariant::InteriorWhitespace]);
    assert_eq!(hash, xx_hash("hello world"));
}

#[test]
fn test_variant_replacement_map() {
    use std::collections::HashMap;
    let mut map = HashMap::new();
    map.insert("'".to_string(), "'".to_string());

    let data = "it's a test";
    let hash = xx_hash_variant(data, vec![HashVariant::ReplacementMap(map)]);
    assert_eq!(hash, xx_hash("it's a test"));
}

#[test]
fn test_variant_drop_chars() {
    let data = "hello!world?";
    let hash = xx_hash_variant(data, vec![HashVariant::DropChars(vec!['!', '?'])]);
    assert_eq!(hash, xx_hash("helloworld"));
}
```

### B. Backward Compatibility Tests (REQUIRED)

```rust
#[test]
fn test_backward_compat_trimmed() {
    let test_cases = [
        "  hello  ",
        "\n\nhello\n\n",
        "\thello\t",
        "  multi\n  line  ",
    ];

    for data in test_cases {
        assert_eq!(
            xx_hash_variant(data, vec![HashVariant::BlockTrimming]),
            xx_hash_trimmed(data),
            "BlockTrimming should match xx_hash_trimmed for: {:?}",
            data
        );
    }
}

#[test]
fn test_backward_compat_normalized() {
    let test_cases = [
        "line1\n\nline2",
        "line1\n\n\n\nline2",
        "flowchart LR\n\n    A --> B\n\n",
    ];

    for data in test_cases {
        assert_eq!(
            xx_hash_variant(data, vec![HashVariant::BlankLine]),
            xx_hash_normalized(data),
            "BlankLine should match xx_hash_normalized for: {:?}",
            data
        );
    }
}

#[test]
fn test_backward_compat_semantic() {
    let test_cases = [
        "  - item1\n  - item2",
        "line1  \n\nline2  ",
        "  - item1  \n\n  - item2\n\n",
    ];

    for data in test_cases {
        assert_eq!(
            xx_hash_variant(data, vec![
                HashVariant::LeadingWhitespace,
                HashVariant::TrailingWhitespace,
                HashVariant::BlankLine,
            ]),
            xx_hash_semantic(data),
            "Leading+Trailing+BlankLine should match xx_hash_semantic for: {:?}",
            data
        );
    }
}
```

### C. Variant Order Tests

```rust
#[test]
fn test_variant_order_independence() {
    // Order in vec should not matter - internal order is fixed
    let data = "  line1  \n\n  line2  ";

    let hash1 = xx_hash_variant(data, vec![
        HashVariant::BlankLine,
        HashVariant::LeadingWhitespace,
        HashVariant::TrailingWhitespace,
    ]);

    let hash2 = xx_hash_variant(data, vec![
        HashVariant::TrailingWhitespace,
        HashVariant::LeadingWhitespace,
        HashVariant::BlankLine,
    ]);

    assert_eq!(hash1, hash2);
}
```

### D. Edge Case Tests

```rust
#[test]
fn test_empty_string() {
    assert_eq!(xx_hash_variant("", vec![HashVariant::BlockTrimming]), xx_hash(""));
}

#[test]
fn test_no_variants() {
    let data = "hello";
    assert_eq!(xx_hash_variant(data, vec![]), xx_hash(data));
}

#[test]
fn test_whitespace_only() {
    let data = "   \n\n   ";
    let hash = xx_hash_variant(data, vec![
        HashVariant::BlankLine,
        HashVariant::LeadingWhitespace,
        HashVariant::TrailingWhitespace,
    ]);
    assert_eq!(hash, xx_hash(""));
}
```

**Acceptance Criteria:**
- [ ] All individual variant tests pass
- [ ] All 3 backward compatibility tests pass
- [ ] Variant order independence verified
- [ ] Edge cases covered

---

## Phase 3: Fix Delta Module (Remove Invalid Comparison)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | rust |
| **Complexity** | Low |
| **Dependencies** | Phase 2 |
| **Parallelizable** | No |
| **Estimated Duration** | 5 minutes |

**Objective:** Review delta module for any invalid hash comparisons.

**Investigation Required:**

After code review, the delta module at `shared/src/markdown/delta/mod.rs` uses:
- `xx_hash_alphanumeric()` for content comparison (lines 257-261)
- `prelude_hash()` for section matching
- `content_hash_trimmed` for code block comparison (line 607-608)

These are all valid comparisons. The "invalid comparison" concern from original plan may have been resolved or was a misunderstanding.

**Action:** Verify no semantic comparison bugs exist, document findings.

**Acceptance Criteria:**
- [ ] Confirmed delta module comparisons are semantically correct
- [ ] No changes needed OR issue documented and fixed

---

## Phase 4: Migrate Callers

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | rust |
| **Complexity** | Low |
| **Dependencies** | Phase 2 |
| **Parallelizable** | Yes (3 parallel tasks) |
| **Estimated Duration** | 10 minutes |

**Objective:** Update all callers to use `xx_hash_variant()`.

### CORRECTED Migration Map

| Old Function | New Call |
|--------------|----------|
| `xx_hash_trimmed(d)` | `xx_hash_variant(d, vec![HashVariant::BlockTrimming])` |
| `xx_hash_normalized(d)` | `xx_hash_variant(d, vec![HashVariant::BlankLine])` |
| `xx_hash_semantic(d)` | `xx_hash_variant(d, vec![HashVariant::LeadingWhitespace, HashVariant::TrailingWhitespace, HashVariant::BlankLine])` |

**NOTE:** The original plan INCORRECTLY included `InteriorWhitespace` in the semantic mapping. The actual `xx_hash_semantic()` implementation does NOT collapse interior whitespace - it only trims each line (leading + trailing) and removes blank lines.

### Parallel Task 4a: Mermaid Module

**File:** `shared/src/mermaid/mod.rs`

**Change:** Line 158
```rust
// Before
crate::hashing::xx_hash_normalized(&self.instructions)

// After
crate::hashing::xx_hash_variant(
    &self.instructions,
    vec![crate::hashing::HashVariant::BlankLine]
)
```

### Parallel Task 4b: TOC Types

**File:** `shared/src/markdown/toc/types.rs`

**Changes:**
- Lines 82, 85: Update imports and `title_hash_trimmed`
- Lines 134, 151: Update `subtree_hash_trimmed`
- Lines 213, 216-217: Update imports and `content_hash_trimmed`, `content_hash_normalized`
- Lines 270, 273: Update `content_hash_trimmed`

```rust
// Example update pattern
use crate::hashing::{xx_hash, xx_hash_variant, HashVariant};

// Before
let title_hash_trimmed = xx_hash_trimmed(&title);

// After
let title_hash_trimmed = xx_hash_variant(&title, vec![HashVariant::BlockTrimming]);
```

### Parallel Task 4c: TOC Module

**File:** `shared/src/markdown/toc/mod.rs`

**Changes:**
- Line 25: Update import
- Line 314: Update `page_hash_trimmed`
- Line 337: Update `preamble_hash_trimmed`

```rust
// Update import
use crate::hashing::{xx_hash, xx_hash_variant, HashVariant};

// Before (line 314)
toc.page_hash_trimmed = xx_hash_trimmed(content);

// After
toc.page_hash_trimmed = xx_hash_variant(content, vec![HashVariant::BlockTrimming]);
```

**Acceptance Criteria:**
- [ ] All 3 files updated
- [ ] `cargo build -p shared` succeeds
- [ ] `cargo test -p shared` passes

---

## Phase 5: Delete Deprecated Functions

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | rust |
| **Complexity** | Low |
| **Dependencies** | Phase 3, Phase 4 |
| **Parallelizable** | No |
| **Estimated Duration** | 5 minutes |

**Objective:** Remove deprecated functions after all callers migrated.

**File:** `shared/src/hashing/xx_hash.rs`

**Delete:**
- `xx_hash_trimmed()` function and its tests
- `xx_hash_normalized()` function and its tests
- `xx_hash_semantic()` function and its tests

**File:** `shared/src/hashing/mod.rs`

**Update re-exports (line 52-55):**
```rust
// Before
pub use xx_hash::{
    xx_hash, xx_hash_alphanumeric, xx_hash_bytes, xx_hash_content_only, xx_hash_normalized,
    xx_hash_semantic, xx_hash_trimmed,
};

// After
pub use xx_hash::{
    xx_hash, xx_hash_alphanumeric, xx_hash_bytes, xx_hash_content_only, xx_hash_variant,
};
```

**Acceptance Criteria:**
- [ ] Deprecated functions removed
- [ ] Re-exports updated
- [ ] `cargo build -p shared` succeeds
- [ ] `cargo test -p shared` passes
- [ ] No unused code warnings

---

## Phase 6: Update Documentation

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | rust |
| **Complexity** | Low |
| **Dependencies** | Phase 5 |
| **Parallelizable** | No |
| **Estimated Duration** | 10 minutes |

**Objective:** Update README and module documentation.

### Task 6a: Fix README Documentation Bug (HIGH PRIORITY)

**File:** `shared/src/hashing/README.md`

**Bug:** Lines 19-20 have swapped descriptions.

```markdown
<!-- BEFORE (WRONG) -->
- `LeadingWhitespace` - all whitespace at the _end of each line_ is removed
- `TrailingWhitespace` - all whitespace at the _beginning of each line_ is removed

<!-- AFTER (CORRECT) -->
- `LeadingWhitespace` - all whitespace at the _beginning of each line_ is removed
- `TrailingWhitespace` - all whitespace at the _end of each line_ is removed
```

### Task 6b: Add Variant Application Order Section

**File:** `shared/src/hashing/README.md`

Add new section after line 21:

```markdown
### Variant Application Order

When multiple variants are specified, they are always applied in this fixed order
(regardless of the order in the input vector):

1. **BlockTrimming** - trim entire content block first
2. **BlankLine** - remove empty lines
3. **LeadingWhitespace** - remove per-line leading whitespace
4. **TrailingWhitespace** - remove per-line trailing whitespace
5. **InteriorWhitespace** - collapse interior whitespace per line
6. **ReplacementMap** - apply text substitutions
7. **DropChars** - remove specific characters
```

### Task 6c: Update Module Docstring

**File:** `shared/src/hashing/xx_hash.rs`

Update module docstring to reference `xx_hash_variant` instead of deprecated functions.

**Acceptance Criteria:**
- [ ] README bug fixed (Leading/Trailing descriptions corrected)
- [ ] Variant order documented in README
- [ ] Module docstring updated
- [ ] `cargo doc -p shared` generates without warnings

---

## Phase 7: Final Verification

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust |
| **Complexity** | Low |
| **Dependencies** | Phase 6 |
| **Parallelizable** | No |
| **Estimated Duration** | 5 minutes |

**Objective:** Verify complete refactoring success.

**Verification Steps:**

1. **Build all packages:**
   ```bash
   cargo build --workspace
   ```

2. **Run all tests:**
   ```bash
   cargo test --workspace
   ```

3. **Check for warnings:**
   ```bash
   cargo clippy --workspace
   ```

4. **Generate and review docs:**
   ```bash
   cargo doc -p shared --open
   ```

5. **Verify no deprecated function references:**
   ```bash
   grep -r "xx_hash_trimmed\|xx_hash_normalized\|xx_hash_semantic" shared/src --include="*.rs"
   # Should return empty (only matches in test comparison comments are OK)
   ```

**Acceptance Criteria:**
- [ ] Workspace builds with no errors
- [ ] All tests pass
- [ ] No clippy warnings
- [ ] Documentation generates cleanly
- [ ] No remaining deprecated function calls

---

## Lessons Learned

> Capture discoveries about skills or memory resources (CLAUDE.md, README.md, etc.) that were inaccurate, incomplete, or missing.

- [DOC: shared/src/hashing/README.md]: Lines 19-20 had swapped descriptions for LeadingWhitespace and TrailingWhitespace - fixed in Phase 6
- [IMPL: xx_hash_semantic]: Original migration plan incorrectly assumed InteriorWhitespace was applied - actual implementation only does line.trim() (leading + trailing per line) plus blank line removal

---

## Package Changes in Execution

> Dependencies to be added, updated, or removed during implementation.

_None required - all dependencies already present._

---
SKILLS_USED: [rust, dockhand-library]
LESSONS_LEARNED:
- [DOC: README.md]: Leading/Trailing whitespace descriptions were swapped (lines 19-20)
- [IMPL: xx_hash_semantic]: Does NOT include InteriorWhitespace - only line.trim() per line
PACKAGE_CHANGES:
- None required
