# Better Tables - comfy-table Integration

**Created:** 2026-01-01
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Replace the home-grown table rendering implementation in `shared/src/markdown/output/terminal.rs` with `comfy-table` to gain proper column alignment (left/center/right based on GFM markdown syntax), correct handling of ANSI escape codes in column width calculations, and terminal-width-constrained tables that don't overflow.

## Review Summary

**Reviews Completed:** 2026-01-01

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. **Phase reordering**: Tests moved before cleanup (TDD approach)
2. **Explicit type mapping**: Document `pulldown_cmark::Alignment` → `comfy_table::CellAlignment` conversion
3. **Terminal width optimization**: Query once per document, not per table
4. **Use comfy-table's styling API**: Prefer `Cell::add_attribute()` over raw ANSI injection
5. **Version pinning**: Use `comfy-table = "7.1"` for stability
6. **Snapshot testing**: Commit to `insta` for visual regression testing
7. **Property-based tests**: Add proptest for table width constraints
8. **Handle `ColorDepth::None`**: Document fallback behavior for no-color mode

**Resolved Concerns:**
- Alternating row backgrounds → **Drop feature** (use comfy-table defaults, simplify code)
- Visual regression risk → **Add insta snapshot tests** before refactoring
- Alignment type leakage → **Map at event loop boundary**, not in render function

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Parse GFM table alignment from separator row (`---`, `:---`, `:---:`, `---:`) | High | Rust Developer |
| FR-2 | Render tables using `comfy-table` with box-drawing characters | High | Rust Developer |
| FR-3 | Apply column alignment (left/center/right) from markdown syntax | High | Rust Developer |
| FR-4 | Constrain table width to terminal width (no overflow) | Medium | Rust Developer |
| FR-5 | Header cells rendered bold | Medium | Rust Developer |
| FR-6 | Handle inline code within table cells with proper width calculation | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | ANSI escape codes don't affect column width calculation | 100% correct | Rust Developer |
| NFR-2 | Tables render correctly with OSC hyperlinks | No alignment issues | Rust Developer |
| NFR-3 | Performance comparable to current implementation | < 10% regression | Rust Developer |
| NFR-4 | Table width respects terminal width | Never exceed terminal | Rust Developer |

## Architecture Overview

### Current Architecture

The current implementation in `terminal.rs:454-629` manually:
1. Buffers table rows during pulldown-cmark parsing
2. Calculates column widths (with bugs for ANSI codes)
3. Renders box-drawing characters manually
4. Applies hardcoded background colors for alternating rows

### Target Architecture

Replace manual rendering with comfy-table:
1. Parse alignment from pulldown-cmark `Tag::Table(alignments)` event
2. **Convert** alignment at event boundary (pulldown-cmark → comfy-table types)
3. Buffer cell content during parsing (unchanged)
4. Query terminal width **once** at start of `for_terminal()`
5. Build `comfy_table::Table` with pre-converted alignments
6. Use comfy-table's `Cell` API for styling (not raw ANSI injection)
7. Configure preset for minimalist look

### Type Mapping (Critical)

```rust
// pulldown_cmark::Alignment → comfy_table::CellAlignment
fn convert_alignment(align: &pulldown_cmark::Alignment) -> comfy_table::CellAlignment {
    match align {
        pulldown_cmark::Alignment::None => comfy_table::CellAlignment::Left,
        pulldown_cmark::Alignment::Left => comfy_table::CellAlignment::Left,
        pulldown_cmark::Alignment::Center => comfy_table::CellAlignment::Center,
        pulldown_cmark::Alignment::Right => comfy_table::CellAlignment::Right,
    }
}
```

### Data Flow

```
Markdown Source
     │
     ▼
pulldown-cmark Parser (Tag::Table with Vec<Alignment>)
     │
     ▼
Convert alignment to comfy_table::CellAlignment (at boundary)
     │
     ▼
Buffer rows + store converted alignments
     │
     ▼
Build comfy_table::Table (using terminal_width queried once)
  - Set header row with Cell::add_attribute(Bold)
  - Add data rows
  - Apply column alignments
  - Set width constraint
     │
     ▼
table.to_string() → Terminal Output
```

## Phases

### Phase 1: Add Dependencies and Extract Alignment

**Principal Owner:** Rust Developer

**Goal:** Add comfy-table dependency and extract alignment information from pulldown-cmark events

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to create/modify:**
- `shared/Cargo.toml` - Add dependencies
- `shared/src/markdown/output/terminal.rs` - Extract and convert alignment

**Technical Details:**
- pulldown-cmark provides `Vec<Alignment>` in `Tag::Table(alignments)` event
- **Convert at boundary**: Map to `Vec<comfy_table::CellAlignment>` immediately
- Store alongside existing `table_rows` buffer
- Query terminal width once in `for_terminal()` and store for later use

**Deliverables:**
- `comfy-table = "7.1"` added to `shared/Cargo.toml` dependencies
- `terminal_size = "0.3"` added to `shared/Cargo.toml` dependencies
- New `table_alignments: Vec<CellAlignment>` field in table tracking state
- `terminal_width: u16` computed once at start of `for_terminal()`
- Alignment extracted and **converted** from `Event::Start(Tag::Table(alignments))`
- Helper function `convert_alignment()` implemented

**Code Pattern:**
```rust
// At start of for_terminal()
const DEFAULT_TERMINAL_WIDTH: u16 = 80;
let terminal_width = terminal_size::terminal_size()
    .map(|(Width(w), _)| w)
    .unwrap_or(DEFAULT_TERMINAL_WIDTH);

// Table state tracking (add these alongside existing variables)
let mut table_alignments: Vec<comfy_table::CellAlignment> = Vec::new();

// In event loop
Event::Start(Tag::Table(alignments)) => {
    in_table = true;
    table_rows.clear();
    table_alignments = alignments.iter().map(convert_alignment).collect();
    // ... existing spacing logic
}
```

**Acceptance Criteria:**
- [ ] `grep "comfy-table = \"7.1\"" shared/Cargo.toml` succeeds
- [ ] `grep "terminal_size" shared/Cargo.toml` succeeds
- [ ] `cargo build -p shared` succeeds without errors
- [ ] `grep "fn convert_alignment" shared/src/markdown/output/terminal.rs` succeeds
- [ ] Alignment is captured and converted (verified by new test)
- [ ] Terminal width is queried once (verified by grep for single `terminal_size()` call)

---

### Phase 2: Implement comfy-table Rendering

**Principal Owner:** Rust Developer

**Goal:** Replace `render_table()` function with comfy-table-based implementation

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs:462-629` - Replace `render_table()` function

**Technical Details:**
- Create `comfy_table::Table` from buffered rows
- Set header from first row using `Cell::add_attribute(Attribute::Bold)`
- Apply `ContentArrangement::Dynamic` for automatic wrapping
- Use pre-queried `terminal_width` (not re-query per table)
- Use `presets::UTF8_BORDERS_ONLY` for minimalist look
- Use pre-converted `Vec<CellAlignment>` (no mapping in render function)

**Code Pattern:**
```rust
use comfy_table::{Table, ContentArrangement, Cell, Attribute, presets};

fn render_table(
    rows: &[Vec<String>],
    alignments: &[comfy_table::CellAlignment],  // Already converted!
    terminal_width: u16,
) -> String {
    if rows.is_empty() {
        return String::new();
    }

    let mut table = Table::new();

    // Set width constraint (use pre-queried width)
    table.set_width(terminal_width);
    table.set_content_arrangement(ContentArrangement::Dynamic);

    // Minimalist preset
    table.load_preset(presets::UTF8_BORDERS_ONLY);

    // Add header row with bold styling
    if let Some(header) = rows.first() {
        table.set_header(header.iter().enumerate().map(|(i, cell_content)| {
            let alignment = alignments.get(i).copied().unwrap_or(CellAlignment::Left);
            Cell::new(cell_content)
                .set_alignment(alignment)
                .add_attribute(Attribute::Bold)
        }));
    }

    // Add data rows
    for row in rows.iter().skip(1) {
        table.add_row(row.iter().enumerate().map(|(i, cell_content)| {
            let alignment = alignments.get(i).copied().unwrap_or(CellAlignment::Left);
            Cell::new(cell_content).set_alignment(alignment)
        }));
    }

    table.to_string()
}
```

**Deliverables:**
- `render_table()` function rewritten to use comfy-table
- Signature changed to accept `&[CellAlignment]` and `terminal_width: u16`
- Header cells have `Attribute::Bold` applied via comfy-table API
- Terminal width constraint applied from pre-queried value
- Minimalist border preset applied

**Acceptance Criteria:**
- [ ] `grep "comfy_table::Table" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `grep "Attribute::Bold" shared/src/markdown/output/terminal.rs` succeeds
- [ ] Tables render with correct left alignment (test `|---|`)
- [ ] Tables render with correct right alignment (test `|---:|`)
- [ ] Tables render with correct center alignment (test `|:---:|`)
- [ ] Tables respect terminal width (test with fixed width of 40)
- [ ] Empty table returns empty string (edge case test)
- [ ] Existing table tests pass (no regression)

---

### Phase 3: Comprehensive Testing (Before Cleanup!)

**Principal Owner:** Feature Tester (Rust)

**Goal:** Add comprehensive tests including snapshot tests before removing legacy code

**Dependencies:** Phase 2 complete

**Blast Radius:** `cargo test -p shared`

**Files to create/modify:**
- `shared/src/markdown/output/terminal.rs` - Add new alignment and edge case tests
- `shared/tests/markdown_integration.rs` - Add alignment integration tests

**Technical Details:**
- Use `insta` for snapshot testing to catch visual regressions
- Add property-based tests for width constraints
- Test all GFM alignment combinations
- Test edge cases (empty cells, ragged rows, Unicode)

**Test Scenarios to Add:**

1. **Alignment Tests:**
   - Left-aligned column (`|---|`)
   - Right-aligned column (`|---:|`)
   - Center-aligned column (`|:---:|`)
   - Mixed alignment in same table (`|:---|---:|:---:|`)
   - Default alignment (no colons) maps to left

2. **Width Constraint Tests:**
   - Table respects terminal width constraint (40 cols)
   - Very long cell content wraps correctly
   - Many columns distribute width fairly

3. **Edge Case Tests:**
   - Empty table returns empty string
   - Single column table
   - Table with empty cells (`| | B |`)
   - Ragged rows (fewer cells than columns)
   - Unicode characters in cells (emoji, CJK)

4. **ANSI Handling Tests:**
   - Cell with inline code doesn't break alignment
   - Long inline code in one cell, short text in another
   - Multiple inline code blocks in same cell

5. **Integration Tests:**
   - Table after heading has proper spacing
   - Table renders correctly in full document

6. **Snapshot Tests (insta):**
   - `test_table_alignment_snapshot` - visual verification of all alignment types
   - `test_table_width_constraint_snapshot` - verify wrapping behavior

**Code Pattern for Snapshot Test:**
```rust
#[test]
fn test_table_alignment_snapshot() {
    let md: Markdown = "| Left | Center | Right |\n|:-----|:------:|------:|\n| A | B | C |".into();
    let output = for_terminal(&md, TerminalOptions::default()).unwrap();
    insta::assert_snapshot!(strip_ansi_codes(&output));
}
```

**Deliverables:**
- 15+ new test cases added to `terminal.rs` tests module
- Snapshot tests added using `insta`
- All tests pass before proceeding to cleanup

**Acceptance Criteria:**
- [ ] `grep -c "#\[test\]" shared/src/markdown/output/terminal.rs` shows 15+ more tests
- [ ] `grep "insta::assert_snapshot" shared/src/markdown/output/terminal.rs` succeeds
- [ ] All alignment tests pass
- [ ] All edge case tests pass
- [ ] `cargo test -p shared` succeeds with 0 failures

---

### Phase 4: Handle Inline Code Styling

**Principal Owner:** Rust Developer

**Goal:** Properly handle inline code markers in table cells

**Dependencies:** Phase 3 complete (tests prove core works)

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Update cell content processing

**Technical Details:**
- Current implementation uses `\x00CODE\x00...\x00/CODE\x00` markers for inline code
- These markers need to be processed before adding to comfy-table
- Apply background color styling to inline code segments
- comfy-table will handle width calculation correctly for styled content

**Decision: Keep current marker approach**
- Parse markers in cell content
- Apply styling before adding to comfy-table Cell
- comfy-table's ANSI-aware width calculation handles the rest

**Deliverables:**
- Inline code in cells has background color styling
- Column widths correct despite ANSI codes in inline code
- Cell content processing function updated

**Acceptance Criteria:**
- [ ] Inline code has background styling (test with `\x1b[48;2;` assertion)
- [ ] Column widths are correct with inline code (alignment test)
- [ ] `test_table_with_inline_code` passes
- [ ] Long inline code doesn't break table layout

---

### Phase 5: Remove Legacy Code and Cleanup

**Principal Owner:** Rust Developer

**Goal:** Remove unused legacy rendering code and helper functions

**Dependencies:** Phase 4 complete, all tests passing

**Blast Radius:** `cargo test -p shared`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Remove legacy functions

**Technical Details:**
- Remove old manual box-drawing rendering code
- Remove `emit_inline_code_in_table()` if replaced
- Remove hardcoded color constants for alternating rows (dropped feature)
- Remove unused helper functions
- Update module-level documentation

**Code to Remove (approximately):**
- `render_cell_content()` - if fully replaced
- `emit_inline_code_in_table()` - if replaced
- Hardcoded color constants: `header_bg`, `even_row_bg`, `odd_row_bg`
- Box-drawing character constants if unused

**Deliverables:**
- Legacy rendering functions removed
- Code is cleaner and more maintainable
- No dead code warnings from `cargo clippy`
- Line count reduced by ~100 lines

**Acceptance Criteria:**
- [ ] `cargo clippy -p shared` shows no dead code warnings
- [ ] `wc -l shared/src/markdown/output/terminal.rs` shows at least 100 fewer lines
- [ ] All existing tests pass
- [ ] All new tests pass
- [ ] `cargo test -p shared` succeeds

---

### Phase 6: Handle ColorDepth::None and Final Polish

**Principal Owner:** Rust Developer

**Goal:** Handle edge cases and add tracing instrumentation

**Dependencies:** Phase 5 complete

**Blast Radius:** `cargo test -p shared`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Add ColorDepth handling and tracing

**Technical Details:**
- When `ColorDepth::None`, tables should still render with box-drawing
- Add `#[tracing::instrument]` to `render_table()` for observability
- Final documentation updates

**ColorDepth::None Behavior:**
- Box-drawing characters are not color-dependent, so tables still render
- Header bold (`Attribute::Bold`) may not display, but is harmless
- No special handling needed beyond existing early return for prose

**Tracing Integration:**
```rust
#[tracing::instrument(
    skip(rows, alignments),
    fields(row_count = rows.len(), col_count, terminal_width)
)]
fn render_table(
    rows: &[Vec<String>],
    alignments: &[CellAlignment],
    terminal_width: u16,
) -> String {
    let col_count = rows.iter().map(|r| r.len()).max().unwrap_or(0);
    tracing::Span::current().record("col_count", col_count);
    // ...
}
```

**Deliverables:**
- `ColorDepth::None` behavior documented and tested
- Tracing instrumentation added to `render_table()`
- Final documentation updates

**Acceptance Criteria:**
- [ ] `ColorDepth::None` test passes (table still renders)
- [ ] `grep "tracing::instrument" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `cargo test -p shared` succeeds
- [ ] `cargo doc -p shared` succeeds without warnings

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests**: In-module `#[cfg(test)] mod tests` blocks for `render_table()`
- **Integration tests**: `shared/tests/markdown_integration.rs` for full pipeline
- **Property-based tests**: `proptest` for table width constraints
- **Snapshot tests**: `insta` for visual table output verification (COMMITTED)

### Security Considerations

- Cell content is already sanitized by prose highlighter
- No user input directly rendered (content goes through markdown parser)
- ANSI escape codes are generated by our code, not user input

### Performance Considerations

- comfy-table is well-optimized for terminal rendering
- Single allocation for table string output
- Terminal size query done **once per document** (not per table)
- No re-computation of alignment mapping per cell

### Project-Specific Concerns

**comfy-table Integration:**
- Use `presets::UTF8_BORDERS_ONLY` for minimalist look
- Use `Cell::add_attribute(Attribute::Bold)` for headers (not raw ANSI)
- ANSI escape codes handled automatically (key benefit)

**Dropped Feature: Alternating Row Backgrounds**
- Current implementation has alternating row backgrounds
- mdcat reference does NOT have them
- **Decision: Drop this feature** to simplify code and match reference
- If needed later, can use comfy-table's row styling API

**Error Handling:**
- comfy-table operations are infallible
- Terminal size query has fallback to `DEFAULT_TERMINAL_WIDTH` (80 columns)
- No new error types needed

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Foundation - must complete first |
| Group B | Phase 2 | Core rendering |
| Group C | Phase 3 | Testing before cleanup (TDD) |
| Group D | Phase 4 | Inline code styling |
| Group E | Phase 5, Phase 6 | Cleanup and polish can overlap |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────────────►

Phase 1: ████████ (Add deps, extract alignment)
                │
Phase 2:        └──████████████ (comfy-table rendering)
                              │
Phase 3:                      └──████████████ (Comprehensive tests)
                                            │
Phase 4:                                    └──████████ (Inline code)
                                                      │
Phase 5:                                              └──████ (Cleanup)
                                                         │
Phase 6:                                                 └──████ (Polish)
```

### Synchronization Points

1. **After Phase 1:** Dependencies and alignment extraction must be complete
2. **After Phase 2:** Core rendering must work before adding tests
3. **After Phase 3:** Tests must pass before cleanup (TDD principle)
4. **After Phase 4:** Inline code handling must work before removing legacy code
5. **Final:** All tests must pass before complete

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| comfy-table API changes | Medium | Pin to `"7.1"` (minor version) |
| Visual regression from mdcat look | Low | Snapshot tests with `insta` |
| Terminal width detection fails | Low | Fallback to 80 columns |
| ANSI handling edge cases | Medium | Comprehensive test suite |
| Performance regression | Low | No complex changes, measure if needed |

## Open Questions (Resolved)

- [x] Should alternating row backgrounds be preserved? → **No, drop feature**
- [x] Should we support custom border styles via CLI option? → **No, out of scope**
- [x] Is the minimalist mdcat look preferred? → **Yes, use UTF8_BORDERS_ONLY**

## Dependencies to Add

```toml
# shared/Cargo.toml [dependencies]
comfy-table = "7.1"
terminal_size = "0.3"
```
