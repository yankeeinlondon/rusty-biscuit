# Visual Diff Feature for `md --delta -v`

## Overview

Add visual diff output to the `md` CLI when `-v` flag is used with `--delta`. The visual diff complements the existing semantic analysis with a delta-style line-by-line view featuring inline character highlighting.

**Terminal Width Behavior:**

- `> 110 columns`: Side-by-side view (like delta with `--side-by-side`)
- `<= 110 columns`: Unified/merged view (traditional +/- format)

## Architecture

### New Module Structure

```
shared/src/markdown/delta/
├── mod.rs              # existing - add visual module export
├── types.rs            # existing
├── visual/
│   ├── mod.rs          # public API, mode selection
│   ├── diff.rs         # line diff computation with similar crate
│   ├── side_by_side.rs # wide terminal renderer
│   └── unified.rs      # narrow terminal renderer
```

### Dependencies to Add

**shared/Cargo.toml:**

```toml
similar = { version = "2.6", features = ["inline"] }
```

The `similar` crate with `inline` feature provides:

- Line-level diff (Myers/patience algorithms)
- Character-level change detection within modified lines
- Clean API for iterating changes

Note: `diffy` not needed - `similar` handles both unified format generation and inline changes.

---

## Implementation Plan

### Step 1: Add `similar` Dependency

**File:** `shared/Cargo.toml`

Add `similar` with inline feature for character-level diff highlighting.

### Step 2: Create Visual Diff Module

**File:** `shared/src/markdown/delta/visual/mod.rs`

```rust
//! Visual diff rendering for terminal output.
//!
//! Provides line-by-line diff visualization with two display modes:
//! - Side-by-side (terminals > 110 columns)
//! - Unified (terminals <= 110 columns)

mod diff;
mod side_by_side;
mod unified;

pub use diff::{DiffLine, InlineSpan, compute_visual_diff};

use terminal_size::{terminal_size, Width};

const SIDE_BY_SIDE_THRESHOLD: u16 = 110;

pub struct VisualDiffOptions {
    pub terminal_width: u16,
    pub show_line_numbers: bool,
    pub context_lines: usize,  // lines of context around changes
}

impl Default for VisualDiffOptions {
    fn default() -> Self {
        let width = terminal_size()
            .map(|(Width(w), _)| w)
            .unwrap_or(80);
        Self {
            terminal_width: width,
            show_line_numbers: true,
            context_lines: 3,
        }
    }
}

/// Render visual diff to string based on terminal width
pub fn render_visual_diff(
    original: &str,
    updated: &str,
    label_original: &str,
    label_updated: &str,
    options: &VisualDiffOptions,
) -> String {
    let diff = compute_visual_diff(original, updated);

    if options.terminal_width > SIDE_BY_SIDE_THRESHOLD {
        side_by_side::render(&diff, label_original, label_updated, options)
    } else {
        unified::render(&diff, label_original, label_updated, options)
    }
}
```

### Step 3: Implement Line Diff Computation

**File:** `shared/src/markdown/delta/visual/diff.rs`

```rust
use similar::{ChangeTag, TextDiff};

/// A span within a line that changed
#[derive(Debug, Clone)]
pub struct InlineSpan {
    pub start: usize,
    pub end: usize,
    pub emphasized: bool,  // true = this specific part changed
}

/// Represents a single line in the diff
#[derive(Debug, Clone)]
pub enum DiffLine {
    /// Unchanged context line
    Context {
        line_no_old: usize,
        line_no_new: usize,
        content: String,
    },
    /// Line only in original (removed)
    Removed {
        line_no: usize,
        content: String,
        inline_changes: Vec<InlineSpan>,
    },
    /// Line only in updated (added)
    Added {
        line_no: usize,
        content: String,
        inline_changes: Vec<InlineSpan>,
    },
}

pub fn compute_visual_diff(original: &str, updated: &str) -> Vec<DiffLine> {
    let diff = TextDiff::from_lines(original, updated);
    let mut result = Vec::new();

    // Track line numbers
    let mut old_line = 1usize;
    let mut new_line = 1usize;

    for change in diff.iter_all_changes() {
        match change.tag() {
            ChangeTag::Equal => {
                result.push(DiffLine::Context {
                    line_no_old: old_line,
                    line_no_new: new_line,
                    content: change.value().trim_end_matches('\n').to_string(),
                });
                old_line += 1;
                new_line += 1;
            }
            ChangeTag::Delete => {
                // Compute inline changes by comparing with next insert if present
                let inline = compute_inline_changes(change.value(), /* next insert */);
                result.push(DiffLine::Removed {
                    line_no: old_line,
                    content: change.value().trim_end_matches('\n').to_string(),
                    inline_changes: inline,
                });
                old_line += 1;
            }
            ChangeTag::Insert => {
                let inline = compute_inline_changes(/* prev delete */, change.value());
                result.push(DiffLine::Added {
                    line_no: new_line,
                    content: change.value().trim_end_matches('\n').to_string(),
                    inline_changes: inline,
                });
                new_line += 1;
            }
        }
    }

    result
}

/// Use similar's inline diff to find character-level changes
fn compute_inline_changes(old: &str, new: &str) -> Vec<InlineSpan> {
    // Use similar's word-level or grapheme-level diff
    // to identify which parts of the line changed
    // ...
}
```

### Step 4: Implement Side-by-Side Renderer

**File:** `shared/src/markdown/delta/visual/side_by_side.rs`

Layout calculation:

```
[left_num:4] [left_content] | [right_num:4] [right_content]
```

For 120-column terminal:

- Line number columns: 4 + 4 = 8
- Separator: 3 (` | `)
- Spacing: 2
- Content per side: (120 - 13) / 2 = 53 chars

Key implementation details:

- Use existing `unicode_width` for visual width calculation
- ANSI-aware column tracking (escape codes don't consume width)
- Line wrapping within each column when content exceeds width
- Colors:
    - Removed line: red background (`\x1b[48;5;52m` dark red)
    - Added line: green background (`\x1b[48;5;22m` dark green)
    - Changed characters within line: brighter highlight
- Empty placeholder for unpaired lines (one side blank)

### Step 5: Implement Unified Renderer

**File:** `shared/src/markdown/delta/visual/unified.rs`

Traditional format:

```
  10   context line
- 11   removed line with [highlighted] changes
+    12 added line with [highlighted] changes
  12 13 context line
```

Key implementation details:

- Prefix: `-` (red), `+` (green), ` ` (context)
- Line numbers: show both old:new for context, single for add/remove
- Inline highlighting with inverse or bold for changed characters

### Step 6: Integrate with CLI

**File:** `md/src/main.rs`

Modify the `print_delta` function:

```rust
fn print_delta(delta: &MarkdownDelta, verbose: bool, original: &Markdown, updated: &Markdown) {
    // ... existing semantic output ...

    if verbose {
        use shared::markdown::delta::visual::{render_visual_diff, VisualDiffOptions};

        let options = VisualDiffOptions::default();

        // Frontmatter visual diff (if changed)
        if delta.frontmatter_changed {
            let fm_original = original.frontmatter_as_yaml();
            let fm_updated = updated.frontmatter_as_yaml();

            println!("\n{BOLD}Frontmatter Changes:{RESET}");
            println!("{}", render_visual_diff(
                &fm_original,
                &fm_updated,
                "original",
                "updated",
                &options
            ));
        }

        // Content body visual diff (if content changed)
        if delta.has_content_changes() {
            let body_original = original.content_body();
            let body_updated = updated.content_body();

            println!("\n{BOLD}Content Changes:{RESET}");
            println!("{}", render_visual_diff(
                &body_original,
                &body_updated,
                "original",
                "updated",
                &options
            ));
        }
    }
}
```

Note: May need to add helper methods to `Markdown` struct:

- `frontmatter_as_yaml() -> String`
- `content_body() -> String` (content after frontmatter)

---

## Visual Design

### Side-by-Side Mode (>110 cols)

```
┌─ test.md                          │ t2.md ─────────────────────────────┐
│  1 │ ---                          │   1 │ ---                          │
│  2 │ title: Original              │   2 │ title: Updated               │
│    │        ~~~~~~~~              │     │        ~~~~~~~               │
│  3 │ ---                          │   3 │ tags: [new]                  │
│    │                              │   4 │ ---                          │
│  4 │                              │   5 │                              │
│  5 │ # Introduction               │   6 │ # Introduction               │
│  6 │ Some text here.              │   7 │ Some modified text here.     │
│    │                              │     │     ~~~~~~~~                 │
└────┴──────────────────────────────┴─────┴──────────────────────────────┘
```

Colors:

- Line 2: Both sides have light yellow background, "Original"/"Updated" highlighted
- Line 3 left: Red background (removed)
- Lines 3-4 right: Green background (added)
- Line 7: Yellow background with "modified " in brighter highlight

### Unified Mode (<=110 cols)

```
─── test.md → t2.md ───
  1    1 │ ---
- 2      │ title: Original
+      2 │ title: Updated
- 3      │ ---
+      3 │ tags: [new]
+      4 │ ---
  4    5 │
  5    6 │ # Introduction
- 6      │ Some text here.
+      7 │ Some modified text here.
```

---

## Color Palette (Theme-Aware)

Use colors that work with both light and dark themes:

| Element | Dark Theme | Light Theme |
|---------|------------|-------------|
| Removed line bg | `#3f1f1f` (dark red) | `#ffeef0` (light red) |
| Added line bg | `#1f3f1f` (dark green) | `#e6ffec` (light green) |
| Changed char (in removed) | `#ff6b6b` (bright red) | `#cb2431` (red) |
| Changed char (in added) | `#69db7c` (bright green) | `#22863a` (green) |
| Line numbers | dim/gray | dim/gray |
| Separator | dim `│` | dim `│` |

Detect dark/light via existing `ColorMode` in themes.rs.

---

## Files to Modify

| File | Changes |
|------|---------|
| `shared/Cargo.toml` | Add `similar = { version = "2.6", features = ["inline"] }` |
| `shared/src/markdown/delta/mod.rs` | Add `pub mod visual;` export |
| `shared/src/markdown/delta/visual/mod.rs` | **New** - Public API |
| `shared/src/markdown/delta/visual/diff.rs` | **New** - Diff computation |
| `shared/src/markdown/delta/visual/side_by_side.rs` | **New** - Wide renderer |
| `shared/src/markdown/delta/visual/unified.rs` | **New** - Narrow renderer |
| `shared/src/markdown/mod.rs` | Possibly add frontmatter/body helpers |
| `md/src/main.rs` | Integrate visual diff in `print_delta()` |

---

## Verification Plan

1. **Unit tests** for diff computation:
   - Empty files
   - Identical files
   - Pure additions/removals
   - Mixed changes with inline highlighting

2. **Integration tests**:
   - Create test markdown files with known differences
   - Verify side-by-side output at 120 columns
   - Verify unified output at 80 columns

3. **Manual testing**:

   ```bash
   # Side-by-side (wide terminal)
   md test.md --delta t2.md -v

   # Force narrow (resize terminal or set COLUMNS=80)
   COLUMNS=80 md test.md --delta t2.md -v

   # Verify frontmatter-only changes
   # Verify content-only changes
   # Verify mixed changes
   ```

4. **Edge cases**:
   - Very long lines (wrapping behavior)
   - Unicode content (emoji, CJK characters)
   - ANSI codes in source content
   - Empty frontmatter vs populated
   - Files with no frontmatter

---

## Design Decisions (Confirmed)

| Decision | Choice |
|----------|--------|
| Context lines | 3 lines around each change |
| Hunk separators | None (clean output) |
| File labels | Actual filenames from CLI args |
| Syntax highlighting | **Full** - see below |

### Syntax Highlighting Strategy

The visual diff should apply **layered** syntax highlighting using the existing `two-face` integration (which provides bat's extended grammars - richer than syntect's built-in set):

1. **Frontmatter section**: YAML grammar via `two-face`
2. **Content body prose**: Markdown grammar via `two-face`
3. **Fenced code blocks**: Language-specific grammar based on info string (e.g., `rust`, `typescript`)

This means the rendering pipeline is:

```
Source text
    ↓
Diff computation (line-level + inline changes)
    ↓
Syntax highlighting (two-face grammars, per-region selection)
    ↓
Diff color overlay (add/remove backgrounds)
    ↓
Terminal output
```

The existing `two-face` theme system in `shared/src/markdown/highlighting/` provides the foundation. Key files:

- `themes.rs` - `ThemePair` enum, light/dark detection, theme loading
- `grammars.rs` - Grammar loading and syntax set management

The challenge is combining syntax highlighting spans with diff change spans without them conflicting.

**Implementation approach:**

1. Apply syntax highlighting first via `two-face` to get styled spans
2. Overlay diff background colors on top of syntax foreground colors
3. For inline character changes, use inverse/bold on top of existing styles
