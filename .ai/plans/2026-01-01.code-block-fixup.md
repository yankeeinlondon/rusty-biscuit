# Code Block Fixup Implementation Plan

**Created:** 2026-01-01
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2026-01-01

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. Added `color_mode: ColorMode` parameter sourcing clarification for all color-aware functions
2. Made highlight color calculation theme-aware (dark vs light mode)
3. Added explicit ANSI reset verification to acceptance criteria
4. Clarified left padding position (after line number gutter, before code content)
5. Added ANSI escape code verification tests (not just text content)
6. Added interaction tests (highlighting + line numbers + title combinations)
7. Added helper function extraction recommendations for DRY code

**Resolved Concerns:**
- Header row layout → Use simple left-to-right (title then language) for MVP; right-align is deferred
- Highlight color saturation → Use `min(235)` cap to avoid pure white on dark themes
- ColorMode parameter → Source from `options.color_mode` in `write_terminal()` call site
- Padding position → After line number gutter, before syntax-highlighted code

## Executive Summary

This plan implements three improvements to code block rendering in terminal output: (1) padding around code blocks for visual breathing room, (2) enhanced title/language header row with proper styling, and (3) complete DSL support for line numbering and line highlighting.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Add one blank row padding above code blocks (with theme background, full width) | High | Rust Developer |
| FR-2 | Add one blank row padding below code blocks (with theme background, full width) | High | Rust Developer |
| FR-3 | Add one character left padding on each code line (with theme background) | High | Rust Developer |
| FR-4 | Render title on left side of header row: `▌${title} ` with theme background | High | Rust Developer |
| FR-5 | Render language on right side of header row: ` ${language} ` with theme background | High | Rust Developer |
| FR-6 | Default language to "text" when not specified | Medium | Rust Developer |
| FR-7 | Title/language text color: WHITE in dark mode, BLACK in light mode | High | Rust Developer |
| FR-8 | Title text should be bold | Medium | Rust Developer |
| FR-9 | Support `line-numbering=true` DSL attribute | High | Rust Developer |
| FR-10 | Support `highlight=N`, `highlight=N-M`, `highlight=N-M,P` DSL attributes | High | Rust Developer |
| FR-11 | Apply highlight background color to highlighted lines | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | No regression in existing code block rendering | 100% passing tests | Feature Tester (Rust) |
| NFR-2 | Maintain performance for large code blocks | No measurable regression | Rust Developer |
| NFR-3 | Consistent styling across color modes (light/dark) | Visual parity | Rust Developer |

## Architecture Overview

The changes are localized to `shared/src/markdown/output/terminal.rs` with minor touches to the DSL parser verification. The existing architecture already supports:

- **DSL Parsing:** `shared/src/markdown/dsl/parser.rs` - Already parses `title`, `line-numbering`, and `highlight` attributes
- **Code Block Rendering:** `highlight_code()` function in `terminal.rs` - Renders syntax-highlighted code with optional line numbers
- **Title Formatting:** `format_title()` function - Currently renders `▌ {title}` with bold

### Component Changes

```
shared/src/markdown/output/terminal.rs
├── format_header_row() - NEW: Renders title (left) + language (right) with theme background
├── format_title() - MODIFY: Remove (functionality moves to format_header_row)
├── highlight_code() - MODIFY: Add padding, integrate highlighting
└── write_terminal() - MODIFY: Use new header row format
```

### Data Flow

```
Markdown Input
     │
     ▼
┌─────────────────────┐
│ pulldown-cmark      │
│ Parser              │
└─────────────────────┘
     │ Event::Start(Tag::CodeBlock(kind))
     ▼
┌─────────────────────┐
│ parse_code_info()   │  ← DSL parsing (already implemented)
│ Returns:            │
│  - language         │
│  - title            │
│  - line_numbering   │
│  - highlight spec   │
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ format_header_row() │  ← NEW: Title + Language header
│ Returns:            │
│  - Styled header    │
│  - Full width bg    │
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ Blank padding row   │  ← NEW: Theme background, full width
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ highlight_code()    │  ← MODIFIED:
│ Per-line:           │
│  - 1 char padding   │  ← NEW
│  - Line numbers     │  (already implemented)
│  - Syntax color     │  (already implemented)
│  - Highlight bg     │  ← NEW: For highlighted lines
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ Blank padding row   │  ← NEW: Theme background, full width
└─────────────────────┘
```

## Phases

### Phase 1: Code Block Padding

**Principal Owner:** Rust Developer

**Goal:** Add visual breathing room around code blocks with theme-aware padding.

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Modify `highlight_code()` function

**Technical Details:**

1. In `highlight_code()`, emit a blank line BEFORE the first code line:
   - Set background color to theme's background
   - Emit spaces to fill terminal width OR use `\x1b[K` (clear to end of line with current background)
   - Reset colors
   - Emit newline

2. In `highlight_code()`, emit a blank line AFTER the last code line:
   - Same approach as above

3. Prepend each code line with 1 character of padding:
   - The padding space is emitted AFTER the line number gutter (if present) but BEFORE the syntax-highlighted code content
   - After setting background color, emit a single space before the code content
   - This applies to both line-numbered and non-line-numbered output

4. Extract padding row emission to helper function for DRY:
   ```rust
   fn emit_padding_row(bg_color: Color) -> String {
       format!("\x1b[48;2;{};{};{}m\x1b[K\x1b[0m\n", bg_color.r, bg_color.g, bg_color.b)
   }
   ```

**Code Changes:**

```rust
// In highlight_code(), before the line loop:
// Emit top padding row
output.push_str(&format!(
    "\x1b[48;2;{};{};{}m\x1b[K\x1b[0m\n",
    bg_color.r, bg_color.g, bg_color.b
));

// In the line loop, after setting background:
output.push(' '); // 1-char left padding

// After the line loop:
// Emit bottom padding row
output.push_str(&format!(
    "\x1b[48;2;{};{};{}m\x1b[K\x1b[0m",
    bg_color.r, bg_color.g, bg_color.b
));
```

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/terminal.rs` contains function `emit_padding_row()` (helper)
- [ ] File `shared/src/markdown/output/terminal.rs` contains top padding logic in `highlight_code()`
- [ ] File `shared/src/markdown/output/terminal.rs` contains bottom padding logic in `highlight_code()`
- [ ] File `shared/src/markdown/output/terminal.rs` contains 1-char left padding per line
- [ ] Bottom padding emits `\x1b[0m` reset after background (no leaked ANSI state)
- [ ] `cargo test -p shared --lib markdown::output::terminal` passes
- [ ] Existing tests still pass: `test_for_terminal_code_block`, `test_for_terminal_with_line_numbers`
- [ ] New test `test_code_block_padding` verifies blank rows above/below
- [ ] New test `test_code_block_left_padding` verifies 1-char left padding
- [ ] New test `test_code_block_padding_uses_theme_background` verifies padding has correct ANSI bg codes

---

### Phase 2: Header Row with Title and Language

**Principal Owner:** Rust Developer

**Goal:** Create a properly formatted header row showing title (left) and language (right) with theme-aware styling.

**Dependencies:** None (can run in parallel with Phase 1)

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Add `format_header_row()`, modify call sites

**Technical Details:**

1. Create new function `format_header_row()`:
   ```rust
   fn format_header_row(
       title: Option<&str>,
       language: &str,
       bg_color: Color,
       color_mode: ColorMode,
   ) -> String
   ```

2. Source `color_mode` from `options.color_mode` at the call site in `write_terminal()`.

3. Extract text color logic to helper function:
   ```rust
   fn header_text_color(color_mode: ColorMode) -> (u8, u8, u8) {
       match color_mode {
           ColorMode::Dark => (255, 255, 255),  // WHITE
           ColorMode::Light => (0, 0, 0),       // BLACK
       }
   }
   ```

5. Build left side (title):
   - If title present: `▌{title} ` with theme background and bold
   - If no title: empty string

6. Build right side (language):
   - Default to "text" if language is empty
   - Format: ` {language} ` with theme background (not bold)

7. Render the full header row (left-to-right layout for MVP):
   - The row itself has NO background (terminal default)
   - Only the title and language spans have theme background
   - Title is left-aligned, language follows immediately (right-alignment deferred to future enhancement)

**Code Example:**

```rust
fn format_header_row(
    title: Option<&str>,
    language: &str,
    bg_color: Color,
    color_mode: ColorMode,
) -> String {
    let text_color = match color_mode {
        ColorMode::Dark => (255, 255, 255),  // WHITE
        ColorMode::Light => (0, 0, 0),       // BLACK
    };

    let lang = if language.is_empty() { "text" } else { language };

    let mut output = String::new();

    // Left side: title (if present)
    if let Some(t) = title {
        // Bold + BG + FG + title + space + reset
        output.push_str(&format!(
            "\x1b[1m\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m▌{} \x1b[0m",
            bg_color.r, bg_color.g, bg_color.b,
            text_color.0, text_color.1, text_color.2,
            t
        ));
    }

    // MVP: Left-to-right layout (title then language)
    // Future enhancement: right-align language using terminal_width parameter

    // Right side: language
    // BG + FG + space + lang + space + reset
    output.push_str(&format!(
        "\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m {} \x1b[0m",
        bg_color.r, bg_color.g, bg_color.b,
        text_color.0, text_color.1, text_color.2,
        lang
    ));

    output
}
```

8. Update `write_terminal()` to use new function instead of `format_title()`.

9. Mark `format_title()` as deprecated with `#[deprecated]` attribute (remove in Phase 4 after verifying no other call sites).

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/terminal.rs` contains function `format_header_row()` with >20 lines
- [ ] File `shared/src/markdown/output/terminal.rs` contains function `header_text_color()` (helper)
- [ ] `grep "fn format_header_row" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `color_mode` parameter sourced from `options.color_mode` at call site
- [ ] Function handles both dark and light color modes
- [ ] Language defaults to "text" when empty
- [ ] Title is bold, language is not bold
- [ ] `cargo test -p shared --lib markdown::output::terminal` passes
- [ ] New test `test_header_row_with_title` verifies title+language output
- [ ] New test `test_header_row_no_title` verifies language-only output
- [ ] New test `test_header_row_default_language` verifies "text" default
- [ ] New test `test_header_row_dark_mode` verifies white text color (ANSI code `\x1b[38;2;255;255;255m`)
- [ ] New test `test_header_row_light_mode` verifies black text color (ANSI code `\x1b[38;2;0;0;0m`)
- [ ] New test `test_header_row_bold_title` verifies title has `\x1b[1m` bold code
- [ ] New test `test_header_row_no_bold_language` verifies language does NOT have bold code

---

### Phase 3: Line Highlighting Implementation

**Principal Owner:** Rust Developer

**Goal:** Apply visual highlighting to specified lines in code blocks.

**Dependencies:** Phase 1 (padding changes are in same function)

**Blast Radius:** `cargo test -p shared --lib markdown::output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Modify `highlight_code()` function

**Technical Details:**

1. The DSL parsing already handles `highlight=...` and produces a `HighlightSpec`.

2. In `highlight_code()`, for each line:
   - Check if `meta.highlight.contains(line_number)`
   - If highlighted, use a distinct background color (subtle yellow/amber tint)
   - If not highlighted, use normal theme background

3. Highlight color strategy (theme-aware):
   - Dark themes: add slight yellow/amber tint (+30 R, +25 G), capped at 235 to avoid pure white
   - Light themes: subtract slightly from R/G channels (-20 R, -15 G) for subtle darkening
   - Extract to helper function for clarity:
   ```rust
   fn compute_highlight_bg(theme_bg: Color, color_mode: ColorMode) -> Color {
       match color_mode {
           ColorMode::Dark => Color {
               r: theme_bg.r.saturating_add(30).min(235),
               g: theme_bg.g.saturating_add(25).min(235),
               b: theme_bg.b,
               a: 255,
           },
           ColorMode::Light => Color {
               r: theme_bg.r.saturating_sub(20),
               g: theme_bg.g.saturating_sub(15),
               b: theme_bg.b,
               a: 255,
           },
       }
   }
   ```

4. Ensure highlight applies to the entire line width (use `\x1b[K` to clear to end of line with highlight background).

**Code Changes:**

```rust
// In highlight_code(), inside the line loop:
let line_number = idx + 1;
let is_highlighted = meta.highlight.contains(line_number);

// Determine background color for this line (needs color_mode parameter)
let line_bg = if is_highlighted {
    compute_highlight_bg(bg_color, color_mode)
} else {
    bg_color
};

// Apply line background
output.push_str(&format!(
    "\x1b[48;2;{};{};{}m",
    line_bg.r, line_bg.g, line_bg.b
));
```

5. Update `highlight_code()` signature to accept `color_mode: ColorMode` parameter (sourced from `options.color_mode`).

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/terminal.rs` contains function `compute_highlight_bg()`
- [ ] File `shared/src/markdown/output/terminal.rs` `highlight_code()` checks `meta.highlight.contains()`
- [ ] `highlight_code()` accepts `color_mode` parameter
- [ ] Highlighted lines have visually distinct background color
- [ ] Non-highlighted lines use normal theme background
- [ ] Highlight extends to end of line (full width via `\x1b[K`)
- [ ] Dark theme highlights use capped saturation (`.min(235)`)
- [ ] Light theme highlights use subtraction (`.saturating_sub()`)
- [ ] `cargo test -p shared --lib markdown::output::terminal` passes
- [ ] New test `test_code_block_highlight_single_line` verifies single line highlighting
- [ ] New test `test_code_block_highlight_range` verifies range highlighting
- [ ] New test `test_code_block_highlight_mixed` verifies mixed single+range
- [ ] New test `test_highlight_with_line_numbers` verifies both features work together
- [ ] New test `test_highlight_dark_mode_color` verifies highlight uses additive tint
- [ ] New test `test_highlight_light_mode_color` verifies highlight uses subtractive tint

---

### Phase 4: Integration and Polish

**Principal Owner:** Rust Developer

**Goal:** Wire together all components and ensure consistent behavior across rendering paths.

**Dependencies:** Phases 1, 2, 3

**Blast Radius:** `cargo test -p shared --lib markdown`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Final integration in `write_terminal()`

**Technical Details:**

1. Ensure `write_terminal()` calls `format_header_row()` before the code block.

2. Ensure the header row is only emitted when there's a title OR a language (language always exists, defaulting to "text").

3. Verify line numbering + highlighting work together correctly.

4. Verify padding works with/without line numbers.

5. Clean up dead code:
   - Verify no other call sites for `format_title()` via `grep -r "format_title" shared/`
   - Remove deprecated `format_title()` function

6. Create a test fixture markdown file with all feature combinations for manual visual testing:
   - Location: `shared/test_data/code_block_features.md`
   - Content: All combinations of title/language/line-numbering/highlighting

**Acceptance Criteria:**
- [ ] `cargo test -p shared --lib markdown` passes (full markdown test suite)
- [ ] `grep -r "format_title" shared/` returns no results (function removed)
- [ ] All feature combinations work: title only, language only, title+language, with/without line numbers, with/without highlights
- [ ] New integration test `test_full_code_block_all_features` verifies complete code block with all features
- [ ] New integration test `test_empty_code_block` verifies padding renders correctly with 0 lines
- [ ] Test fixture file `shared/test_data/code_block_features.md` exists for manual testing

---

### Phase 5: Test Coverage and Documentation

**Principal Owner:** Feature Tester (Rust)

**Goal:** Ensure comprehensive test coverage and update documentation.

**Dependencies:** Phase 4

**Blast Radius:** `cargo test -p shared`

**Files to create/modify:**
- `shared/src/markdown/output/terminal.rs` - Add comprehensive tests
- `shared/docs/md/code-block-dsl.md` - Update with implementation status

**Technical Details:**

1. Add tests for each new feature:
   - Padding tests (top, bottom, left)
   - Header row tests (title/language combinations, color modes)
   - Highlighting tests (single, range, mixed, edge cases)

2. Add integration tests combining multiple features.

3. Update DSL documentation to reflect implementation status.

4. Add doc comments to new functions.

**Test Scenarios:**

| Scenario | Test Name | Description |
|----------|-----------|-------------|
| Top padding | `test_code_block_has_top_padding_row` | Verify blank row above code with theme bg |
| Bottom padding | `test_code_block_has_bottom_padding_row` | Verify blank row below code with theme bg |
| Left padding | `test_code_block_lines_have_left_padding` | Verify 1-char left padding per line |
| Padding + line numbers | `test_padding_preserves_line_numbers_alignment` | Padding doesn't break line number column alignment |
| Padding ANSI | `test_code_block_padding_uses_theme_background` | Padding has correct `\x1b[48;2;...` codes |
| Title only | `test_header_row_title_only` | Header with title, no explicit language |
| Language only | `test_header_row_language_only` | Header with language, no title |
| Both | `test_header_row_title_and_language` | Header with both title and language |
| Default lang | `test_header_row_defaults_to_text` | Empty language becomes "text" |
| Dark mode | `test_header_row_white_text_in_dark_mode` | Text color is white (`\x1b[38;2;255;255;255m`) |
| Light mode | `test_header_row_black_text_in_light_mode` | Text color is black (`\x1b[38;2;0;0;0m`) |
| Bold title | `test_header_row_bold_title` | Title has `\x1b[1m` bold code |
| No bold lang | `test_header_row_no_bold_language` | Language does NOT have bold code |
| Single highlight | `test_highlight_single_line` | `highlight=5` highlights line 5 |
| Range highlight | `test_highlight_range` | `highlight=4-6` highlights lines 4,5,6 |
| Mixed highlight | `test_highlight_mixed` | `highlight=1,4-6,10` works correctly |
| Highlight + line nums | `test_highlight_with_line_numbers` | Both features work together |
| Highlight dark mode | `test_highlight_dark_mode_color` | Uses additive tint (+30R, +25G) |
| Highlight light mode | `test_highlight_light_mode_color` | Uses subtractive tint (-20R, -15G) |
| Highlight full width | `test_highlight_entire_line_width` | Highlight background extends to EOL with `\x1b[K` |
| Edge: line 0 | `test_highlight_ignores_zero` | `highlight=0` has no effect (lines are 1-indexed) |
| Edge: out of range | `test_highlight_out_of_range` | `highlight=100` on 5-line code is ignored |
| Edge: empty block | `test_empty_code_block` | Empty code block still renders padding correctly |
| Combined | `test_full_code_block_all_features` | Title + line numbers + highlights |
| Combined + title | `test_highlight_title_line_numbers_combined` | All three features active |

**Acceptance Criteria:**
- [ ] All tests in test scenarios table are implemented
- [ ] `cargo test -p shared` passes with >95% of new tests passing
- [ ] Doc comments added to `format_header_row()`, updated `highlight_code()`
- [ ] `shared/docs/md/code-block-dsl.md` updated to mark features as implemented

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests:** In `terminal.rs` under `#[cfg(test)] mod tests`
- **Integration focus:** Test complete code block rendering paths
- **Helper functions:** Use existing `strip_ansi_codes()` from `testing` module
- **Visual verification:** Manual testing with `mat` binary for visual confirmation

### Security Considerations

None - changes are purely cosmetic rendering enhancements.

### Performance Considerations

- Avoid allocations in hot paths (reuse String buffers)
- The `\x1b[K` escape sequence is efficient for full-width background
- Highlight lookup is O(n) where n = number of highlight ranges (typically <5)

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1, Phase 2 | Independent changes: padding vs header row |
| Group B | Phase 3 | Depends on Phase 1 (modifies same function) |
| Group C | Phase 4 | Depends on all previous phases |
| Group D | Phase 5 | Depends on Phase 4 |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────►

Group A: ████████████ (Phase 1 + Phase 2 in parallel)
                     │
Group B:             └──████████ (Phase 3)
                              │
Group C:                      └──████ (Phase 4)
                                   │
Group D:                           └──████████ (Phase 5)
```

### Synchronization Points

1. **After Group A:** Both padding and header row functions must be complete
2. **After Group B:** Highlighting must be integrated with padding
3. **After Group C:** All features must be wired together in `write_terminal()`

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| ANSI escape codes break in some terminals | Medium | Test in multiple terminals (iTerm2, Terminal.app, VS Code) |
| `\x1b[K` not clearing properly | Low | Fallback to explicit space padding if needed |
| Highlight colors clash with syntax colors | Medium | Use subtle tint that doesn't override syntax highlighting |
| Right-align language requires terminal width | Low | Use simple spacing or omit right-align for MVP |

## Open Questions

- [x] ~~Should the language label be right-aligned on the header row, or is left-to-right (title then language) acceptable?~~ → **RESOLVED:** Use left-to-right layout for MVP. Right-alignment is a future enhancement.
- [x] ~~What specific highlight color should be used?~~ → **RESOLVED:** Theme-aware: Dark mode +30R/+25G (capped at 235), Light mode -20R/-15G.
- [ ] Should we add a visual indicator (like a marker in the gutter) for highlighted lines in addition to background color? → **DEFERRED to future enhancement**

## Answered Questions from Review

1. **Q: Where does `color_mode` come from for `format_header_row()`?**
   A: Source from `options.color_mode` at the call site in `write_terminal()`.

2. **Q: Are syntect's `Color` RGB fields public?**
   A: Yes, the existing code at line 1048 extracts `bg_color.r`, `bg_color.g`, `bg_color.b` successfully.

3. **Q: How to handle empty code blocks?**
   A: Still render padding rows (top and bottom) even when there are 0 lines of code. Add explicit test case.

4. **Q: What about Unicode in titles (like the `▌` character)?**
   A: The character is already in use and renders correctly. No additional handling needed for MVP.

## Appendix: ANSI Escape Code Reference

| Code | Effect |
|------|--------|
| `\x1b[1m` | Bold |
| `\x1b[0m` | Reset all |
| `\x1b[38;2;R;G;Bm` | Set foreground (24-bit) |
| `\x1b[48;2;R;G;Bm` | Set background (24-bit) |
| `\x1b[K` | Clear to end of line (uses current background) |
