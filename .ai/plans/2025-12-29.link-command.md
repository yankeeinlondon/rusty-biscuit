# Link Command Implementation

**Created:** 2025-12-29
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Implement a new `research link` CLI command that creates symbolic links from research topic skill directories to Claude Code (`~/.claude/skills/`) and OpenCode CLI (`~/.config/opencode/skill/`) user-scoped skill locations. The command will support filtering by glob patterns and topic types, with both terminal-friendly and JSON output formats. The implementation will reuse existing list command infrastructure for topic discovery and filtering.

## Review Summary

**Reviews Completed:** 2025-12-29

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. Enhanced error type design: Added error variants to `SkillAction` for richer failure reporting
2. Strengthened security: Added specific path validation tests, symlink target verification, and broken symlink handling
3. Improved API design: Changed `link()` to return `LinkResult` instead of `()` for inspectability
4. Clarified symlink creation semantics: Fixed parameter naming and added source validation
5. Enhanced test coverage: Added property-based tests, security scenarios, and edge case handling
6. Added skill directory validation: Verify `skill/SKILL.md` exists before creating symlinks
7. Improved error handling: Added granular error collection and asymmetric failure handling
8. Added missing dependencies: proptest for property-based testing

**Resolved Concerns:**
- **Async necessity** → Clarified: Using async for consistency with list command and future extensibility
- **Error type hierarchy** → Added `LinkError` to Phase 1, clarified error type relationships
- **Home directory resolution** → Explicitly using `dirs` crate with helper functions
- **Symlink security** → Added specific guidance on using `symlink_metadata()`, avoiding `canonicalize()`
- **Edge case handling** → Added detection for broken symlinks, wrong symlinks, and regular directories
- **Test coverage gaps** → Added proptest integration, security scenarios, and symlink target verification tests

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | CLI command accepts glob filters and type filters (same as `list` command) | High | Rust Developer |
| FR-2 | Discover all research topics using existing discovery logic | High | Rust Developer |
| FR-3 | Check for existing symlinks at Claude Code and OpenCode locations | High | Rust Developer |
| FR-4 | Check for local skill definitions that would conflict with symlink creation | High | Rust Developer |
| FR-5 | Create symlinks for topics that don't have existing symlinks or local definitions | High | Rust Developer |
| FR-6 | Output diagnostic information in terminal format (colors, formatting) | Medium | Rust Developer |
| FR-7 | Output diagnostic information in JSON format when `--json` flag used | Medium | Rust Developer |
| FR-8 | Handle errors gracefully (permission denied, filesystem issues) | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Performance | Process 100+ topics in <1s | Rust Developer |
| NFR-2 | Security | Validate symlink targets, prevent directory traversal | Rust Architect |
| NFR-3 | Reliability | Continue processing if individual symlink creation fails | Rust Developer |
| NFR-4 | Maintainability | Reuse existing list command infrastructure (DRY) | Rust Architect |
| NFR-5 | Usability | Clear diagnostic output showing what was linked/skipped | Rust Developer |
| NFR-6 | Compatibility | Work across macOS and Linux (no Windows symlink support needed) | Rust Developer |

## Architecture Overview

The link command will follow the same architecture pattern as the existing `list` command:

1. **CLI Layer** (`research/cli/src/main.rs`): Parse arguments using Clap
2. **Library Layer** (`research/lib/src/link/mod.rs`): Core linking logic
3. **Reuse Discovery**: Use `list::discovery::discover_topics` for finding topics
4. **Reuse Filtering**: Use `list::filter::apply_filters` for filtering topics
5. **Link Module**: New module with linking logic, symlink checking, and output formatting

### Component Diagram

```
CLI (main.rs)
    ↓
research_lib::link()
    ↓
┌─────────────────────────────────────────┐
│ Link Orchestration                      │
├─────────────────────────────────────────┤
│ 1. discover_topics() [reuse]            │
│ 2. apply_filters() [reuse]              │
│ 3. check_symlink_status() [new]         │
│ 4. create_symlinks() [new]              │
│ 5. format_output() [new]                │
└─────────────────────────────────────────┘
```

### Data Flow

```
User Input (filter, types, --json)
    ↓
Discover topics from $RESEARCH_DIR/.research/library/
    ↓
Apply glob and type filters
    ↓
For each topic:
  - Check ~/.claude/skills/{topic}/
  - Check ~/.config/opencode/skill/{topic}/
  - Determine action (create_link, skip_exists, skip_local)
    ↓
Create symlinks where needed (with error handling)
    ↓
Output results (terminal colors or JSON)
```

## Phases

### Phase 1: Link Module Core Types and CLI Integration

**Principal Owner:** Rust Developer

**Goal:** Create the link module structure, define types, and integrate with the CLI.

**Dependencies:** None

**Blast Radius:** `cargo test --lib link`

**Deliverables:**
- File: `research/lib/src/link/mod.rs` - Module entry point with public API
- File: `research/lib/src/link/types.rs` - SkillAction, SkillLink, LinkResult types
- File: `research/cli/src/main.rs` - Add Link subcommand to Commands enum
- Update: `research/lib/src/lib.rs` - Expose `pub mod link;` and `pub use link::link;`

**Technical Details:**
- Create `research/lib/src/link/` directory
- Define Rust enums and structs with enhanced error reporting:
  ```rust
  #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
  #[serde(rename_all = "snake_case")]
  pub enum SkillAction {
      CreatedLink,
      NoneAlreadyLinked,
      NoneLocalDefinition,
      NoneSkillDirectoryInvalid,  // Source skill/ doesn't exist or no SKILL.md
      FailedPermissionDenied(String),
      FailedOther(String),
  }

  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct SkillLink {
      pub name: String,
      pub claude_action: SkillAction,
      pub opencode_action: SkillAction,
  }

  #[derive(Debug)]
  pub struct LinkResult {
      pub links: Vec<SkillLink>,
      pub errors: Vec<(String, String)>,  // (topic_name, error_message)
  }

  #[derive(Debug, Error)]
  pub enum LinkError {
      #[error("Discovery failed: {0}")]
      Discovery(#[from] DiscoveryError),
      #[error("Filter failed: {0}")]
      Filter(#[from] FilterError),
      #[error("Failed to determine home directory")]
      HomeDirectory,
      #[error("I/O error: {0}")]
      Io(#[from] std::io::Error),
  }
  ```
- **IMPORTANT:** Using `async fn link()` for consistency with list command and future extensibility, even though symlink operations are synchronous
- Add Link variant to Commands enum in CLI with Clap attributes:
  ```rust
  Link {
      #[arg(value_name = "FILTER")]
      filters: Vec<String>,
      #[arg(short = 't', long = "type")]
      types: Vec<String>,
      #[arg(long)]
      json: bool,
  }
  ```
- Stub implementation of `pub async fn link(filters: Vec<String>, types: Vec<String>, json: bool) -> Result<LinkResult, LinkError>`
  - **Note:** Return `LinkResult` instead of `()` so callers can inspect what was linked

**Acceptance Criteria:**
- [ ] File `research/lib/src/link/mod.rs` exists with >30 lines
- [ ] File `research/lib/src/link/types.rs` exists with >120 lines (expanded for error variants)
- [ ] `grep "pub mod link" research/lib/src/lib.rs` succeeds
- [ ] `grep "pub use link::link" research/lib/src/lib.rs` succeeds
- [ ] `grep "Link {" research/cli/src/main.rs` succeeds
- [ ] `grep "LinkError" research/lib/src/link/types.rs` succeeds
- [ ] `grep "SkillAction::FailedPermissionDenied" research/lib/src/link/types.rs` succeeds
- [ ] Cargo.toml includes `proptest = "1"` in `[dev-dependencies]`
- [ ] `cargo build` succeeds
- [ ] `cargo test --lib link` runs (even if 0 tests initially)

---

### Phase 2: Symlink Detection Logic

**Principal Owner:** Rust Developer

**Goal:** Implement logic to detect existing symlinks and local skill definitions.

**Dependencies:** Phase 1

**Blast Radius:** `cargo test --lib link::detection`

**Deliverables:**
- File: `research/lib/src/link/detection.rs` - Symlink and local definition checking
- Add to module exports in `research/lib/src/link/mod.rs`

**Technical Details:**
- Create helper functions for directory resolution using `dirs` crate:
  ```rust
  fn get_claude_skills_dir() -> Result<PathBuf, DetectionError> {
      let home = dirs::home_dir().ok_or(DetectionError::HomeDirectoryNotFound)?;
      Ok(home.join(".claude/skills"))
  }

  fn get_opencode_skills_dir() -> Result<PathBuf, DetectionError> {
      let home = dirs::home_dir().ok_or(DetectionError::HomeDirectoryNotFound)?;
      Ok(home.join(".config/opencode/skill"))
  }
  ```
- Create detection functions:
  ```rust
  pub fn check_symlink_exists(path: &Path) -> bool
  pub fn check_is_symlink(path: &Path) -> bool
  pub fn check_is_broken_symlink(path: &Path) -> bool
  pub fn check_local_definition_exists(path: &Path) -> bool
  pub fn validate_skill_source(path: &Path) -> bool  // Verify skill/SKILL.md exists
  pub fn determine_action(target_path: &Path, source_path: &Path) -> SkillAction
  ```
- **CRITICAL SECURITY:** Use `std::fs::symlink_metadata()` to check for symlinks WITHOUT following them
  - **NEVER** use `fs::metadata()` or `fs::canonicalize()` on target paths before determining if they're symlinks
  - `canonicalize()` follows symlinks which could introduce vulnerabilities
- Use `path.is_symlink()` for symlink detection (requires Rust 1.58+, verify in Cargo.toml)
- Check if path exists and is NOT a symlink → local definition
- Detect broken symlinks: `is_symlink() && !exists()` (symlink exists but target doesn't)
- Security: Validate that target paths are within expected directories (no traversal)
  - Use string-based path validation (ensure targets start with expected prefixes)
  - Reject paths with `..` components
  - Reject absolute paths outside safe zones

**Acceptance Criteria:**
- [ ] File `research/lib/src/link/detection.rs` exists with >200 lines (expanded for security)
- [ ] Function `check_symlink_exists` has 8+ unit tests including broken symlinks
- [ ] Function `check_is_symlink` has 5+ unit tests
- [ ] Function `check_is_broken_symlink` has 5+ unit tests
- [ ] Function `check_local_definition_exists` has 5+ unit tests
- [ ] Function `validate_skill_source` has 5+ unit tests (missing SKILL.md, empty dir, etc.)
- [ ] Function `determine_action` has 15+ unit tests covering all SkillAction variants
- [ ] All tests use tempfile for filesystem isolation and verify cleanup
- [ ] Security test: `determine_action` rejects paths with `..` components
- [ ] Security test: `determine_action` rejects paths outside allowed directories
- [ ] Security test: Creates symlink pointing to /tmp, verifies detected as existing symlink (not followed)
- [ ] Property-based test (proptest): `determine_action` is idempotent (same inputs = same output)
- [ ] Property-based test (proptest): Path validation rejects all forms of traversal
- [ ] `cargo test --lib link::detection` passes all tests

---

### Phase 3: Symlink Creation Logic

**Principal Owner:** Rust Developer

**Goal:** Implement safe symlink creation with error handling.

**Dependencies:** Phase 2

**Blast Radius:** `cargo test --lib link::creation`

**Deliverables:**
- File: `research/lib/src/link/creation.rs` - Symlink creation functions
- Add to module exports in `research/lib/src/link/mod.rs`

**Technical Details:**
- Create functions (note parameter naming matches std::os::unix::fs::symlink semantics):
  ```rust
  // Creates symlink at `symlink_location` pointing to `skill_dir`
  pub fn create_skill_symlink(skill_dir: &Path, symlink_location: &Path) -> Result<(), CreationError>
  pub fn ensure_parent_directory(path: &Path) -> Result<(), std::io::Error>
  pub fn validate_skill_directory(path: &Path) -> Result<(), CreationError>
  ```
- **IMPORTANT:** `std::os::unix::fs::symlink(original, link)` takes *target* as first arg, *link path* as second
  - Our function: `create_skill_symlink(skill_dir, symlink_location)` matches this convention
  - `skill_dir` is the original (target) - e.g., `~/.research/library/clap/skill/`
  - `symlink_location` is the link path - e.g., `~/.claude/skills/clap`
- Use `std::os::unix::fs::symlink()` for Unix-like systems (macOS, Linux)
- Create **absolute symlinks** for robustness (moving .claude directory won't break links)
- Create parent directories if needed (`~/.claude/skills/` or `~/.config/opencode/skill/`)
- Error handling with thiserror:
  ```rust
  #[derive(Debug, Error)]
  pub enum CreationError {
      #[error("Invalid source: skill directory missing or invalid: {0}")]
      InvalidSource(PathBuf),
      #[error("Failed to create parent directory: {0}")]
      ParentDirectory(#[source] std::io::Error),
      #[error("Failed to create symlink: {0}")]
      SymlinkCreation(#[source] std::io::Error),
  }
  ```
- Use `std::fs::create_dir_all()` for parent directory creation
- Validate source path before creating symlink:
  ```rust
  pub fn create_skill_symlink(skill_dir: &Path, symlink_location: &Path) -> Result<(), CreationError> {
      // Validate source exists and contains SKILL.md
      validate_skill_directory(skill_dir)?;

      // Create parent directory if needed
      ensure_parent_directory(symlink_location)?;

      // Create symlink (Unix-specific, absolute path)
      std::os::unix::fs::symlink(skill_dir, symlink_location)
          .map_err(CreationError::SymlinkCreation)?;

      Ok(())
  }
  ```

**Acceptance Criteria:**
- [ ] File `research/lib/src/link/creation.rs` exists with >130 lines (expanded for validation)
- [ ] Function `create_skill_symlink` has 10+ unit tests
- [ ] Function `ensure_parent_directory` has 5+ unit tests (including idempotency test)
- [ ] Function `validate_skill_directory` has 5+ unit tests (missing SKILL.md, not a directory, etc.)
- [ ] Tests verify symlink creation using tempfile directories
- [ ] Tests verify parent directory creation
- [ ] Tests verify error handling when parent directory creation succeeds but symlink fails
- [ ] Tests verify source path validation (missing, no SKILL.md, etc.)
- [ ] Tests verify absolute vs relative symlink creation (should be absolute)
- [ ] `cargo test --lib link::creation` passes all tests

---

### Phase 4: Link Orchestration and Integration

**Principal Owner:** Rust Developer

**Goal:** Implement the main link function that orchestrates discovery, filtering, and linking.

**Dependencies:** Phase 3

**Blast Radius:** `cargo test --lib link`

**Deliverables:**
- Update: `research/lib/src/link/mod.rs` - Implement full `link()` function
- File: `research/lib/src/link/orchestration.rs` (optional, if logic is complex)

**Technical Details:**
- Implement `pub async fn link(filters: Vec<String>, types: Vec<String>, json: bool) -> Result<LinkResult, LinkError>`
  - **Note:** Returns `LinkResult` for caller inspectability (not `()`)
- Reuse `list::discovery::discover_topics()` for finding research topics
- Reuse `list::filter::apply_filters()` for glob and type filtering
- For each filtered topic:
  1. Get source path: `{topic.location}/skill/`
  2. Validate source (check skill/SKILL.md exists) - if invalid, set action to `NoneSkillDirectoryInvalid`
  3. Check Claude Code: determine action for `~/.claude/skills/{topic.name}`
  4. Check OpenCode: determine action for `~/.config/opencode/skill/{topic.name}`
  5. Attempt symlink creation where action should be `CreatedLink`
  6. Collect results into `SkillLink` entries
- Error handling (graceful degradation):
  - If individual symlink creation fails (permission denied, IO error):
    - Update `SkillAction` to `FailedPermissionDenied` or `FailedOther`
    - Log with `tracing::error!()` (not just warn - these are user-facing errors)
    - Continue processing other topics and services
    - Add to `LinkResult.errors` vec
  - If both Claude Code and OpenCode fail for a topic, still record the SkillLink
- Asymmetric failure handling:
  - Claude Code creation succeeds, OpenCode fails → Record both actions separately
  - One service may have `CreatedLink`, the other `FailedPermissionDenied`
- Use `#[instrument]` attribute for automatic tracing span
- Return `LinkResult { links: Vec<SkillLink>, errors: Vec<(String, String)> }`

**Acceptance Criteria:**
- [ ] Function `link()` in `research/lib/src/link/mod.rs` is >150 lines (expanded for error handling)
- [ ] `grep "discover_topics" research/lib/src/link/mod.rs` succeeds
- [ ] `grep "apply_filters" research/lib/src/link/mod.rs` succeeds
- [ ] `grep "#\[instrument\]" research/lib/src/link/mod.rs` succeeds
- [ ] Integration tests in `research/lib/tests/link_integration_test.rs` exist with 8+ tests
- [ ] Tests use tempfile for full end-to-end scenarios and verify cleanup
- [ ] Tests verify filtering works correctly (glob patterns and type filters)
- [ ] Tests verify symlink creation for multiple topics
- [ ] Test: End-to-end discover -> filter -> link with mixed scenarios
- [ ] Test: Error handling - continue processing when one symlink fails mid-batch (verify other 4 succeed)
- [ ] Test: Asymmetric failure - Claude Code succeeds, OpenCode fails for same topic
- [ ] Test: Empty filter result produces no symlinks but no error
- [ ] Test: Topic has no skill directory (missing `skill/SKILL.md`) - verify `NoneSkillDirectoryInvalid`
- [ ] Test: Idempotency - running command twice produces same result
- [ ] `cargo test link` passes all tests (unit + integration)

---

### Phase 5: Output Formatting

**Principal Owner:** Rust Developer

**Goal:** Implement terminal and JSON output formatting for link results.

**Dependencies:** Phase 4

**Blast Radius:** `cargo test --lib link::format`

**Deliverables:**
- File: `research/lib/src/link/format.rs` - Terminal and JSON formatting
- Update: `research/lib/src/link/mod.rs` - Call formatting functions
- Update: `research/cli/src/main.rs` - Handle link command output

**Technical Details:**
- Create functions (library returns data, CLI decides whether to call terminal or JSON formatter):
  ```rust
  pub fn format_terminal(result: &LinkResult) -> String
  pub fn format_json(result: &LinkResult) -> Result<String, serde_json::Error>
  ```
- Terminal output using owo-colors with explicit color scheme:
  - **Topic name:** bold
  - **"added link":** green (success)
  - **"already linked":** dim + italic (skip)
  - **"local definition":** yellow (warning-like)
  - **Service names (Claude Code, OpenCode):** normal weight when both, italic when only one
  - **Failed actions:** red with error message
- Terminal format examples:
  - Both created: `- clap: added link to both Claude Code and OpenCode` (green)
  - One created: `- clap: Claude Code already linked, created link for OpenCode` (partial green)
  - Already linked: `- clap: already linked` (dim, italic)
  - Local definition: `- clap: already had a local definition for this skill` (yellow)
  - Invalid skill dir: `- clap: skill directory invalid (no SKILL.md)` (yellow)
  - Permission denied: `- clap: failed to create link (permission denied)` (red)
- JSON output: Serialize `LinkResult { links, errors }` using serde_json
  - Include all `SkillAction` variants in serialized output
  - Errors are separate array for structured parsing
- Match output format style from list command (terminal-friendly with colors)

**Acceptance Criteria:**
- [ ] File `research/lib/src/link/format.rs` exists with >180 lines (expanded for all action variants)
- [ ] Function `format_terminal` has 12+ unit tests verifying all SkillAction combinations
- [ ] Function `format_json` has 5+ unit tests
- [ ] Tests verify color codes for success (green), warning (yellow), error (red), skip (dim)
- [ ] Test: Output when zero topics processed (empty result)
- [ ] Test: Output with mixed actions (some created, some failed, some skipped)
- [ ] Terminal output uses owo-colors (bold, dim, italic, green, yellow, red)
- [ ] JSON output is valid and parseable (test with serde_json::from_str roundtrip)
- [ ] `cargo test --lib link::format` passes all tests
- [ ] Manual test: `cargo run --bin research -- link --json` produces valid JSON

---

### Phase 6: CLI Wiring and End-to-End Testing

**Principal Owner:** Rust Developer

**Goal:** Complete CLI integration and perform end-to-end testing.

**Dependencies:** Phase 5

**Blast Radius:** `cargo test` (full test suite)

**Deliverables:**
- Update: `research/cli/src/main.rs` - Complete Link command handling
- File: `research/lib/tests/link_e2e_test.rs` - End-to-end integration tests
- Update: `research/docs/commands/link.md` - Update with implementation details if needed

**Technical Details:**
- In `research/cli/src/main.rs`, match on `Commands::Link`:
  ```rust
  Commands::Link { filters, types, json } => {
      match research_lib::link(filters, types, json).await {
          Ok(()) => {
              // Success - output already written to stdout
          }
          Err(e) => {
              eprintln!("Link failed: {}", e);
              std::process::exit(1);
          }
      }
  }
  ```
- End-to-end tests:
  - Create temp research directory with topics
  - Create temp Claude Code and OpenCode directories
  - Run link command with various filters
  - Verify symlinks created correctly
  - Verify output format (both terminal and JSON)
- Test scenarios:
  - Empty research directory
  - Topics with existing symlinks
  - Topics with local definitions
  - Type filtering (`-t library`)
  - Glob filtering (`foo*`)
  - Combined filters
  - Permission errors (if possible to simulate)

**Acceptance Criteria:**
- [ ] `research/cli/src/main.rs` handles `Commands::Link` correctly
- [ ] File `research/lib/tests/link_e2e_test.rs` exists with 10+ tests
- [ ] `cargo test` passes all tests (full suite)
- [ ] `cargo build --release` succeeds
- [ ] Manual test: `research link` with no args works
- [ ] Manual test: `research link -t library` filters correctly
- [ ] Manual test: `research link foo*` filters by glob pattern
- [ ] Manual test: `research link --json` outputs valid JSON
- [ ] Manual verification: Symlinks created at correct locations
- [ ] Manual verification: Error messages are helpful

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests**: Each module (types, detection, creation, format) has comprehensive unit tests
  - Use `#[cfg(test)] mod tests` blocks
  - Use `tempfile::TempDir` for filesystem isolation
  - Test all edge cases and error conditions
- **Integration tests**: `tests/link_integration_test.rs` for multi-module scenarios
- **End-to-end tests**: `tests/link_e2e_test.rs` for full CLI workflow
- **Property-based tests**: Consider proptest for:
  - Glob pattern matching
  - Path validation
- **Manual tests**: Real-world usage with actual research directory

### Security Considerations

- **Symlink target validation**: Prevent directory traversal attacks
  - Validate source paths are within `$RESEARCH_DIR/.research/library/`
  - Validate target paths are within `~/.claude/skills/` or `~/.config/opencode/skill/`
- **Filesystem permissions**: Handle permission denied errors gracefully
- **Symlink following**: Use `symlink_metadata()` to avoid following symlinks during checks
- **Path canonicalization**: Use `fs::canonicalize()` carefully to avoid TOCTOU races
- **No arbitrary file operations**: Only create symlinks, never delete or modify existing files

### Performance Considerations

- **Parallel processing**: Not needed for initial implementation (topic count is low)
  - Future optimization: Use rayon to check symlinks in parallel
- **Filesystem operations**: Minimize `stat()` calls
  - Check symlink existence before attempting creation
- **Filtering efficiency**: Reuse existing optimized filtering from list command
- **Memory usage**: Process topics in streaming fashion (iterator), not all in memory

### Error Handling

- **thiserror for library errors**:
  ```rust
  #[derive(Debug, Error)]
  pub enum LinkError {
      #[error("Discovery failed: {0}")]
      Discovery(#[from] DiscoveryError),
      #[error("Filter failed: {0}")]
      Filter(#[from] FilterError),
      #[error("Failed to determine home directory")]
      HomeDirectory,
  }
  ```
- **Graceful degradation**: Continue processing if individual symlink fails
- **Informative error messages**: Include file paths and system error details
- **Logging**: Use tracing for debugging:
  - `info!()` for successful symlink creation
  - `warn!()` for failed individual operations
  - `debug!()` for detection logic

### Observability

- **Tracing integration**:
  - Add spans for main operations: `info_span!("link_command")`
  - Log each symlink creation: `info!("Created symlink: {} -> {}", target, source)`
  - Log skipped topics: `debug!("Skipped {}: already linked", name)`
- **Error context**: Use thiserror to preserve error chains
- **Output diagnostics**: Terminal format provides user-visible feedback

### Code Reuse

- **Discovery**: Use `list::discovery::discover_topics()` - no duplication
- **Filtering**: Use `list::filter::apply_filters()` - no duplication
- **Types**: Reuse `list::types::TopicInfo` for topic representation
- **Output patterns**: Follow same structure as `list::format` module

## Parallelization Opportunities

Phases can be executed in the following groups:

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Foundation types and CLI - must complete first |
| Group B | Phase 2, Phase 3 | Detection and Creation are independent |
| Group C | Phase 4 | Orchestration depends on Group A & B |
| Group D | Phase 5, Phase 6 (partial) | Formatting and CLI wiring partially independent |

### Parallelization Diagram

```text
Timeline:
─────────────────────────────────────────────────────►

Phase 1: ████████ (Foundation)
              │
              ├──────────────┐
              │              │
Phase 2:      └──████████    │ (Detection - parallel with Phase 3)
                          │  │
Phase 3:                  └──████████ (Creation - parallel with Phase 2)
                                   │
Phase 4:                           └──████████ (Orchestration)
                                            │
                                            ├──────────┐
Phase 5:                                    └──████████│ (Formatting)
                                                    │  │
Phase 6:                                            └──████████ (E2E testing)
```

### Synchronization Points

1. **After Phase 1**: Types and CLI structure must be complete before detection/creation
2. **After Group B (Phase 2 & 3)**: Both detection and creation must complete before orchestration
3. **After Phase 4**: Orchestration must complete before formatting can be tested end-to-end
4. **Final**: All phases complete before merging to main

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| OpenCode directory doesn't exist on user's system | Low | Create parent directories automatically, document in error message |
| Symlink creation fails due to permissions | Medium | Graceful error handling, continue processing other topics, clear error messages |
| Existing symlink points to wrong location | Low | Document behavior: don't overwrite existing symlinks, user must manually fix |
| Large number of topics causes performance issues | Low | Initial implementation handles sequentially, optimize with rayon if needed |
| Path traversal security vulnerability | High | Strict path validation in detection phase, comprehensive security tests |
| Breaking changes to list command infrastructure | Medium | Pin to specific versions, add integration tests to catch breakage |

## Open Questions

All open questions have been resolved during review:

- [x] Should the command offer a `--force` flag to overwrite existing symlinks? → **Decision: Not for v1, document manual process**
- [x] Should there be a `--dry-run` flag to preview changes without creating symlinks? → **Decision: Defer to v2 if needed**
- [x] What should happen if source skill directory doesn't exist (no `skill/SKILL.md`)? → **Decision: Use `SkillAction::NoneSkillDirectoryInvalid`, display warning in output**
- [x] Should the command support unlinking (removing symlinks)? → **Decision: Not for v1, separate `unlink` command later if needed**
- [x] Should both CLI tools be linked by default, or add flags like `--claude-only`, `--opencode-only`? → **Decision: Link both by default, defer flags to v2**
- [x] How should broken symlinks be handled? → **Decision: Added `check_is_broken_symlink()`, report as `NoneAlreadyLinked` with note in output**
- [x] Should symlinks be relative or absolute? → **Decision: Absolute for robustness (moving .claude directory won't break links)**
- [x] What happens if existing symlink points to wrong topic? → **Decision: Treat as existing symlink, don't overwrite, user must manually fix**

## Implementation Readiness

This plan is ready for implementation with the following enhancements from review:

✅ **Enhanced error handling** - SkillAction includes error variants for rich reporting
✅ **Strengthened security** - Path validation, symlink following prevention, comprehensive security tests
✅ **Improved testability** - Property-based tests with proptest, comprehensive edge cases
✅ **Better API design** - Returns LinkResult for inspectability, asymmetric failure handling
✅ **Skill validation** - Verifies skill/SKILL.md exists before linking
✅ **Comprehensive test coverage** - 60+ tests planned across all phases
✅ **Clear documentation** - Explicit parameter naming, security guidance, color scheme specification

**Next Steps:**
1. Begin Phase 1: Define types and CLI integration
2. Run tests after each phase to verify blast radius
3. Use TDD approach: Write tests first for faster feedback
4. Consider parallel development: Phase 2 and Phase 3 can be developed simultaneously
5. Validate with manual testing after Phase 6 completion
