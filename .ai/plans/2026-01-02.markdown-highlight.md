# Markdown Highlight Feature (`==text==`)

**Created:** 2026-01-02
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2026-01-02

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**
1. **Phase 2 unclosed marker handling**: Added robust implementation to convert unclosed Start(Mark) back to literal `==` text
2. **Code block awareness**: Added `in_code` tracking to skip mark processing inside code blocks and inline code
3. **Escape sequence handling**: Clarified `\==` → `==` behavior (backslash removed, delimiters literal)
4. **Additional test scenarios**: Added 7 more test cases (total 22) including light/dark mode, code blocks, Unicode
5. **Performance benchmark**: Added acceptance criterion for <5% overhead verification
6. **Mark scope for ScopeCache**: Added explicit technical details for `scope_for_inline_tag()` method
7. **CSS dark mode**: Added CSS variable support for theme-aware highlight colors

## Executive Summary

Add support for the popular `==highlighted text==` Markdown extension to the `Markdown` struct's rendering engine. Since pulldown-cmark does not provide native support for this syntax, we will implement a custom text post-processor that intercepts `Event::Text` events and splits them into highlight spans, emitting synthetic `Start/End(Mark)` events that the HTML and terminal renderers consume.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Parse `==text==` inline syntax and emit Mark events | High | Rust Developer |
| FR-2 | Render `<mark>text</mark>` for HTML output | High | Rust Developer |
| FR-3 | Render highlighted text with yellow/contrasting background for terminal output | High | Rust Developer |
| FR-4 | Support nesting with other inline formatting (bold, italic, code) | Medium | Rust Developer |
| FR-5 | Handle escaped delimiters (`\==`) as literal text | Medium | Rust Developer |
| FR-6 | Add CSS styles for `<mark>` element in HTML output | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Zero allocation for text without `==` markers | O(1) extra allocs | Rust Developer |
| NFR-2 | Maintain existing test coverage | 100% pass rate | Feature Tester |
| NFR-3 | Document public API additions | rustdoc coverage | Rust Developer |
| NFR-4 | Theme-aware highlight colors | Light/dark support | Rust Developer |

## Architecture Overview

### Current State

The `Markdown` struct uses pulldown-cmark for parsing, which emits events like:
- `Event::Start(Tag::Strong)` / `Event::End(TagEnd::Strong)` for `**bold**`
- `Event::Start(Tag::Strikethrough)` / `Event::End(TagEnd::Strikethrough)` for `~~strikethrough~~`
- `Event::Text(CowStr)` for plain text content

pulldown-cmark 0.12 does **NOT** have a built-in `ENABLE_MARK` or `ENABLE_HIGHLIGHT` option.

### Proposed Solution

Create a **text post-processor iterator adapter** that wraps the pulldown-cmark parser and:

1. Passes through all non-Text events unchanged
2. For Text events, scans for `==` delimiters
3. Splits text into segments, emitting synthetic highlight events

```
Input Text:  "This is ==highlighted== and normal text"

Output Events:
  Event::Text("This is ")
  Event::Start(Tag::Mark)       // Synthetic custom tag
  Event::Text("highlighted")
  Event::End(TagEnd::Mark)
  Event::Text(" and normal text")
```

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         shared/src/markdown/                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────┐     ┌─────────────────────────────┐               │
│  │   Markdown      │     │  output/mod.rs              │               │
│  │   (mod.rs)      │────▶│  ├── as_html()              │               │
│  │                 │     │  └── for_terminal()         │               │
│  └─────────────────┘     └─────────────────────────────┘               │
│           │                          │                                  │
│           ▼                          ▼                                  │
│  ┌─────────────────┐     ┌─────────────────────────────┐               │
│  │ inline/mod.rs   │     │  output/html.rs             │               │
│  │ (NEW)           │     │  - Handle Mark tag          │               │
│  │                 │     │  - Add <mark> CSS           │               │
│  │ MarkProcessor   │     └─────────────────────────────┘               │
│  │ (iterator       │                                                    │
│  │  adapter)       │     ┌─────────────────────────────┐               │
│  │                 │     │  output/terminal.rs         │               │
│  │ - Wraps Parser  │     │  - Handle Mark tag          │               │
│  │ - Emits Mark    │     │  - ANSI background styling  │               │
│  │   events        │     └─────────────────────────────┘               │
│  └─────────────────┘                                                    │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  highlighting/scope_cache.rs                                     │   │
│  │  - Add scope_for_inline_tag(InlineTag::Mark) mapping             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Data Flow

1. **Input**: Markdown content string with `==highlighted==` text
2. **Parser**: pulldown-cmark parses and emits `Event::Text("This is ==highlighted== text")`
3. **Processor**: `MarkProcessor` adapter splits into multiple events including synthetic `Mark` tags
4. **Renderer (HTML)**: Converts `Mark` tags to `<mark>...</mark>` elements
5. **Renderer (Terminal)**: Applies ANSI background color codes for highlight effect

## Phases

### Phase 1: Define Mark Event Types

**Principal Owner:** Rust Developer

**Goal:** Create the type definitions for the synthetic Mark tag events

**Dependencies:** None

**Blast Radius:** `cargo test -p shared --lib inline`

**Files to create:**
- `shared/src/markdown/inline/mod.rs` - Module entry with MarkProcessor
- `shared/src/markdown/inline/types.rs` - InlineTag enum for Mark

**Files to modify:**
- `shared/src/markdown/mod.rs` - Add `pub mod inline;`

**Deliverables:**
- `InlineTag` enum with `Mark` variant
- `InlineEvent` enum wrapping pulldown-cmark events + custom events
- Type definitions exported from module

**Technical Details:**

```rust
// shared/src/markdown/inline/types.rs
use pulldown_cmark::Event;

/// Custom inline tags not natively supported by pulldown-cmark.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InlineTag {
    /// Highlighted text (`==text==`) - renders as `<mark>` in HTML
    Mark,
    // Future: Underline, Subscript, Superscript
}

/// Wrapper for pulldown-cmark events with custom inline extensions.
#[derive(Debug, Clone)]
pub enum InlineEvent<'a> {
    /// Standard pulldown-cmark event (passed through unchanged)
    Standard(Event<'a>),
    /// Start of custom inline tag
    Start(InlineTag),
    /// End of custom inline tag
    End(InlineTag),
}

impl<'a> From<Event<'a>> for InlineEvent<'a> {
    fn from(event: Event<'a>) -> Self {
        InlineEvent::Standard(event)
    }
}
```

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/inline/mod.rs` exists with >50 lines
- [ ] File `shared/src/markdown/inline/types.rs` exists with >30 lines
- [ ] `grep "pub enum InlineTag" shared/src/markdown/inline/types.rs` succeeds
- [ ] `grep "pub enum InlineEvent" shared/src/markdown/inline/types.rs` succeeds
- [ ] `grep "pub mod inline" shared/src/markdown/mod.rs` succeeds
- [ ] `cargo test -p shared --lib inline` runs 3+ tests
- [ ] All new tests pass

---

### Phase 2: Implement MarkProcessor Iterator

**Principal Owner:** Rust Developer

**Goal:** Create the iterator adapter that processes text events for `==` markers

**Dependencies:** Phase 1

**Blast Radius:** `cargo test -p shared --lib inline`

**Files to modify:**
- `shared/src/markdown/inline/mod.rs` - Add MarkProcessor struct and Iterator impl

**Deliverables:**
- `MarkProcessor<I>` struct that wraps `I: Iterator<Item=Event<'a>>`
- Implements `Iterator<Item=InlineEvent<'a>>`
- Correctly handles:
  - Text without markers (pass-through)
  - Text with single `==pair==`
  - Text with multiple `==one== and ==two==` pairs
  - Unclosed `==` markers (literal rendering)
  - Escaped `\==` sequences

**Technical Details:**

```rust
// shared/src/markdown/inline/mod.rs
use pulldown_cmark::{Event, CowStr};
use std::collections::VecDeque;

pub struct MarkProcessor<'a, I>
where
    I: Iterator<Item = Event<'a>>,
{
    inner: I,
    pending: VecDeque<InlineEvent<'a>>,
    /// Track if we're inside a code block (fenced or indented)
    in_code_block: bool,
    /// Track if we're inside inline code
    in_inline_code: bool,
}

impl<'a, I> MarkProcessor<'a, I>
where
    I: Iterator<Item = Event<'a>>,
{
    pub fn new(inner: I) -> Self {
        Self {
            inner,
            pending: VecDeque::new(),
            in_code_block: false,
            in_inline_code: false,
        }
    }

    /// Process a text event, splitting on `==` markers.
    /// Returns true if the text was processed (contained markers).
    fn process_text(&mut self, text: CowStr<'a>) -> bool {
        let s = text.as_ref();

        // Fast path: no markers
        if !s.contains("==") {
            return false;
        }

        // Parse for ==markers==
        let mut segments: VecDeque<InlineEvent<'a>> = VecDeque::new();
        let mut current_pos = 0;
        let mut in_mark = false;
        let mut last_start_idx: Option<usize> = None;  // Track position of last Start(Mark)

        while let Some(marker_pos) = s[current_pos..].find("==") {
            let abs_pos = current_pos + marker_pos;

            // Check for escape sequence (handle multi-byte chars safely)
            let is_escaped = abs_pos > 0 && {
                // Use char_indices to safely check the preceding character
                s[..abs_pos].chars().last() == Some('\\')
            };

            if is_escaped {
                // Escaped: emit text before backslash, then "==" literally
                let before_backslash = abs_pos - 1; // Safe because we checked abs_pos > 0
                if before_backslash > current_pos {
                    let before = &s[current_pos..before_backslash];
                    segments.push_back(InlineEvent::Standard(
                        Event::Text(CowStr::from(before.to_string()))
                    ));
                }
                segments.push_back(InlineEvent::Standard(
                    Event::Text(CowStr::from("==".to_string()))
                ));
                current_pos = abs_pos + 2;
                continue;
            }

            // Emit text before marker
            if abs_pos > current_pos {
                let before = &s[current_pos..abs_pos];
                segments.push_back(InlineEvent::Standard(
                    Event::Text(CowStr::from(before.to_string()))
                ));
            }

            // Toggle mark state
            if in_mark {
                segments.push_back(InlineEvent::End(InlineTag::Mark));
                last_start_idx = None;  // Paired, clear tracking
            } else {
                last_start_idx = Some(segments.len());  // Track this Start position
                segments.push_back(InlineEvent::Start(InlineTag::Mark));
            }
            in_mark = !in_mark;
            current_pos = abs_pos + 2;
        }

        // Handle remaining text
        if current_pos < s.len() {
            let remaining = &s[current_pos..];
            segments.push_back(InlineEvent::Standard(
                Event::Text(CowStr::from(remaining.to_string()))
            ));
        }

        // If we ended with an unclosed mark, convert Start(Mark) back to literal "=="
        if in_mark {
            if let Some(start_idx) = last_start_idx {
                // Replace the Start(Mark) at start_idx with literal text
                segments[start_idx] = InlineEvent::Standard(
                    Event::Text(CowStr::from("==".to_string()))
                );
            }
        }

        self.pending = segments;
        true
    }
}

impl<'a, I> Iterator for MarkProcessor<'a, I>
where
    I: Iterator<Item = Event<'a>>,
{
    type Item = InlineEvent<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        // Return pending events first
        if let Some(event) = self.pending.pop_front() {
            return Some(event);
        }

        // Get next event from inner iterator
        match self.inner.next()? {
            // Track code block state
            Event::Start(Tag::CodeBlock(_)) => {
                self.in_code_block = true;
                Some(InlineEvent::Standard(Event::Start(Tag::CodeBlock(
                    pulldown_cmark::CodeBlockKind::Fenced("".into())
                ))))
            }
            Event::End(TagEnd::CodeBlock) => {
                self.in_code_block = false;
                Some(InlineEvent::Standard(Event::End(TagEnd::CodeBlock)))
            }
            // Track inline code state
            Event::Code(text) => {
                // Inline code is literal - don't process markers
                Some(InlineEvent::Standard(Event::Code(text)))
            }
            // Process text only if not in code
            Event::Text(text) => {
                if self.in_code_block || self.in_inline_code {
                    // Pass through unchanged in code contexts
                    Some(InlineEvent::Standard(Event::Text(text)))
                } else if self.process_text(text.clone()) {
                    self.pending.pop_front()
                } else {
                    Some(InlineEvent::Standard(Event::Text(text)))
                }
            }
            other => Some(InlineEvent::Standard(other)),
        }
    }
}
```

**Acceptance Criteria:**
- [ ] `grep "pub struct MarkProcessor" shared/src/markdown/inline/mod.rs` succeeds
- [ ] `grep "impl.*Iterator.*for MarkProcessor" shared/src/markdown/inline/mod.rs` succeeds
- [ ] `cargo test -p shared --lib inline` runs 10+ tests
- [ ] Test: Text without markers passes through unchanged
- [ ] Test: `==highlighted==` emits Start(Mark), Text, End(Mark)
- [ ] Test: `==one== and ==two==` emits correct sequence
- [ ] Test: Unclosed `==text` renders literally
- [ ] Test: Escaped `\==` renders as `==`
- [ ] All tests pass

---

### Phase 3: Integrate with HTML Renderer

**Principal Owner:** Rust Developer

**Goal:** Update HTML output to handle Mark events and render `<mark>` elements

**Dependencies:** Phase 2

**Blast Radius:** `cargo test -p shared --lib output::html`

**Files to modify:**
- `shared/src/markdown/output/html.rs` - Use MarkProcessor, handle InlineEvent

**Deliverables:**
- HTML renderer uses `MarkProcessor::new(parser)` instead of raw parser
- Handles `InlineEvent::Start(InlineTag::Mark)` → `<mark>`
- Handles `InlineEvent::End(InlineTag::Mark)` → `</mark>`
- CSS styles for `<mark>` element added to `generate_styles()`

**Technical Details:**

Update parser creation in `as_html()`:
```rust
// Before
let parser = Parser::new_ext(md.content(), Options::ENABLE_STRIKETHROUGH);
for event in parser {
    match event { ... }
}

// After
use crate::markdown::inline::{MarkProcessor, InlineEvent, InlineTag};
let parser = Parser::new_ext(md.content(), Options::ENABLE_STRIKETHROUGH);
let events = MarkProcessor::new(parser);

for event in events {
    match event {
        InlineEvent::Standard(e) => match e {
            // existing event handling unchanged
            Event::Start(Tag::Heading { level, .. }) => { ... }
            ...
        },
        InlineEvent::Start(InlineTag::Mark) => {
            output.push_str("<mark>");
        }
        InlineEvent::End(InlineTag::Mark) => {
            output.push_str("</mark>");
        }
    }
}
```

Add CSS to `generate_styles()`:
```rust
// In generate_styles() function, add mark styles with CSS variable support:
r#"
mark {
    background-color: var(--highlight-bg, #fff3b8);
    color: var(--highlight-fg, inherit);
    padding: 0.1em 0.2em;
    border-radius: 2px;
}

/* Dark mode adjusts automatically if parent sets --highlight-bg */
"#
```

**Acceptance Criteria:**
- [ ] `grep "MarkProcessor::new" shared/src/markdown/output/html.rs` succeeds
- [ ] `grep "InlineTag::Mark" shared/src/markdown/output/html.rs` succeeds
- [ ] `grep "<mark>" shared/src/markdown/output/html.rs` succeeds
- [ ] `grep -A2 "mark {" shared/src/markdown/output/html.rs` shows CSS styles
- [ ] `cargo test -p shared --lib output::html` runs 25+ tests
- [ ] Test: `==highlighted==` renders as `<mark>highlighted</mark>`
- [ ] Test: Nested `**==bold highlight==**` renders correctly
- [ ] Test: CSS includes `mark` selector
- [ ] All tests pass

---

### Phase 4: Integrate with Terminal Renderer

**Principal Owner:** Rust Developer

**Goal:** Update terminal output to handle Mark events with ANSI background colors

**Dependencies:** Phase 2

**Blast Radius:** `cargo test -p shared --lib output::terminal`

**Files to modify:**
- `shared/src/markdown/output/terminal.rs` - Use MarkProcessor, handle InlineEvent
- `shared/src/markdown/highlighting/scope_cache.rs` - Add Mark scope mapping method

**Deliverables:**
- Terminal renderer uses `MarkProcessor::new(parser)`
- Handles Mark events with ANSI background color escape codes
- Theme-aware highlight colors (different for light/dark modes)
- Add `in_mark` boolean tracking similar to `in_emphasis`
- Add `scope_for_inline_tag()` method to `ScopeCache`

**Technical Details:**

Add Mark scope to ScopeCache:
```rust
// In shared/src/markdown/highlighting/scope_cache.rs

// Add field to ScopeCache struct:
pub mark: Scope,

// In ScopeCache::new():
mark: Scope::new("markup.mark.markdown")
    .expect("Invalid hardcoded scope: markup.mark.markdown"),

// Add new method for InlineTag mapping:
pub fn scope_for_inline_tag(&self, tag: &InlineTag) -> Option<Scope> {
    match tag {
        InlineTag::Mark => Some(self.mark),
    }
}
```

Add tracking flag and event handling:
```rust
let mut in_mark = false;

// In event match, add handling for mark events:
InlineEvent::Start(InlineTag::Mark) => {
    in_mark = true;
}
InlineEvent::End(InlineTag::Mark) => {
    in_mark = false;
}
```

Add ANSI background in text rendering (in the text emission logic):
```rust
// When emitting styled text, if in_mark is true, apply background:
fn emit_mark_styled(text: &str, color_depth: ColorDepth, color_mode: ColorMode) -> String {
    let (bg_start, bg_end) = match color_depth {
        ColorDepth::TrueColor => {
            // Light yellow for dark mode, darker yellow for light mode
            match color_mode {
                ColorMode::Dark => ("\x1b[48;2;255;243;184m", "\x1b[49m"),  // #fff3b8
                ColorMode::Light => ("\x1b[48;2;255;230;130m", "\x1b[49m"), // darker yellow
            }
        }
        ColorDepth::Colors256 => ("\x1b[48;5;229m", "\x1b[49m"),  // Yellow palette
        ColorDepth::Colors16 => ("\x1b[43m", "\x1b[49m"),          // Basic yellow BG
        ColorDepth::None => ("", ""),
    };
    format!("{}{}{}", bg_start, text, bg_end)
}
```

**Acceptance Criteria:**
- [ ] `grep "MarkProcessor::new" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `grep "in_mark" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `grep "InlineTag::Mark" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `grep "48;2;255;243;184" shared/src/markdown/output/terminal.rs` succeeds (TrueColor bg)
- [ ] `grep "scope_for_inline_tag" shared/src/markdown/highlighting/scope_cache.rs` succeeds
- [ ] `grep "markup.mark.markdown" shared/src/markdown/highlighting/scope_cache.rs` succeeds
- [ ] `cargo test -p shared --lib output::terminal` runs 20+ tests
- [ ] Test: `==highlighted==` renders with ANSI background codes
- [ ] Test: TrueColor mode uses RGB background
- [ ] Test: 256-color mode uses color index
- [ ] Test: 16-color mode uses basic yellow
- [ ] Test: Light mode uses darker yellow (#ffe682)
- [ ] Test: Dark mode uses lighter yellow (#fff3b8)
- [ ] All tests pass

---

### Phase 5: Integration Testing and Documentation

**Principal Owner:** Feature Tester (Rust)

**Goal:** Add comprehensive integration tests and update documentation

**Dependencies:** Phases 3, 4

**Blast Radius:** `cargo test -p shared`

**Files to create:**
- `shared/tests/highlight_integration.rs` - Integration tests for highlight feature

**Files to modify:**
- `shared/src/markdown/mod.rs` - Update module docs with highlight examples
- `shared/src/markdown/inline/mod.rs` - Ensure comprehensive rustdocs

**Deliverables:**
- Integration tests covering all scenarios below
- Documentation updated with examples

**Test Scenarios:**

| # | Test Case | Input | Expected |
|---|-----------|-------|----------|
| 1 | Simple highlight | `==text==` | HTML: `<mark>text</mark>`, Terminal: yellow bg |
| 2 | Multiple highlights | `==one== and ==two==` | Two separate mark spans |
| 3 | Nested with bold | `**==text==**` | Bold mark inside strong |
| 4 | Nested with italic | `*==text==*` | Mark inside emphasis |
| 5 | Nested with strikethrough | `~~==text==~~` | Mark inside del |
| 6 | In list item | `- ==item==` | Mark inside li |
| 7 | In blockquote | `> ==quote==` | Mark inside blockquote |
| 8 | In heading | `## ==Title==` | Mark inside h2 |
| 9 | Unclosed marker | `==unclosed text` | Literal `==unclosed text` |
| 10 | Empty markers | `====` | Empty `<mark></mark>` |
| 11 | Escaped marker | `\==not highlighted==` | `==not highlighted==` |
| 12 | Consecutive markers | `======` | Empty mark + `==` literal |
| 13 | Mark in inline code | `` `==code==` `` | Literal (no mark in code) |
| 14 | No markers | `plain text` | No mark tags |
| 15 | Preserve other styles | `**bold** ==mark==` | Both render correctly |
| 16 | Fenced code block | ` ```\n==code==\n``` ` | Literal (no mark in code) |
| 17 | Light mode terminal | `==text==` (ColorMode::Light) | Darker yellow bg (#ffe682) |
| 18 | Dark mode terminal | `==text==` (ColorMode::Dark) | Light yellow bg (#fff3b8) |
| 19 | Unicode inside mark | `==你好世界==` | Mark with UTF-8 content |
| 20 | Mark at start | `==start== middle end` | Only "start" marked |
| 21 | Mark at end | `start middle ==end==` | Only "end" marked |
| 22 | Entire paragraph marked | `==entire paragraph==` | Whole text marked |

**Acceptance Criteria:**
- [ ] File `shared/tests/highlight_integration.rs` exists with >200 lines
- [ ] `cargo test -p shared --test highlight_integration` runs 22+ tests
- [ ] All tests pass
- [ ] `cargo doc -p shared --no-deps` succeeds without warnings
- [ ] Module docs include highlight usage examples
- [ ] `cargo test -p shared` (full suite) passes
- [ ] Performance test confirms <5% overhead for documents without markers

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests**: In `#[cfg(test)] mod tests` blocks within each module
- **Integration tests**: `shared/tests/highlight_integration.rs`
- **Property-based tests**: Consider proptest for delimiter parsing edge cases
- **Snapshot tests**: Consider insta for HTML output verification

### Security Considerations

- No remote content involved
- No file I/O
- Pure text parsing - minimal attack surface
- HTML output uses existing `html_escape` for XSS prevention
- Mark content is escaped same as regular text

### Performance Considerations

- **Zero-allocation fast path**: When text contains no `==` markers, pass through unchanged
- **Avoid regex**: Use simple char-by-char or `find()` scanning
- **Reuse buffers**: Use `VecDeque<InlineEvent>` for pending events
- **Benchmark target**: Parse 1000 documents with/without highlights, ensure <5% overhead

### Error Handling

- Invalid/unclosed markers render literally (no errors returned)
- Escaped sequences handled gracefully
- No panics in parser adapter
- Robust to malformed input

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Foundation types - no dependencies |
| Group B | Phase 2 | Depends on Phase 1 types |
| Group C | Phase 3, Phase 4 | Both depend on Phase 2, independent of each other |
| Group D | Phase 5 | Depends on Phases 3 and 4 |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────►

Phase 1: ████████ (Type definitions)
                │
Phase 2:        └──████████████ (MarkProcessor)
                              │
                              ├──Phase 3: ████████ (HTML)
                              │
                              └──Phase 4: ████████ (Terminal)
                                               │
Phase 5:                                       └──████████ (Integration)
```

### Synchronization Points

1. **After Phase 1:** Types must be finalized and exported
2. **After Phase 2:** Iterator adapter must be complete and tested
3. **After Phases 3+4:** Both renderers updated before integration testing

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| pulldown-cmark event ordering assumptions break | High | Thorough testing with edge cases, especially nested styles |
| Performance regression from iterator adapter | Medium | Benchmark before/after, optimize hot path with contains() check |
| Scope cache changes break prose highlighting | Medium | Add regression tests for existing styles |
| Terminal color rendering varies by terminal | Low | Document tested terminals, use established ANSI codes |
| Unclosed marker edge cases cause unexpected output | Medium | Comprehensive testing, conservative fallback to literal |

## Open Questions

- [x] Should we support configurable highlight colors via `HtmlOptions`/`TerminalOptions`?
  - **Decision:** Not in this phase. CSS variables (`--highlight-bg`) provide configurability for HTML. Terminal uses theme-aware defaults.
- [x] Should escaped `\==` produce a single `=` or literal `==`?
  - **Decision:** `\==` → `==` (backslash removed, delimiters rendered literally)
- [ ] Should we add a feature flag to disable highlight processing for performance?
  - **Deferred:** If benchmarks show >5% overhead, add `MarkdownOptions::enable_highlighting: bool`
- [x] Handle `==` inside inline code blocks?
  - **Decision:** No processing in code - `MarkProcessor` skips text events inside code blocks and inline code

## Estimated Implementation Size

| Phase | Lines of Code | Files Created | Files Modified |
|-------|--------------|---------------|----------------|
| Phase 1 | ~80 | 2 | 1 |
| Phase 2 | ~150 | 0 | 1 |
| Phase 3 | ~50 | 0 | 1 |
| Phase 4 | ~80 | 0 | 2 |
| Phase 5 | ~200 | 1 | 2 |
| **Total** | **~560** | **3** | **7** |
