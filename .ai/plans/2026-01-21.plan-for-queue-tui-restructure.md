---
status: "executing: phase 7b"
started_at: 00:12:39
finished_at:
duration:
tts_gender: male
requirements: |
  ## Phase 0: Restructure (Sequential - Must complete before TUI work)
  Split queue package into two submodules:
  1. Library Module (./queue/lib) - core scheduling logic, data types, persistence
  2. CLI Module (./queue/cli) - clap parsing, TUI, terminal integration
  Move current implementation to CLI module first, then extract library.

  ## Phase 1+: TUI Implementation
  - Add TUI module based on ratatui + crossterm
  - EVERY queue command opens the TUI (no silent mode)
  - Terminal detection:
    - Wezterm: create pane below current window via wezterm CLI
    - Non-Wezterm: use native terminal app (open -a Terminal on macOS)
  - Main window shows task list with ID, WHEN, Command, Where columns
  - Hotkeys: Q/CTRL+C (quit), N (new), E# (edit), R# (remove), H (history)
  - Where parameter defaults: new pane (Wezterm), new window (others), background option
  - Input Modal for new/edit tasks
  - History Modal with filtering, stored in ~/.queue-history.jsonl
  - Tasks show status: italicized/dimmed when completed
  - File locking for concurrent history file access
required_skills:
  - rust
  - ratatui
  - crossterm
  - clap
  - thiserror
important_skills:
  tokio: "async runtime for TUI event loop or background task execution"
  serde: "serializing/deserializing task data and history to JSONL format"
  chrono: "parsing and formatting WHEN field timestamps"
  just: "creating justfile recipes for build/test/install operations"
  color-eyre: "rich error reporting in the CLI"
subagents:
  Plan: "Create phased implementation plan"
  Explore: "Module assessment for monorepo impact"
  general-purpose: "Reviews (completeness, concurrency, correctness) and finalization"
  feature-tester-rust: "Test implementation phases"
monorepo_modules_impacted:
  - root_workspace: "Update members list: queue -> queue/cli, queue/lib"
  - queue_cli: "New package with ratatui, crossterm, serde_json"
  - queue_lib: "New package - extract scheduler + history logic"
  - queue_justfile: "Coordinate both cli and lib builds"
completeness_changes: []
concurrency_changes: []
detail_changes: []
lessons_learned_count: 0
---
# Planning Process

- [x] Prep Started [00:12:39]
    - [x] Identified Skills [00:13:05]
    - [x] Identified Subagents [00:13:05]
- [x] Prep complete [00:13:05]
- [x] Clarify (orchestrator direct) [00:13:45]
    - [x] User asked clarifying questions (human in the loop)
    - [x] Requirements have been updated based on user responses:
        - Sequential phases (restructure before TUI)
        - Native terminal app for non-Wezterm new windows
        - Always TUI mode (no silent flag)
        - File locking for history concurrency
- [x] Planning Subagent [agent: Plan] started [00:13:50]
    - [x] subagent skills used: rust, ratatui, crossterm, clap, thiserror
    - [x] Planning completed [00:14:45]
- [x] Module Assessment Subagent [agent: Explore] started [00:13:50]
    - [x] subagent skills used: rust, just
    - [x] Module Assessment completed [00:14:45]
- [x] All Pre-review Steps are complete [00:14:45]
- [x] Review Started [00:15:30]
   - [x] Completeness Review [agent: general-purpose]
       - [x] subagent skills used: rust, ratatui, crossterm, clap, thiserror
   - [x] Concurrency Review [agent: general-purpose]
       - [x] subagent skills used: rust, ratatui, crossterm
   - [x] Correctness Review [agent: general-purpose]
        - [x] subagent skills used: rust, ratatui, crossterm, clap, thiserror
- [x] Reviews Completed [00:16:30]
- [x] Plan Finalization [agent: general-purpose] started [00:16:35]
    - [x] subagent skills used: rust, ratatui, crossterm, clap, thiserror
- [x] Plan finalized [00:17:45]
- Final Steps
    - [x] Lessons learned collected from all subagents
    - [x] Researching 2 packages (fs2, ratatui - already have local skill)
- [x] Summarized plan to user via STDOUT
    - Project File: .ai/plans/2026-01-21.plan-for-queue-tui-restructure.md
    - Started: 00:12:39
    - Completed: 00:18:00
    - Duration: ~5 minutes



## Plan

> **Note:** This plan incorporates feedback from completeness, concurrency, and correctness reviews. Key changes:
> - Phase 5 split into 5a (Modal Infrastructure) and 5b (Input Widgets) for parallelization
> - Phase 7 split into 7a (Execution Core) and 7b (TUI Integration) for parallelization
> - Phase 9 split into 9a/9b/9c for earlier test development
> - Fixed ratatui lifecycle pattern (use `init()`/`restore()`, not fictional `run()`)
> - Added Q key confirmation dialog to Phase 5a
> - Added Linux terminal support to Phase 2
> - Reassigned Phase 7 from feature-tester-rust to general-purpose

### Phase 0: Project Restructuring

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, clap, thiserror |
| **Suggested Skills** | just (justfile setup) |
| **Complexity** | Medium |
| **Dependencies** | None |
| **Parallelizable** | No (blocking - changes project structure) |

**Objective:** Split the monolithic `queue` package into `queue-lib` (library) and `queue-cli` (binary) following the tree-hugger/sniff patterns.

**Deliverables:**
- New workspace structure: `queue/lib/` and `queue/cli/`
- `queue-lib` crate with hyphenated package name
- `queue-cli` crate depending on `queue-lib = { path = "../lib" }`
- Update root `Cargo.toml` workspace members
- Create `queue/justfile` with build/test/lint/install recipes

**Acceptance Criteria:**
- [ ] `cargo build -p queue-lib` succeeds
- [ ] `cargo build -p queue-cli` succeeds
- [ ] `cargo test -p queue-lib` passes all existing time parsing tests
- [ ] `cargo check --workspace` succeeds
- [ ] Existing CLI functionality unchanged

---

### Phase 1: Library Core Data Types

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, thiserror |
| **Suggested Skills** | serde (JSONL persistence), chrono (time handling) |
| **Complexity** | Medium |
| **Dependencies** | Phase 0 |
| **Parallelizable** | Yes (with Phase 2) |

**Objective:** Define core data types and persistence layer in `queue-lib`.

**Deliverables:**
- `ExecutionTarget` enum: `NewPane`, `NewWindow`, `Background`
- `TaskStatus` enum: `Pending`, `Running`, `Completed`, `Failed { error: String }`
- `ScheduledTask` struct with id, command, scheduled_at, target, status, created_at
- `HistoryStore` trait for persistence abstraction
- `JsonFileStore` implementation with `fs2` file locking
- Serde derive implementations for all types

**Acceptance Criteria:**
- [ ] All types derive Debug, Clone, Serialize, Deserialize
- [ ] `JsonFileStore` uses `fs2::FileExt::lock_exclusive()` for writes
- [ ] `JsonFileStore` uses `fs2::FileExt::lock_shared()` for reads
- [ ] Unit tests for JSONL serialization round-trip
- [ ] Unit tests for file locking behavior

---

### Phase 2: Terminal Detection

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 0 |
| **Parallelizable** | Yes (with Phase 1) |

**Objective:** Implement cross-platform terminal detection for Wezterm and native terminal fallback.

**Deliverables:**
- `TerminalDetector` for identifying current terminal via env vars
- Wezterm detection via `WEZTERM_PANE` environment variable
- Native terminal detection:
  - macOS: Terminal.app, iTerm2
  - Linux: gnome-terminal, konsole, xfce4-terminal, xterm
- `TerminalCapabilities` struct indicating supported features

**Acceptance Criteria:**
- [ ] Correctly detects Wezterm when `WEZTERM_PANE` is set
- [ ] Falls back to native terminal detection when not in Wezterm
- [ ] Linux terminal detection covers gnome-terminal, konsole
- [ ] macOS detection covers Terminal.app
- [ ] Unit tests with mocked environment variables

---

### Phase 3: TUI Application Shell

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui, crossterm |
| **Suggested Skills** | tokio (channel setup) |
| **Complexity** | High |
| **Dependencies** | Phase 1 |
| **Parallelizable** | No |

**Objective:** Create the foundational TUI application structure with proper terminal lifecycle management.

**Deliverables:**
- `App` struct containing application state (tasks, selection, mode)
- `AppMode` enum: Normal, EditMode, RemoveMode, InputModal, HistoryModal, ConfirmQuit
- Terminal initialization using `ratatui::init()` / `ratatui::restore()` pattern
- Panic hook using `std::panic::set_hook()` for terminal cleanup
- Event loop with `crossterm::event::poll()` timeout pattern
- `tokio::sync::mpsc` channel setup for async-to-TUI communication
- Filter on `KeyEventKind::Press` only (Windows compatibility)

**Implementation Pattern:**
```rust
fn main() -> std::io::Result<()> {
    let original_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |info| {
        let _ = ratatui::restore();
        original_hook(info);
    }));

    let mut terminal = ratatui::init();
    let result = run_app(&mut terminal);
    ratatui::restore()?;
    result
}
```

**Acceptance Criteria:**
- [ ] Terminal properly initialized and restored on exit
- [ ] Terminal restored on panic (panic hook works)
- [ ] Only handles `KeyEventKind::Press` events
- [ ] `Ctrl+C` triggers graceful shutdown
- [ ] Channel established for async task updates

---

### Phase 4: Main Window Layout

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 3 |
| **Parallelizable** | No |

**Objective:** Implement the main window UI with task table and status footer.

**Deliverables:**
- Layout using `Layout::vertical()` with `Constraint::Min` and `Constraint::Length`
- Task table using `Table` widget with `Row` and `Cell` construction
- Columns: ID, WHEN, Command, Where
- `TableState` for row selection with highlight
- Completed tasks with dimmed/italic styling
- Footer with keyboard shortcuts, dynamic coloring for edit/remove modes

**Implementation Pattern:**
```rust
let rows = tasks.iter().map(|task| {
    Row::new([
        Cell::from(task.id.to_string()),
        Cell::from(format_schedule(&task.scheduled_at)),
        Cell::from(task.command.as_str()),
        Cell::from(format_target(&task.target)),
    ])
});
let table = Table::new(rows, widths)
    .highlight_style(Style::default().add_modifier(Modifier::REVERSED));
frame.render_stateful_widget(table, area, &mut app.table_state);
```

**Acceptance Criteria:**
- [ ] Table displays all scheduled tasks
- [ ] Arrow keys navigate table rows
- [ ] Footer shows correct hotkey labels
- [ ] Footer background changes to yellow on E key press
- [ ] Footer background changes to red on R key press
- [ ] Completed tasks visually distinguished (dimmed + italic)

---

### Phase 5a: Modal Infrastructure

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 4 |
| **Parallelizable** | Yes (Phase 6 can start after 5a) |

**Objective:** Create reusable modal overlay infrastructure for dialogs.

**Deliverables:**
- `Modal` trait defining render and input handling interface
- `ModalOverlay` component for centered modal rendering
- Three-step modal render pattern (main content, Clear, modal content)
- Focus management (modal captures all input when active)
- `ConfirmDialog` modal for quit confirmation (Q key requirement)

**Implementation Pattern:**
```rust
fn render_modal(frame: &mut Frame, modal: &impl Modal, main_area: Rect) {
    let modal_area = centered_rect(60, 40, main_area);
    frame.render_widget(Clear, modal_area);
    modal.render(frame, modal_area);
}
```

**Acceptance Criteria:**
- [ ] Modal renders centered over main content
- [ ] Modal area properly cleared before rendering
- [ ] Q key shows confirm quit dialog
- [ ] Confirm dialog has Yes/No options
- [ ] ESC closes modal without action

---

### Phase 5b: Input Widgets

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui |
| **Suggested Skills** | None |
| **Complexity** | High |
| **Dependencies** | Phase 5a |
| **Parallelizable** | Yes (with Phase 6, after 5a) |

**Objective:** Implement the task input modal for creating and editing scheduled tasks.

**Deliverables:**
- `InputModal` implementing `Modal` trait
- Text input field for command entry with cursor
- Schedule type selector (At time / After delay)
- Time/delay input with validation using existing parsers
- Execution target selector (new pane, new window, background)
- Form validation with error display

**Acceptance Criteria:**
- [ ] N key opens input modal from main window
- [ ] E key opens input modal pre-filled for editing selected task
- [ ] Tab navigates between form fields
- [ ] Invalid input shows inline error message
- [ ] ENTER submits valid form and creates/updates task
- [ ] ESC cancels without changes

---

### Phase 6: History Modal

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui |
| **Suggested Skills** | serde (JSONL reading) |
| **Complexity** | Medium |
| **Dependencies** | Phase 5a |
| **Parallelizable** | Yes (with Phase 5b, after 5a) |

**Objective:** Implement the history modal showing previously queued commands.

**Deliverables:**
- `HistoryModal` implementing `Modal` trait
- Scrollable list of historical commands
- Up/down arrow navigation with highlight
- ENTER to copy selected command to input modal
- N to create new task with selected history as template
- F to open filter sub-modal (text search)

**Acceptance Criteria:**
- [ ] H key opens history modal
- [ ] History loads from ~/.queue-history.jsonl
- [ ] Arrow keys navigate list with visual highlight
- [ ] ENTER transitions to input modal with command pre-filled
- [ ] ESC returns to main window

---

### Phase 7a: Execution Core

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, tokio |
| **Suggested Skills** | None |
| **Complexity** | High |
| **Dependencies** | Phase 1, Phase 2 |
| **Parallelizable** | Yes (with Phase 4, 5, 6) |

**Objective:** Implement the task execution engine that runs scheduled commands.

**Deliverables:**
- `TaskExecutor` managing scheduled task execution
- Tokio-based scheduler using `tokio::time::sleep_until`
- Execution handlers for each `ExecutionTarget`:
  - NewPane: `wezterm cli split-pane --top -- /bin/sh -c "command"`
  - NewWindow: Platform-specific terminal spawning
  - Background: Detached process with `tokio::process::Command`
- Task status updates via `tokio::sync::mpsc` channel

**Acceptance Criteria:**
- [ ] Tasks execute at scheduled time (within 1 second tolerance)
- [ ] Wezterm pane execution works when Wezterm detected
- [ ] Native terminal fallback spawns new terminal window
- [ ] Background tasks run detached
- [ ] Task status updated to Running when started
- [ ] Task status updated to Completed/Failed on finish

---

### Phase 7b: TUI-Executor Integration

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, ratatui, tokio |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 4, Phase 7a |
| **Parallelizable** | No |

**Objective:** Integrate the execution engine with the TUI for real-time status updates.

**Deliverables:**
- Channel receiver integration in TUI event loop (non-blocking `try_recv()`)
- Real-time task status display updates
- Running task indicator
- X key to cancel selected pending task

**Implementation Pattern:**
```rust
loop {
    terminal.draw(|f| render(&app, f))?;

    while let Ok(event) = rx.try_recv() {
        app.handle_task_event(event);
    }

    if crossterm::event::poll(Duration::from_millis(50))? {
        // Handle keyboard input
    }
}
```

**Acceptance Criteria:**
- [ ] Task status changes reflected in table immediately
- [ ] Running tasks show visual indicator
- [ ] X key cancels selected pending task
- [ ] TUI remains responsive during task execution

---

### Phase 8: CLI Integration

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, clap, ratatui |
| **Suggested Skills** | None |
| **Complexity** | Low |
| **Dependencies** | Phase 7b |
| **Parallelizable** | No |

**Objective:** Integrate CLI argument parsing with TUI launch.

**Deliverables:**
- `queue` (no args) opens TUI with task list
- `queue --at 9:00pm "echo hi"` opens TUI with pre-populated new task
- `queue --in 15m "echo hi"` opens TUI with pre-populated new task
- Debug logging to file (`--debug` writes to `~/.queue-debug.log`)

**Acceptance Criteria:**
- [ ] All CLI invocations open TUI
- [ ] Pre-populated tasks appear in task list
- [ ] Help text reflects TUI-based workflow
- [ ] `--version` displays version without TUI

---

### Phase 9a: Library Unit Tests

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 2 |
| **Parallelizable** | Yes (can start early) |

**Objective:** Create comprehensive unit tests for library components.

**Deliverables:**
- Unit tests for all data types in `queue-lib`
- Unit tests for `JsonFileStore` with tempfile
- Unit tests for terminal detection with mocked env vars
- Unit tests for time/delay parsing edge cases

**Acceptance Criteria:**
- [ ] All public types have serialization tests
- [ ] File locking tested with concurrent access simulation
- [ ] Terminal detection tested with mocked env vars
- [ ] `cargo test -p queue-lib` achieves >80% coverage

---

### Phase 9b: TUI Component Tests

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust, ratatui |
| **Suggested Skills** | None |
| **Complexity** | Medium |
| **Dependencies** | Phase 6 |
| **Parallelizable** | Yes (after Phase 6) |

**Objective:** Create tests for TUI components using ratatui's test utilities.

**Deliverables:**
- Widget render tests using `TestBackend`
- State management tests (selection, mode transitions)
- Modal behavior tests
- Keyboard input routing tests

**Acceptance Criteria:**
- [ ] Table renders correctly with mock data
- [ ] Modal overlay renders centered
- [ ] State transitions work correctly
- [ ] `cargo test -p queue-cli` passes all TUI tests

---

### Phase 9c: Integration Tests

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust |
| **Suggested Skills** | tokio |
| **Complexity** | High |
| **Dependencies** | Phase 8 |
| **Parallelizable** | No (final test phase) |

**Objective:** Create end-to-end integration tests for the complete system.

**Deliverables:**
- CLI argument parsing integration tests
- Task scheduling and execution integration tests (with short delays)
- History persistence integration tests
- Cross-mode state sharing tests

**Acceptance Criteria:**
- [ ] Full CLI workflow tested
- [ ] Task executes at scheduled time
- [ ] History persists across process restarts
- [ ] All integration tests pass

---

### Phase 10: Documentation

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust |
| **Suggested Skills** | None |
| **Complexity** | Low |
| **Dependencies** | Phase 9c |
| **Parallelizable** | No (final) |

**Objective:** Complete documentation for users and developers.

**Deliverables:**
- Updated `queue/README.md` with TUI usage examples
- Keyboard shortcut reference
- Rustdoc for all public APIs

**Acceptance Criteria:**
- [ ] README documents all CLI flags
- [ ] README documents all TUI keybindings
- [ ] `cargo doc -p queue-lib` generates without warnings
- [ ] `cargo doc -p queue-cli` generates without warnings


## Dependency Graph

```
Phase 0 (Restructure)
    │
    ├──────────────────────────┐
    │                          │
    ▼                          ▼
Phase 1 (Data Types)      Phase 2 (Terminal Detection)
    │                          │
    │   ┌──────────────────────┤
    │   │                      │
    ▼   ▼                      ▼
Phase 3 (TUI Shell)       Phase 7a (Execution Core)
    │                          │
    ▼                          │
Phase 4 (Main Layout)  ◄───────┤
    │                          │
    ▼                          │
Phase 5a (Modal Infra)         │
    │                          │
    ├─────────────┐            │
    │             │            │
    ▼             ▼            ▼
Phase 5b       Phase 6     Phase 7b (TUI Integration)
(Input Modal)  (History)       │
    │             │            │
    └─────┬───────┴────────────┘
          │
          ▼
    Phase 8 (CLI Integration)
          │
    ┌─────┼─────┐
    │     │     │
    ▼     ▼     ▼
  9a    9b    9c (Testing - 9a can start after Phase 2)
          │
          ▼
    Phase 10 (Documentation)
```


## Lessons Learned

> Capture discoveries about skills or memory resources (CLAUDE.md, README.md, etc.) that were inaccurate, incomplete, or missing. These insights help improve future planning sessions.

- [SKILL: ratatui]: The skill mentions both `ratatui::run()` and `init()`/`restore()` patterns - for complex async integration, the explicit pattern (`init()`/`restore()` with panic hook) provides better control
- [SKILL: ratatui]: Table widget requires explicit `Row`/`Cell` construction, not direct string conversion
- [SKILL: ratatui]: Modal overlay requires three-step render: main content, `Clear` widget, then modal content
- [SKILL: crossterm]: `KeyEventKind::Press` filtering is critical for Windows compatibility
- [FILE: CLAUDE.md]: No mention of `fs2` crate for file locking, but it's the standard approach for JSONL concurrent access
- [FILE: power-queue.md]: References "wezterm skill" but it was not in the required skills list


## Package Changes in Execution

> Dependencies to be added, updated, or removed during implementation. Research for ADD actions produces skill files.

### queue-cli (new crate)
- [ADD]: ratatui = "0.30" - TUI framework for terminal user interface
    - "How to create modal overlays in ratatui?"
- [ADD]: crossterm = "0.29" - Terminal manipulation (via ratatui dependency)

### queue-lib (new crate)
- [ADD]: serde = { features = ["derive"] } - Serialization for task data and history
- [ADD]: serde_json - JSONL format for history file
- [ADD]: fs2 - Cross-platform file locking for concurrent history access
    - "How to use fs2 for file locking in Rust?"
- [ADD]: dirs - Platform-specific paths for ~/.queue-history.jsonl
- [KEEP]: chrono = { features = ["serde"] } - DateTime serialization (already in workspace)
- [KEEP]: thiserror - Error types (already in workspace)
- [KEEP]: tokio - Async runtime (already in workspace)

### Workspace Changes
- [MODIFY]: Root Cargo.toml - Change `"queue"` to `"queue/cli"`, `"queue/lib"` in members list
- [REMOVE]: queue (single crate) - Replaced by workspace split

