---
status: "executing: phase 1"
started_at: 10:55:00
finished_at: 11:03:00
duration: 8 minutes
tts_gender: male
requirements: |
  Sniff Package Roundout - Based on .ai/features/sniff-roundout.md:

  1. Rename `filesystem/monorepo` to `filesystem/repo`:
     - Rename property `monorepo.tool` to `repo.monorepo_tool`
     - `filesystem/packages` only appears when repo IS a monorepo
     - Non-monorepo: dependencies on `filesystem/repo`
     - Monorepo: dependencies at package level within `filesystem/packages`

  2. Remove `filesystem/dependencies` section:
     - Currently useless, should be removed
     - For monorepos, packages include dev/dependencies/peer/optional deps

  3. CLI switches for filtering output (mutually exclusive):
     - Top-level: --filesystem, --hardware, --os
     - Detail-level: --git, --repo, --language, --cpu, --gpu, --memory, --storage
     - Error on combined usage
     - Rename `hardware/gpus` to `hardware/gpu`

  4. Dependency properties:
     - targeted_version, actual_version (when lock file exists), package_manager
     - latest_version (only with --deep flag, requires network)

  5. Sniff Library refactoring:
     - Move os.rs from hardware to top-level module
     - Create package module for package manager resolution
     - Separate OsPackageManager and LanguagePackageManager enums
     - Implement PackageManagerShape trait (async)
     - Static package manager registry with LazyLock
required_skills: [rust, clap, strum, tokio]
important_skills:
  thiserror: "Defining error types for new package module"
  rust-testing: "Writing unit and integration tests for refactored code"
  serde: "JSON serialization adjustments for renamed fields"
  async_trait: "Implementing PackageManagerShape trait with async methods"
  reqwest: "Network operations for --deep flag functionality"
subagents:
  Plan: "Create phased implementation plan"
  Explore: "Module assessment for monorepo impact"
  general-purpose: "Reviews (completeness, concurrency, correctness) and finalization"
  feature-tester-rust: "Test implementation phases"
monorepo_modules_impacted:
  - sniff/lib/src/filesystem/mod.rs (HIGH - remove deps, rename monorepo)
  - sniff/lib/src/filesystem/monorepo.rs (HIGH - rename to repo.rs)
  - sniff/lib/src/filesystem/dependencies.rs (HIGH - delete)
  - sniff/lib/src/hardware/mod.rs (HIGH - remove os mod, rename gpu field)
  - sniff/lib/src/hardware/os.rs (MEDIUM - move to top-level)
  - sniff/lib/src/lib.rs (MEDIUM - add os/package modules)
  - sniff/lib/src/package.rs (NEW - create module)
  - sniff/cli/src/main.rs (HIGH - add 8 CLI flags)
  - sniff/cli/src/output.rs (HIGH - update all section references)
completeness_changes:
  - Phase 2 missing PackageLocation refactor for per-package dependencies
  - Phase 4 needs macro/codegen strategy for 90+ package manager variants
  - Phase 6 output schema unspecified
  - Phase 7 test coverage for exclusivity validation incomplete
concurrency_changes:
  - Phases 1-3 parallelization correctly identified
  - Sequential ordering accurate for Phases 4-7
detail_changes:
  - Phase 3 must handle detect_os() extraction from hardware module
  - Phase 1 needs explicit validation mechanism for mutual exclusivity
  - Phase 4 requires Send+Sync bounds for LazyLock trait objects
  - Phase 5 must specify network failure behavior (skip field vs error)
  - Phase 2 gpus→gpu rename belongs in hardware section, not filesystem
lessons_learned_count: 5
---
# Planning Process

- [x] Prep Started [10:55am]
    - [x] Identified Skills [10:56am]
    - [x] Identified Subagents [10:56am]
- [x] Prep complete with 35% context available [10:56am]
- [x] Clarify (orchestrator) started [10:56am]
    - [x] User asked clarifying questions (human in the loop) [10:57am]
    - [x] Requirements have been updated based on user responses [10:57am]
    - Clarifications:
      - Error handling: Result<Option<T>, Error> pattern
      - --deep flag: Already exists - no new implementation needed
      - OS package managers: Comprehensive (30+ managers across all platforms)
      - Language package managers: Comprehensive (60+ managers across all ecosystems)
- [x] Planning Subagent [agent: **Plan**] started [10:57am]
    - [x] subagent skills used: rust, clap, strum, tokio
    - [x] Planning completed [10:59am]
- [x] Module Assessment Subagent [agent: **Explore**] started [10:57am]
    - [x] subagent skills used: rust, clap
    - [x] Module Assessment completed [10:59am]
- [x] All Pre-review Steps are complete [10:59am]
    - 35% of context window is still available (warning zone)
- [x] Review Started [11:00am]
   - [x] Consolidated Review [agent: **general-purpose**] (context-optimized)
       - [x] subagent skills used: rust, clap
       - 16 recommendations (9 high priority)
- [x] Reviews Completed [11:01am]
    - ~30% of context window is still available
- [x] Plan Finalization [agent: orchestrator] started [11:02am]
    - [x] subagent skills used: rust, clap, serde, strum
    - Incorporated 9 high-priority review recommendations
- [x] Plan finalized [11:03am]
    - ~25% of context window remaining
- Final Steps
    - [x] Lessons learned collected from all subagents (5 entries)
    - [ ] Researching 3 packages (strum, strum_macros, async-trait)
- [ ] Summarized plan to user via STDOUT



## Plan

### Phase 1: CLI Argument Restructuring

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, clap |
| **Suggested Skills** | thiserror (error handling) |
| **Complexity** | Medium |
| **Dependencies** | None |
| **Parallelizable** | Yes (with Phase 2, 3) |

**Objective:** Implement mutually exclusive CLI switches with proper error handling.

**Deliverables:**
- Top-level switches: `--filesystem`, `--hardware`, `--os`
- Detail-level switches: `--git`, `--repo`, `--language`, `--cpu`, `--gpu`, `--memory`, `--storage`
- Mutual exclusivity validation with clear error messages
- **Validation function** that checks all filter flags before config building

**Implementation Notes:**
- Create `validate_filter_flags()` function that collects all active flags into a set
- Return error if set.len() > 1 with message listing which flags conflict
- Integrate validation early in main() before SniffConfig construction

**Acceptance Criteria:**
- [ ] `sniff --cpu --memory` exits with error: "Error: --cpu and --memory are mutually exclusive"
- [ ] `sniff --filesystem --git` exits with error: "Error: --filesystem and --git are mutually exclusive"
- [ ] Help text documents mutual exclusivity constraint
- [ ] All combinations of 2+ filter flags produce clear error messages

---

### Phase 2: Filesystem Section Restructuring

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, serde |
| **Suggested Skills** | strum |
| **Complexity** | High |
| **Dependencies** | None |
| **Parallelizable** | Yes (with Phase 1, 3) |

**Objective:** Rename `monorepo` to `repo`, remove `dependencies` section, restructure dependency placement.

**Deliverables:**
- Rename `MonorepoInfo` → `RepoInfo` with `monorepo_tool` field
- Remove standalone `dependencies` from `FilesystemInfo`
- Dependencies on `RepoInfo` for non-monorepos
- Dependencies on `PackageLocation` for monorepo packages
- **Update PackageLocation struct** with dependency arrays

**Implementation Notes:**
- `RepoInfo` structure for non-monorepo: contains `dependencies`, `dev_dependencies`, `peer_dependencies`, `optional_dependencies` directly
- `PackageLocation` structure for monorepo packages: add same 4 dependency arrays
- **Note:** `gpus` → `gpu` rename moved to Phase 2b (Hardware) to keep filesystem changes focused

**New Structures:**
```rust
pub struct RepoInfo {
    pub is_monorepo: bool,
    pub monorepo_tool: Option<MonorepoTool>,
    pub root: PathBuf,
    // Non-monorepo only:
    pub dependencies: Option<Vec<DependencyEntry>>,
    pub dev_dependencies: Option<Vec<DependencyEntry>>,
    pub peer_dependencies: Option<Vec<DependencyEntry>>,
    pub optional_dependencies: Option<Vec<DependencyEntry>>,
    // Monorepo only:
    pub packages: Option<Vec<PackageLocation>>,
}

pub struct PackageLocation {
    pub name: String,
    pub path: PathBuf,
    // ... existing fields ...
    pub dependencies: Option<Vec<DependencyEntry>>,
    pub dev_dependencies: Option<Vec<DependencyEntry>>,
    pub peer_dependencies: Option<Vec<DependencyEntry>>,
    pub optional_dependencies: Option<Vec<DependencyEntry>>,
}
```

**Acceptance Criteria:**
- [ ] JSON shows `"repo"` instead of `"monorepo"`
- [ ] `"monorepo_tool"` field instead of `"tool"`
- [ ] Non-monorepo repos show dependencies on `repo`
- [ ] Monorepo repos show dependencies on each package in `packages` array
- [ ] `packages` array only present when `is_monorepo: true`

---

### Phase 2b: Hardware Field Rename

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, serde |
| **Complexity** | Low |
| **Dependencies** | None |
| **Parallelizable** | Yes (with Phase 1, 2, 3) |

**Objective:** Rename `hardware/gpus` to `hardware/gpu` for consistency.

**Deliverables:**
- Rename field `HardwareInfo::gpus` → `HardwareInfo::gpu`
- Update serialization to output `"gpu"` instead of `"gpus"`
- Update CLI output references

**Acceptance Criteria:**
- [ ] JSON shows `"gpu"` instead of `"gpus"`
- [ ] CLI text output uses "GPU" (singular section name)

---

### Phase 3: OS Module Promotion

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust |
| **Suggested Skills** | - |
| **Complexity** | Medium |
| **Dependencies** | None |
| **Parallelizable** | Yes (with Phase 1, 2) |

**Objective:** Move `os.rs` from `hardware/` to top-level module.

**Deliverables:**
- New `sniff/lib/src/os/` module directory
- Updated `lib.rs` exports
- Updated import paths across codebase
- **Extract `detect_os()` function** from hardware module

**Implementation Notes:**
- Current `detect_os()` is defined in `hardware/os.rs` and exported via `hardware/mod.rs`
- Move entire `os.rs` to `lib/src/os/mod.rs`
- Update `hardware/mod.rs` to remove `mod os` and related exports
- Update `lib.rs` to add `pub mod os` and export `OsInfo`, `detect_os()`
- **Re-export from lib.rs** for backward compatibility: `pub use os::{OsInfo, detect_os, ...}`
- Update `detect_with_config()` in `lib.rs` to call `os::detect_os()` instead of `hardware::detect_os()`

**Acceptance Criteria:**
- [ ] `sniff_lib::os::OsInfo` is the canonical path
- [ ] `sniff_lib::os::detect_os()` works correctly
- [ ] CLI `--os` flag shows OS-specific info without hardware
- [ ] All existing tests pass with updated imports
- [ ] `sniff_lib::OsInfo` still works (re-export for compatibility)

---

### Phase 4: Package Module Creation

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, tokio, strum, async_trait |
| **Suggested Skills** | thiserror, serde |
| **Complexity** | High |
| **Dependencies** | Phase 3 |
| **Parallelizable** | No |

**Objective:** Create `package` module with `PackageManagerShape` trait and static registry.

**Deliverables:**
- `OsPackageManager` enum (30+ variants) with strum derives
- `LanguagePackageManager` enum (60+ variants) with strum derives
- `PackageManager` wrapper enum
- `PackageManagerShape` async trait (Result<Option<T>, Error> returns)
- Static `PACKAGE_MANAGERS` registry with `LazyLock`

**Implementation Notes:**
- Use `strum` for enum serialization: `#[strum(serialize_all = "PascalCase")]`
- For 90+ variants, use macro to reduce boilerplate:
```rust
macro_rules! impl_package_manager {
    ($enum:ident, $($variant:ident => $impl:ty),* $(,)?) => {
        impl $enum {
            pub fn get_manager(&self) -> Box<dyn PackageManagerShape + Send + Sync> {
                match self {
                    $(Self::$variant => Box::new(<$impl>::default()),)*
                }
            }
        }
    };
}
```
- Trait object storage requires `Send + Sync` bounds:
```rust
static PACKAGE_MANAGERS: LazyLock<HashMap<String, Box<dyn PackageManagerShape + Send + Sync>>> = ...
```
- Start with stub implementations that return `Ok(None)` for unimplemented managers
- Prioritize implementing: Npm, Pnpm, Yarn, Bun, Cargo, Pip, Homebrew, Apt

**Acceptance Criteria:**
- [ ] `OsPackageManager::Homebrew.to_string()` returns `"Homebrew"`
- [ ] `LanguagePackageManager::Npm.to_string()` returns `"Npm"`
- [ ] `PACKAGE_MANAGERS.get("Npm")` returns `&dyn PackageManagerShape`
- [ ] All enum variants compile with `Send + Sync` bounds
- [ ] At least 8 core managers have functional implementations

---

### Phase 5: Dependency Enrichment

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, tokio |
| **Suggested Skills** | serde, thiserror |
| **Complexity** | High |
| **Dependencies** | Phase 2, Phase 4 |
| **Parallelizable** | No |

**Objective:** Enrich dependency entries with `latest_version` using `--deep` flag.

**Deliverables:**
- Updated `DependencyEntry` struct with `latest_version` field
- Async dependency resolution for registry lookups
- Graceful degradation on network failures

**Implementation Notes:**
- **DependencyEntry field mapping:**
  - Rename `version_req` → `targeted_version`
  - Add `package_manager: String` field
  - Add `latest_version: Option<String>` field (only populated with `--deep`)
- **Network failure handling:** On network failure for a specific dependency:
  - Log warning at DEBUG level
  - Set `latest_version: None` (skip field in JSON)
  - Continue processing other dependencies
  - **Do not fail** the entire detection
- Use `PackageManagerShape::find_package()` from Phase 4 for registry lookups
- Run lookups in parallel using `tokio::join!` or `futures::join_all`

**DependencyEntry Structure:**
```rust
pub struct DependencyEntry {
    pub name: String,
    pub targeted_version: String,  // Renamed from version_req
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actual_version: Option<String>,  // From lock file
    pub package_manager: String,  // e.g., "Npm", "Cargo"
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latest_version: Option<String>,  // --deep only
}
```

**Acceptance Criteria:**
- [ ] `sniff --deep` fetches `latest_version` for all dependencies
- [ ] `sniff` without `--deep` omits `latest_version` field
- [ ] Network failures log warnings but don't fail detection
- [ ] `targeted_version` field present (renamed from `version_req`)
- [ ] `package_manager` field present as string (e.g., "Npm")

---

### Phase 6: CLI Output Updates

| Property | Value |
|----------|-------|
| **Subagent** | `general-purpose` |
| **Required Skills** | rust, clap |
| **Suggested Skills** | - |
| **Complexity** | Low |
| **Dependencies** | Phase 1, 2, 3 |
| **Parallelizable** | No |

**Objective:** Update CLI text and JSON output for all structural changes.

**Deliverables:**
- Updated text output formatting
- Updated JSON serialization for renamed fields
- Granular detail-level output for each switch

**Acceptance Criteria:**
- [ ] `sniff --json` outputs `"repo"` instead of `"monorepo"`
- [ ] `sniff --os` shows package managers, locale, timezone
- [ ] Text output reflects all structural changes

---

### Phase 7: Test Updates

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | rust |
| **Suggested Skills** | - |
| **Complexity** | Medium |
| **Dependencies** | Phase 1-6 |
| **Parallelizable** | No |

**Objective:** Update existing tests and add new tests for all changed functionality.

**Deliverables:**
- Updated integration tests for new CLI arguments
- Updated unit tests for renamed structs/fields
- New tests for mutual exclusivity validation
- New tests for package module

**Acceptance Criteria:**
- [ ] All existing tests pass or are updated
- [ ] CLI mutual exclusivity tests added
- [ ] Package manager enum tests added

---

### Dependency Graph

```
Phase 1 (CLI Args) ──────────────────────┐
                                         │
Phase 2 (Filesystem Restructure) ────────┼──> Phase 6 (CLI Output)
                                         │           │
Phase 3 (OS Module) ─────────────────────┤           │
         │                               │           v
         v                               │     Phase 7 (Tests)
Phase 4 (Package Module) ────────────────┘
         │
         v
Phase 5 (Dependency Enrichment) ─────────────────────┘
```

**Parallel Execution:** Phases 1, 2, 3 can run in parallel


## Lessons Learned

> Capture discoveries about skills or memory resources (CLAUDE.md, README.md, etc.) that were inaccurate, incomplete, or missing. These insights help improve future planning sessions.

- [CODE: sniff/lib/src/hardware/os.rs]: File is ~1800+ lines handling OS, locale, timezone, package managers - refactoring will improve maintainability
- [STRUCTURE: filesystem/dependencies.rs]: Current DependencyEntry needs `targeted_version` rename from `version_req` and `package_manager` field addition
- [PATTERN: CLI]: Existing include-only mode can be extended but mutual exclusivity requires custom validation
- [ASYNC_IMPLEMENTATION]: PackageManagerShape trait needs async-trait (not yet in Cargo.toml)
- [SERIALIZATION_IMPACT]: JSON output structure changes significantly; consider versioning strategy

## Package Changes in Execution

> Dependencies to be added, updated, or removed during implementation. Research for ADD actions produces skill files.

- [ADD]: strum in cargo (crates.io) - EnumString/Display derives for PascalCase serialization
    - "How to use strum with serde for custom serialization formats?"
    - "What is the recommended strum version for Rust 2024 edition?"
- [ADD]: strum_macros in cargo (crates.io) - Proc macro crate for strum derives
- [ADD]: async-trait in cargo (crates.io) - Required for async trait methods in PackageManagerShape
    - "Is async-trait still needed with Rust 1.75+ native async fn in traits?"

