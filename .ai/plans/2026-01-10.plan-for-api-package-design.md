---
status: "executing: phases 1.5/2/3/4/6 parallel"
started_at: "10:23:00"
finished_at: "14:52:00"
duration: "~4.5 hours (with reviews)"
tts_gender: male
requirements: |
  Design and implement the "api" package in @api/. The package provides primitives for
  defining REST APIs with type-safe callable structs generated from definitions.

  ## Refined Requirements (User Decisions)

  ### Code Generation Strategy: PROC-MACRO
  - Create a separate proc-macro crate (api-macros or api-derive)
  - Use derive macros for compile-time generation of callable API structs
  - Provides full type safety and IDE integration

  ### HTTP Client: ASYNC-FIRST
  - Use reqwest's async client with tokio runtime
  - Modern approach optimized for concurrent API requests
  - No sync/blocking API needed initially

  ### Response Validation Strategy:
  - **XML responses**: Full XSD schema validation when XmlSchema is specified
  - **JSON/YAML responses**: Serde deserialization only - success = valid
  - Different validation depth by response format

  ### OpenAPI Generation: YES
  - Auto-generate OpenAPI 3.x specifications from RestApiDefinition
  - Useful for documentation and API consumers

  ## Key Capabilities
  - Define APIs with auth strategy, base URL, docs URL, OpenAPI URL
  - Define endpoints with ID, method, path, typed input/output
  - Build/compile definitions to generate callable API structs
  - Support JSON, YAML, XML (with XSD), CSV, HTML, PlainText, Binary response types

  ## Current State (rough starting point)
  - auth.rs: ApiAuthMethod enum (complete)
  - endpoint_id.rs: Validated EndpointId type (complete)
  - rest_api.rs: Incomplete types - missing traits, broken generics, no builder
  - No HTTP client integration (reqwest unused)
  - No code generation (syn unused)

  ## Required Crates
  - quick-xml (XML parsing only - NOT for XSD validation)
  - xmlschema (XSD validation - separate from parsing)
  - syn/quote/proc-macro2 (proc-macro code generation)
  - reqwest (async HTTP client)
  - schemars/utoipa (OpenAPI/JSON Schema generation)
  - tokio (async runtime)
required_skills:
  - reqwest
  - quick-xml
  - syn
  - thiserror
  - prettyplease
important_skills:
  rust: "Core Rust patterns for generics, traits, associated types"
  schemars: "If generating JSON Schema for OpenAPI integration"
  tokio: "Async patterns with reqwest"
  rust-testing: "Unit tests for builders, code gen, HTTP mocking"
  wiremock: "HTTP endpoint mocking in integration tests"
  strum: "Enum ergonomics for HTTP methods, response types"
subagents:
  rust-architect: "Senior Rust Systems Architect - architecture, trait design, code reviews (opus)"
  schema-architect: "Data modeling, type systems, serde patterns (sonnet)"
  rust-developer: "Implementation details, async patterns, error handling (sonnet)"
  feature-tester-rust: "Testing strategy review (sonnet)"
monorepo_modules_impacted:
  - ai-pipeline/lib: "HIGH - duplicate auth, provider APIs, openai_api.rs"
  - shared: "HIGH - HTTP utilities, tools (BraveSearch, ScreenScrape), providers"
  - research/lib: "MEDIUM - registry APIs, changelog fetching"
  - model_id: "REFERENCE - proc-macro patterns to follow"
---

# Finalized Implementation Plan: API Package

## Review Feedback Summary

This plan incorporates ALL review recommendations from three review passes:

| Review Type | Recommendations Applied |
|-------------|------------------------|
| **Completeness** | Phase 0 (auth consolidation), Phase 1.5 (XSD research), error strategy, tracing, format testing |
| **Concurrency** | Parallel phases 2/3/4/6, Phase 7 split into 7a-7d, Cargo.toml consolidation, partial Phase 8 |
| **Correctness** | Trait-based ResponseFormat, removed 'static bound, xmlschema crate, ownership patterns, improved derive syntax, ApiResponseValue, type-state builders, layered errors |

---

## Architecture Overview (REVISED)

```
api/                        # Main library crate
  src/
    lib.rs                  # Re-exports + public API
    auth.rs                 # ApiAuth (CONSOLIDATED from 3 locations)
    endpoint_id.rs          # EndpointId validation (COMPLETE)
    method.rs               # RestMethod enum with strum
    endpoint.rs             # Endpoint struct with type-state builder
    definition.rs           # RestApiDefinition with builder
    response/               # Response handling module
      mod.rs                # Module exports
      format.rs             # ResponseFormat trait + implementations
      value.rs              # ApiResponseValue enum
      xml/
        mod.rs
        parser.rs           # quick-xml parsing
        validator.rs        # xmlschema XSD validation
    client/                 # HTTP client module
      mod.rs
      executor.rs           # Request execution with tracing
      pool.rs               # Connection pooling
    error/                  # Layered error types
      mod.rs
      api_error.rs          # Top-level ApiError
      client_error.rs       # HTTP/network errors
      validation_error.rs   # Response validation errors
      auth_error.rs         # Authentication errors
    openapi/                # OpenAPI generation module
      mod.rs
      generator.rs          # OpenAPI 3.x spec generation

api-macros/                 # Proc-macro crate (separate)
  src/
    lib.rs                  # Proc-macro entry points
    derive_api.rs           # #[derive(RestApi)] implementation
    endpoints.rs            # #[endpoints] attribute macro
    codegen.rs              # Code generation utilities
    parse.rs                # Custom parsing for API definitions
  tests/
    ui/                     # trybuild test cases
      pass/                 # Should compile
      fail/                 # Should fail with good errors
```

---

## Future Integration (Deferred)

> **Note:** The `api` package is developed in isolation first. Cross-package consolidation
> (making `ai-pipeline`, `shared`, and `research` depend on `api`) happens during a later
> integration phase. At that time:
> - Other packages will import `api::ApiAuthMethod` instead of their own definitions
> - Duplicate auth enums in other packages will be deprecated and removed
> - HTTP client patterns may be consolidated

---

## Phase 1: Foundation Types and Traits (REVISED)

| Property | Value |
|----------|-------|
| **Subagent** | `schema-architect` |
| **Required Skills** | thiserror, serde, strum |
| **Complexity** | High |
| **Dependencies** | Phase 0 |
| **Parallelizable** | No (foundational) |
| **Estimated Duration** | 3 hours |

**Objective:** Establish correct trait hierarchy and type system with reviewed fixes applied.

### Critical Fix 1: Trait-Based ResponseFormat (NOT PhantomData in enum)

**WRONG (current):**
```rust
pub enum ApiResponse<T: ApiResponseShape, X: XmlSchema> {
    Json(Option<T>),
    Xml(Option<X>),
    // PhantomData forces T and X to be constrained even for PlainText
}
```

**CORRECT:**
```rust
use std::future::Future;
use serde::de::DeserializeOwned;

/// Marker trait for response format parsing strategies.
/// Each format implements its own parsing logic.
pub trait ResponseFormat {
    /// The output type after parsing
    type Output: Send + Sync;
    /// The error type for parsing failures
    type Error: std::error::Error + Send + Sync + 'static;

    /// Parse a response into the output type
    fn parse(response: reqwest::Response) -> impl Future<Output = Result<Self::Output, Self::Error>> + Send;
}

/// JSON response format with typed deserialization
pub struct JsonFormat<T>(std::marker::PhantomData<T>);

impl<T: DeserializeOwned + Send + Sync> ResponseFormat for JsonFormat<T> {
    type Output = T;
    type Error = serde_json::Error;

    async fn parse(response: reqwest::Response) -> Result<Self::Output, Self::Error> {
        response.json().await.map_err(Into::into)
    }
}

/// YAML response format with typed deserialization
pub struct YamlFormat<T>(std::marker::PhantomData<T>);

/// XML response format with optional XSD validation
pub struct XmlFormat<X: XmlSchema>(std::marker::PhantomData<X>);

/// Plain text response (no parsing)
pub struct PlainTextFormat;

impl ResponseFormat for PlainTextFormat {
    type Output = String;
    type Error = reqwest::Error;

    async fn parse(response: reqwest::Response) -> Result<Self::Output, Self::Error> {
        response.text().await
    }
}

/// HTML response (plain text with semantic marker)
pub struct HtmlFormat;

/// CSV response (plain text with semantic marker)
pub struct CsvFormat;

/// Binary response (raw bytes)
pub struct BinaryFormat;

impl ResponseFormat for BinaryFormat {
    type Output = Vec<u8>;
    type Error = reqwest::Error;

    async fn parse(response: reqwest::Response) -> Result<Self::Output, Self::Error> {
        response.bytes().await.map(|b| b.to_vec())
    }
}
```

### Critical Fix 2: Remove 'static Bound

**WRONG:**
```rust
pub trait ApiResponseShape: DeserializeOwned + Send + Sync + 'static {}
```

**CORRECT:**
```rust
// DeserializeOwned already implies 'static - no need to add it
pub trait ApiResponseShape: DeserializeOwned + Send + Sync {}

// Auto-implement for all qualifying types
impl<T: DeserializeOwned + Send + Sync> ApiResponseShape for T {}
```

### Critical Fix 3: XmlSchema Trait Design

```rust
use std::borrow::Cow;

/// Trait for XML response types with optional XSD validation.
/// XSD validation is SEPARATE from parsing (uses xmlschema crate).
pub trait XmlSchema: DeserializeOwned + Send + Sync {
    /// Returns the XSD schema for validation, if available.
    ///
    /// ## Notes
    /// - Return `None` to skip XSD validation
    /// - Return `Some(Cow::Borrowed(...))` for static XSD strings
    /// - Return `Some(Cow::Owned(...))` for runtime-loaded XSD
    fn xsd_schema() -> Option<Cow<'static, str>> { None }
}

// Separate functions for parsing vs validation
pub fn parse_xml<X: XmlSchema>(xml: &str) -> Result<X, XmlParseError>;
pub fn validate_xml<X: XmlSchema>(xml: &str) -> Result<(), XmlValidationError>;
pub async fn parse_and_validate_xml<X: XmlSchema>(xml: &str) -> Result<X, XmlError>;
```

### Critical Fix 4: ApiResponseValue Definition

```rust
/// Parsed response value from an API call.
/// This is the OUTPUT type, not the format specifier.
pub enum ApiResponseValue<T, X = ()> {
    /// Parsed JSON response
    Json(T),
    /// Parsed YAML response
    Yaml(T),
    /// Parsed XML response (with optional XSD validation)
    Xml(X),
    /// Plain text response
    PlainText(String),
    /// HTML response
    Html(String),
    /// CSV response (unparsed - caller handles parsing)
    Csv(String),
    /// Binary response
    Binary(Vec<u8>),
}

impl<T, X> ApiResponseValue<T, X> {
    /// Returns true if this is a structured data response (JSON/YAML/XML)
    pub fn is_structured(&self) -> bool {
        matches!(self, Self::Json(_) | Self::Yaml(_) | Self::Xml(_))
    }

    /// Attempt to get JSON value, returning None for other formats
    pub fn as_json(&self) -> Option<&T> {
        match self {
            Self::Json(v) => Some(v),
            _ => None,
        }
    }
}
```

### Critical Fix 5: Type-State Builder Pattern

```rust
/// Marker traits for builder state tracking
pub mod builder_state {
    pub struct Missing;
    pub struct Present;
}

use builder_state::{Missing, Present};

pub struct EndpointBuilder<Method, Path, Response> {
    id: Option<String>,
    method: Option<RestMethod>,
    path: Option<String>,
    description: Option<String>,
    _phantom: std::marker::PhantomData<(Method, Path, Response)>,
}

impl EndpointBuilder<Missing, Missing, Missing> {
    pub fn new() -> Self {
        Self {
            id: None,
            method: None,
            path: None,
            description: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<P, R> EndpointBuilder<Missing, P, R> {
    pub fn method(self, method: RestMethod) -> EndpointBuilder<Present, P, R> {
        EndpointBuilder {
            method: Some(method),
            id: self.id,
            path: self.path,
            description: self.description,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<M, R> EndpointBuilder<M, Missing, R> {
    pub fn path(self, path: impl Into<String>) -> EndpointBuilder<M, Present, R> {
        EndpointBuilder {
            path: Some(path.into()),
            id: self.id,
            method: self.method,
            description: self.description,
            _phantom: std::marker::PhantomData,
        }
    }
}

// Only allow build() when all required fields present
impl<F: ResponseFormat> EndpointBuilder<Present, Present, Present> {
    pub fn build(self) -> Endpoint<F> {
        Endpoint {
            id: self.id.expect("id set"),
            method: self.method.expect("method set"),
            path: self.path.expect("path set"),
            description: self.description,
            _format: std::marker::PhantomData,
        }
    }
}
```

### Critical Fix 6: Layered Error Types

```rust
use thiserror::Error;

/// Top-level API error type
#[derive(Debug, Error)]
pub enum ApiError {
    /// HTTP client errors (network, timeout, etc.)
    #[error(transparent)]
    Client(#[from] ClientError),

    /// Response validation errors (parse, XSD, etc.)
    #[error(transparent)]
    Validation(#[from] ValidationError),

    /// Authentication errors
    #[error(transparent)]
    Auth(#[from] AuthError),

    /// Endpoint configuration errors
    #[error(transparent)]
    Config(#[from] ConfigError),
}

/// HTTP client errors
#[derive(Debug, Error)]
pub enum ClientError {
    #[error("HTTP request failed: {0}")]
    Request(#[from] reqwest::Error),

    #[error("HTTP {status}: {message}")]
    HttpStatus { status: u16, message: String },

    #[error("Request timeout after {duration_ms}ms")]
    Timeout { duration_ms: u64 },

    #[error("Connection failed: {0}")]
    Connection(String),
}

/// Response validation errors
#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("JSON parse error: {0}")]
    JsonParse(#[from] serde_json::Error),

    #[error("YAML parse error: {0}")]
    YamlParse(#[from] serde_yaml::Error),

    #[error("XML parse error: {0}")]
    XmlParse(#[from] quick_xml::DeError),

    #[error("XSD validation failed: {0}")]
    XsdValidation(String),

    #[error("Unexpected content type: expected {expected}, got {actual}")]
    ContentTypeMismatch { expected: String, actual: String },
}

/// Authentication errors
#[derive(Debug, Error)]
pub enum AuthError {
    #[error("Missing API key for {provider}")]
    MissingApiKey { provider: String },

    #[error("Invalid API key format")]
    InvalidKeyFormat,

    #[error("Authentication failed: {message}")]
    AuthenticationFailed { message: String },
}

/// Configuration errors
#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("Invalid URL: {0}")]
    InvalidUrl(#[from] url::ParseError),

    #[error("Missing required field: {field}")]
    MissingField { field: &'static str },

    #[error("Invalid endpoint ID: {0}")]
    InvalidEndpointId(#[from] crate::EndpointIdError),
}
```

### RestMethod Enum

```rust
use strum::{Display, EnumIter, EnumString};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Display, EnumIter, EnumString)]
#[strum(serialize_all = "UPPERCASE")]
pub enum RestMethod {
    Get,
    Post,
    Put,
    Patch,
    Delete,
    Head,
    Options,
    Trace,
}

impl RestMethod {
    /// Returns true if this method typically has a request body
    pub fn has_body(&self) -> bool {
        matches!(self, Self::Post | Self::Put | Self::Patch)
    }

    /// Returns true if this method is idempotent
    pub fn is_idempotent(&self) -> bool {
        !matches!(self, Self::Post | Self::Patch)
    }
}
```

**Acceptance Criteria:**
- [ ] `ResponseFormat` trait with format-specific implementations
- [ ] Type-state builder for `Endpoint` with compile-time safety
- [ ] `ApiResponseValue<T, X>` enum fully defined
- [ ] Layered error hierarchy with thiserror
- [ ] `RestMethod` enum with strum derives
- [ ] No `'static` bounds where `DeserializeOwned` suffices
- [ ] Unit tests for all builder methods and error conversions

---

## Phase 1.5: XSD Validation Strategy Research (NEW)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | quick-xml |
| **Complexity** | Medium |
| **Dependencies** | None (can start during Phase 1) |
| **Parallelizable** | Yes (with Phase 1) |
| **Estimated Duration** | 1 hour |

**Objective:** Research and select XSD validation crate since quick-xml CANNOT do XSD validation.

**Background:** The original plan incorrectly assumed quick-xml could validate XSD schemas. quick-xml only PARSES XML - it has no XSD validation capability.

**Research Tasks:**
1. Evaluate `xmlschema` crate for runtime XSD validation
2. Evaluate `xsd-parser` crate (primarily for code generation, not runtime)
3. Consider libxml2 bindings if pure Rust options are insufficient
4. Document API surface and integration patterns

**Candidate Crates:**

| Crate | Purpose | Notes |
|-------|---------|-------|
| `xmlschema` | Runtime XSD validation | Pure Rust, limited schema support |
| `libxml` | libxml2 bindings | Full XSD 1.0/1.1, requires C dep |
| `xsd-parser` | Code gen from XSD | Not for runtime validation |

**Deliverables:**
- Technical decision document in `api/.ai/decisions/xsd-validation.md`
- Recommended crate with justification
- API wrapper design for `XmlSchema` trait integration
- Fallback strategy if XSD validation is unavailable

**Acceptance Criteria:**
- [ ] Decision documented with pros/cons
- [ ] Selected crate can validate basic XSD schemas
- [ ] Integration design compatible with `XmlSchema` trait
- [ ] Clear fallback when XSD unavailable (parse-only mode)

---

## Phase 2: XSD Validation Infrastructure (PARALLEL)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | quick-xml, xmlschema (or selected crate) |
| **Complexity** | High |
| **Dependencies** | Phase 1, Phase 1.5 |
| **Parallelizable** | Yes (with Phases 3, 4, 6 after Phase 1 complete) |
| **Estimated Duration** | 4 hours |

**Objective:** Implement separate XML parsing (quick-xml) and XSD validation (xmlschema).

**Key Design:** Separation of concerns between parsing and validation:

```rust
// api/src/response/xml/parser.rs
use quick_xml::de::from_str;

pub fn parse_xml<X: XmlSchema>(xml: &str) -> Result<X, XmlParseError> {
    from_str(xml).map_err(XmlParseError::from)
}

// api/src/response/xml/validator.rs
// Uses xmlschema crate (or selected alternative)

pub struct XsdValidator {
    schema: Option<CompiledSchema>,
}

impl XsdValidator {
    pub fn new<X: XmlSchema>() -> Result<Self, XsdCompileError> {
        match X::xsd_schema() {
            Some(xsd) => {
                let schema = compile_xsd(&xsd)?;
                Ok(Self { schema: Some(schema) })
            }
            None => Ok(Self { schema: None }),
        }
    }

    pub fn validate(&self, xml: &str) -> Result<(), XsdValidationError> {
        match &self.schema {
            Some(schema) => schema.validate(xml),
            None => Ok(()), // No XSD = skip validation
        }
    }
}

// Combined operation
pub async fn parse_and_validate<X: XmlSchema>(xml: &str) -> Result<X, XmlError> {
    // Validate first (fail fast)
    let validator = XsdValidator::new::<X>()?;
    validator.validate(xml)?;

    // Then parse
    parse_xml(xml).map_err(Into::into)
}
```

**Deliverables:**
- `api/src/response/xml/parser.rs` - quick-xml parsing
- `api/src/response/xml/validator.rs` - XSD validation
- `XmlParseError` and `XsdValidationError` types
- Integration with `ResponseFormat` trait for `XmlFormat<X>`
- Graceful fallback when XSD unavailable

**Acceptance Criteria:**
- [ ] XML parsing works without XSD
- [ ] XSD validation works for well-formed schemas
- [ ] Clear error messages for validation failures
- [ ] Integration tests with sample XML/XSD pairs
- [ ] Graceful fallback when XSD is malformed

---

## Phase 3: Async HTTP Client Integration (PARALLEL)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | reqwest, tokio, tracing |
| **Complexity** | Medium |
| **Dependencies** | Phase 1 |
| **Parallelizable** | Yes (with Phases 2, 4, 6 after Phase 1 complete) |
| **Estimated Duration** | 3 hours |

**Objective:** Implement async HTTP client with tracing instrumentation.

### Critical Fix: Async Lifetime / Ownership

**WRONG (reference with lifetime issues):**
```rust
pub async fn execute<F: ResponseFormat>(&self, endpoint: &Endpoint<F>) -> Result<F::Output, ApiError>
```

**CORRECT (ownership or Clone):**
```rust
// Option 1: Take ownership
pub async fn execute<F: ResponseFormat>(&self, endpoint: Endpoint<F>) -> Result<F::Output, ApiError>

// Option 2: Clone internally (if endpoints are reusable)
pub async fn execute<F: ResponseFormat>(&self, endpoint: &Endpoint<F>) -> Result<F::Output, ApiError>
where
    Endpoint<F>: Clone,
```

**Recommendation:** Use Option 2 (Clone) since endpoints are likely reused.

### Tracing Instrumentation (OpenTelemetry Conventions)

```rust
use tracing::{instrument, info, debug, Span};

impl ApiClient {
    #[instrument(
        name = "api_request",
        skip(self, auth),
        fields(
            http.method = %endpoint.method(),
            http.url = %endpoint.full_url(&self.base_url),
            http.status_code = tracing::field::Empty,
            http.request_content_length = tracing::field::Empty,
            http.response_content_length = tracing::field::Empty,
            otel.kind = "client",
            otel.status_code = tracing::field::Empty,
        )
    )]
    pub async fn execute<F: ResponseFormat>(
        &self,
        endpoint: &Endpoint<F>,
        auth: &ApiAuth,
    ) -> Result<F::Output, ApiError>
    where
        Endpoint<F>: Clone,
    {
        let request = self.build_request(endpoint, auth)?;

        let response = self.client
            .execute(request)
            .await
            .map_err(ClientError::from)?;

        // Record response fields
        let span = Span::current();
        span.record("http.status_code", response.status().as_u16());

        if !response.status().is_success() {
            span.record("otel.status_code", "ERROR");
            return Err(ClientError::HttpStatus {
                status: response.status().as_u16(),
                message: response.text().await.unwrap_or_default(),
            }.into());
        }

        span.record("otel.status_code", "OK");
        F::parse(response).await.map_err(|e| ValidationError::from(e).into())
    }
}
```

**Deliverables:**
- `ApiClient` struct wrapping `reqwest::Client` with connection pooling
- Auth method application (Bearer, HeaderKey, QueryParam)
- Request building from Endpoint definitions
- Response parsing via `ResponseFormat` trait
- Full tracing instrumentation with OpenTelemetry semantic conventions
- `ClientError` with reqwest integration

**Acceptance Criteria:**
- [ ] All HTTP methods work correctly
- [ ] Auth methods correctly applied to requests
- [ ] Query params for GET, body for POST/PUT/PATCH
- [ ] Tracing spans with all semantic fields populated
- [ ] Integration tests with wiremock
- [ ] Connection pooling enabled by default

---

## Phase 4: Proc-Macro Crate Setup (PARALLEL)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-architect` |
| **Required Skills** | syn, quote, proc-macro2 |
| **Complexity** | Medium |
| **Dependencies** | Phase 1 |
| **Parallelizable** | Yes (with Phases 2, 3, 6 after Phase 1 complete) |
| **Estimated Duration** | 2 hours |

**Objective:** Set up proc-macro crate with improved derive syntax.

### Critical Fix: Improved Derive Macro Syntax

**AWKWARD (struct with fields of `()`):**
```rust
#[derive(RestApi)]
pub struct MyApi {
    get_models: (),
    create_user: (),
}
```

**BETTER (impl block approach):**
```rust
use api_macros::{RestApi, endpoints};

#[derive(RestApi)]
#[api(base_url = "https://api.example.com")]
#[api(auth = bearer)]
#[api(docs = "https://docs.example.com")]
pub struct ExampleApi;

#[endpoints(api = ExampleApi)]
impl ExampleApi {
    /// Get all available models
    #[endpoint(method = Get, path = "/models")]
    #[response(json)]
    pub async fn get_models(&self) -> Result<ModelsResponse, ApiError>;

    /// Create a new user
    #[endpoint(method = Post, path = "/users")]
    #[request(json)]
    #[response(json)]
    pub async fn create_user(&self, input: CreateUserRequest) -> Result<User, ApiError>;

    /// Get user by ID
    #[endpoint(method = Get, path = "/users/{id}")]
    #[response(json)]
    pub async fn get_user(&self, id: String) -> Result<User, ApiError>;
}
```

### Cargo.toml Consolidation (All Dependencies Here)

This is the serialization point for dependency additions to avoid merge conflicts:

```toml
# api/Cargo.toml
[package]
name = "api"
version = "0.1.0"
edition = "2024"

[dependencies]
quick-xml = { version = "0.38", features = ["serde", "serde-types", "serialize"] }
reqwest = { version = "0.13", default-features = false, features = ["json", "rustls-tls"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
strum = { version = "0.26", features = ["derive"] }
thiserror = "2.0"
tokio = { version = "1.48", features = ["rt", "macros"] }
tracing = "0.1"
url = "2.5"
# XSD validation - pending Phase 1.5 decision
# xmlschema = "0.1"  # OR libxml = "0.3"

# OpenAPI generation
utoipa = { version = "5.3", features = ["actix_extras"] }

[dev-dependencies]
tokio = { version = "1.48", features = ["rt-multi-thread", "macros"] }
wiremock = "0.6"
tracing-test = "0.2"

# api-macros/Cargo.toml
[package]
name = "api-macros"
version = "0.1.0"
edition = "2024"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "parsing", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"
prettyplease = "0.2"

[dev-dependencies]
trybuild = "1.0"
```

**Deliverables:**
- New `api-macros/` directory with Cargo.toml
- Workspace integration in root Cargo.toml
- `#[derive(RestApi)]` skeleton with struct parsing
- `#[endpoints]` attribute macro skeleton
- trybuild test infrastructure with pass/fail directories
- ALL dependencies consolidated in this phase

**Acceptance Criteria:**
- [ ] Crate compiles as proc-macro
- [ ] Basic derive macro parses struct with `#[api(...)]` attributes
- [ ] Workspace members updated in root Cargo.toml
- [ ] trybuild tests in place (even if basic)
- [ ] All Phase 2-6 dependencies added to Cargo.toml files

---

## Phase 5: Code Generation Implementation

| Property | Value |
|----------|-------|
| **Subagent** | `rust-developer` |
| **Required Skills** | syn, quote, prettyplease |
| **Complexity** | High |
| **Dependencies** | Phase 4 |
| **Parallelizable** | No |
| **Estimated Duration** | 6 hours |

**Objective:** Implement full derive macro code generation.

**Generated Code Example:**

For this input:
```rust
#[derive(RestApi)]
#[api(base_url = "https://api.example.com")]
pub struct ExampleApi;

#[endpoints(api = ExampleApi)]
impl ExampleApi {
    #[endpoint(method = Get, path = "/models")]
    #[response(json)]
    pub async fn get_models(&self) -> Result<ModelsResponse, ApiError>;
}
```

Generate:
```rust
impl ExampleApi {
    /// Create a new API client instance
    pub fn new(auth: ApiAuth) -> Self {
        Self {
            client: ApiClient::new("https://api.example.com"),
            auth,
        }
    }

    /// Get all available models
    ///
    /// ## Errors
    /// Returns `ApiError` if the request fails or response cannot be parsed.
    pub async fn get_models(&self) -> Result<ModelsResponse, ApiError> {
        static ENDPOINT: Endpoint<JsonFormat<ModelsResponse>> = Endpoint {
            id: "get_models",
            method: RestMethod::Get,
            path: "/models",
            description: Some("Get all available models"),
            _format: std::marker::PhantomData,
        };

        self.client.execute(&ENDPOINT, &self.auth).await
    }
}

// Generated supporting types
struct ExampleApiClient {
    client: ApiClient,
    auth: ApiAuth,
}
```

**Deliverables:**
- Parse `#[api(...)]` attributes for struct-level config
- Parse `#[endpoint(...)]` attributes for method-level config
- Parse `#[request(...)]` and `#[response(...)]` format specifiers
- Generate endpoint static definitions
- Generate async method implementations
- Generate path parameter substitution for `/users/{id}` patterns
- Pretty-printed output via prettyplease
- Span-aware error messages for invalid inputs

**Acceptance Criteria:**
- [ ] Derive macro generates compilable code
- [ ] Generated methods are async
- [ ] Path parameters correctly extracted and substituted
- [ ] Request/response format types correctly propagated
- [ ] Span-aware error messages point to correct source locations
- [ ] trybuild pass/fail tests comprehensive

---

## Phase 6: OpenAPI Generation (PARALLEL)

| Property | Value |
|----------|-------|
| **Subagent** | `schema-architect` |
| **Required Skills** | serde, utoipa |
| **Complexity** | Medium |
| **Dependencies** | Phase 1 |
| **Parallelizable** | Yes (with Phases 2, 3, 4 after Phase 1 complete) |
| **Estimated Duration** | 3 hours |

**Objective:** Generate OpenAPI 3.x specs from RestApiDefinition.

**Deliverables:**
- `OpenApiGenerator` struct
- `generate_spec()` method returning OpenAPI 3.x document
- JSON and YAML output options
- Integration with utoipa's `ToSchema` trait
- Auth schemes documented in spec
- Path parameter documentation

**Generated OpenAPI Example:**
```yaml
openapi: 3.1.0
info:
  title: Example API
  version: 1.0.0
servers:
  - url: https://api.example.com
paths:
  /models:
    get:
      operationId: get_models
      summary: Get all available models
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ModelsResponse'
components:
  schemas:
    ModelsResponse:
      type: object
      properties:
        models:
          type: array
          items:
            $ref: '#/components/schemas/Model'
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
security:
  - bearerAuth: []
```

**Acceptance Criteria:**
- [ ] Valid OpenAPI 3.x spec generated
- [ ] All endpoints represented with correct methods/paths
- [ ] Auth requirements documented as security schemes
- [ ] Request/response schemas included
- [ ] Spec validates against OpenAPI validator

---

## Phase 7a: HTTP Client + XSD Integration Testing

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | wiremock, tokio |
| **Complexity** | Medium |
| **Dependencies** | Phases 2, 3 |
| **Parallelizable** | No (testing checkpoint) |
| **Estimated Duration** | 2 hours |

**Objective:** Verify HTTP client and XSD validation work together.

**Test Coverage:**
- [ ] All 7 response formats parsed correctly:
  - JSON with valid/invalid structure
  - YAML with valid/invalid structure
  - XML without XSD (parse only)
  - XML with valid XSD
  - XML with invalid XSD (validation failure)
  - PlainText, HTML, CSV
  - Binary responses
- [ ] All auth methods applied correctly
- [ ] Error propagation from client to caller
- [ ] Connection pooling behavior
- [ ] Timeout handling

---

## Phase 7b: Proc-Macro Testing

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | trybuild, syn |
| **Complexity** | Medium |
| **Dependencies** | Phase 5 |
| **Parallelizable** | Yes (with 7a if Phase 5 done) |
| **Estimated Duration** | 2 hours |

**Objective:** Verify proc-macro generates correct code.

**Test Coverage:**
- [ ] trybuild pass cases:
  - Basic API with single endpoint
  - API with multiple endpoints
  - All HTTP methods
  - Path parameters
  - Request bodies
  - All response formats
- [ ] trybuild fail cases:
  - Missing required attributes
  - Invalid method names
  - Invalid path patterns
  - Type mismatches
  - Clear error messages

---

## Phase 7c: OpenAPI Testing

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | serde_json, serde_yaml |
| **Complexity** | Low |
| **Dependencies** | Phase 6 |
| **Parallelizable** | Yes (with 7a, 7b) |
| **Estimated Duration** | 1 hour |

**Objective:** Verify OpenAPI spec generation.

**Test Coverage:**
- [ ] Generated spec is valid JSON/YAML
- [ ] All endpoints present in spec
- [ ] Schemas correctly reference types
- [ ] Security schemes documented
- [ ] Spec validates against OpenAPI 3.x validator

---

## Phase 7d: End-to-End Testing

| Property | Value |
|----------|-------|
| **Subagent** | `feature-tester-rust` |
| **Required Skills** | wiremock, tokio |
| **Complexity** | High |
| **Dependencies** | Phases 7a, 7b, 7c |
| **Parallelizable** | No (final integration) |
| **Estimated Duration** | 3 hours |

**Objective:** Full end-to-end testing: define -> generate -> execute.

**Test Coverage:**
- [ ] Define complete API with proc-macro
- [ ] Generated code compiles and runs
- [ ] Execute requests against wiremock
- [ ] Verify response parsing
- [ ] Generate OpenAPI spec from same definition
- [ ] Error handling end-to-end

**Acceptance Criteria:**
- [ ] All integration tests pass
- [ ] Code coverage > 80% for api crate
- [ ] Code coverage > 70% for api-macros crate
- [ ] Performance benchmarks documented

---

## Phase 8: Documentation and Examples (PARTIAL PARALLEL)

| Property | Value |
|----------|-------|
| **Subagent** | `rust-architect` |
| **Required Skills** | None |
| **Complexity** | Low |
| **Dependencies** | Phases 1-6 (partial), Phase 7 (full) |
| **Parallelizable** | Partially - can start after Phase 6 |
| **Estimated Duration** | 2 hours |

**Objective:** Complete documentation and examples.

**Parallel Work (can start after Phase 6):**
- [ ] Rustdoc for foundation types (Phase 1)
- [ ] Rustdoc for response formats (Phase 1)
- [ ] Rustdoc for error types (Phase 1)
- [ ] Example: Basic JSON API definition
- [ ] Example: XML API with XSD validation

**Sequential Work (requires Phase 7):**
- [ ] Rustdoc for proc-macro attributes
- [ ] README.md comprehensive guide
- [ ] Example: Full featured API
- [ ] Migration guide from existing code
- [ ] No broken doc links verification

**Deliverables:**
- Updated `api/README.md` with comprehensive guide
- Rustdoc for all public items
- `api/examples/` directory with:
  - `basic_json_api.rs` - Simple JSON API
  - `xml_with_xsd.rs` - XML API with XSD validation
  - `full_featured.rs` - All features demonstrated
- Migration guide from `ai-pipeline` and `shared` auth types

**Acceptance Criteria:**
- [ ] All public items documented with examples
- [ ] Examples compile and run
- [ ] No broken doc links
- [ ] Migration guide tested

---

## Execution Dependency Graph

```
Phase 1 (Foundation Types)
     │
     ├──────────────────┬──────────────────┬──────────────────┐
     │                  │                  │                  │
     ▼                  ▼                  ▼                  ▼
Phase 1.5           Phase 2            Phase 3            Phase 4
(XSD Research)      (XSD Infra)        (HTTP Client)      (Macro Setup)
     │                  │                  │                  │
     │                  │                  │                  │
     └──────────────────┴──────────────────│──────────────────┘
                        │                  │
                        ▼                  │
                    Phase 6                │
                    (OpenAPI)              │
                        │                  │
                        │                  ▼
                        │              Phase 5
                        │            (Code Gen)
                        │                  │
                        ▼                  ▼
                     Phase 7c           Phase 7b
                    (OpenAPI Tests)   (Macro Tests)
                        │                  │
                        └────────┬─────────┘
                                 │
Phase 7a ◄───────────────────────┤
(HTTP+XSD Tests)                 │
         │                       │
         └───────────────────────┤
                                 │
                                 ▼
                             Phase 7d
                           (E2E Tests)
                                 │
                                 ▼
                             Phase 8
                         (Documentation)

LEGEND:
───────  Sequential dependency
- - - -  Partial parallel (can start subset of work)
```

---

## Rejected Recommendations

| Recommendation | Reason for Rejection |
|----------------|---------------------|
| Use `libxml` for XSD validation | Requires C dependency; prefer pure Rust `xmlschema` if capable. Decision deferred to Phase 1.5 research. |
| Generate sync API alongside async | Violates user requirement for async-first. Can add later if needed. |
| Use `schemars` for OpenAPI | `utoipa` provides more OpenAPI-specific features and is actively maintained. |

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| `xmlschema` crate insufficient for complex XSD | Phase 1.5 research will identify fallback (libxml2 bindings) |
| Proc-macro compile time too slow | Use `prettyplease` for formatting, minimize generated code |
| Type-state builders too complex | Provide non-builder constructors as escape hatch |
| Tracing overhead in hot path | Use `tracing::Level::DEBUG` for verbose fields |

---

## Files Summary

| File | Action | Phase |
|------|--------|-------|
| `api/src/auth.rs` | Modify - consolidate ApiAuth | 0 |
| `ai-pipeline/lib/src/api/auth.rs` | Modify - re-export | 0 |
| `shared/src/api/types.rs` | Modify - re-export | 0 |
| `api/src/response/format.rs` | Create - ResponseFormat trait | 1 |
| `api/src/response/value.rs` | Create - ApiResponseValue | 1 |
| `api/src/endpoint.rs` | Create - type-state builder | 1 |
| `api/src/method.rs` | Create - RestMethod enum | 1 |
| `api/src/error/*.rs` | Create - layered errors | 1 |
| `api/.ai/decisions/xsd-validation.md` | Create - decision doc | 1.5 |
| `api/src/response/xml/*.rs` | Create - parser + validator | 2 |
| `api/src/client/*.rs` | Create - HTTP client | 3 |
| `api-macros/Cargo.toml` | Create - proc-macro crate | 4 |
| `api-macros/src/*.rs` | Create - macro implementation | 4, 5 |
| `api/src/openapi/*.rs` | Create - OpenAPI generation | 6 |
| `api/tests/integration/*.rs` | Create - integration tests | 7a-7d |
| `api/README.md` | Modify - comprehensive guide | 8 |
| `api/examples/*.rs` | Create - example files | 8 |

---

## Verification Checklist

After all phases complete:

1. `cargo build -p api -p api-macros` - both crates compile
2. `cargo test -p api` - all unit tests pass
3. `cargo test -p api-macros` - trybuild tests pass
4. `cargo clippy -p api -p api-macros -- -D warnings` - no warnings
5. `cargo doc -p api --no-deps` - docs build, no broken links
6. Examples in `api/examples/` compile and run
7. OpenAPI spec validates against external validator
8. Migration from `ai-pipeline`/`shared` auth types verified
