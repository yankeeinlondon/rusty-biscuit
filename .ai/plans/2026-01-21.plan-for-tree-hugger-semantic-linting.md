# Tree-Hugger Semantic Linting Implementation Plan

## Overview

Implement the full semantic linting framework for tree-hugger as described in `.ai/prompts/linting-rules.md`, including:

- Reference tracking infrastructure
- Language builtin symbol lists
- Semantic lint rules (undefined-symbol, unused-symbol, unused-import)
- Dead code detection
- Ignore directives
- Comprehensive test fixtures

**Estimated Duration:** 20-27 hours across 8 phases

---

## Current State

**Already Implemented:**

- `lint_diagnostics()` method with pattern-based query execution
- `syntax_diagnostics()` method detecting parse errors via tree-sitter ERROR nodes
- Symbol extraction: `symbols()`, `imported_symbols()`, `exported_symbols()`
- 16 language lint.scm files with patterns: `unwrap-call`, `expect-call`
- `LintDiagnostic`, `SourceContext`, `DiagnosticSeverity` types
- CLI `hug lint` subcommand with `--json` and `--plain` output

**To Be Removed (existing but too noisy):**

- `debug-print` - console.log, print(), etc. (too common in development)
- `empty-block` - empty {} blocks (often intentional)
- `todo-comment` - TODO/FIXME comments (user request)

**Missing (to be implemented):**

- Reference tracking (`referenced_symbols()` method)
- Builtin symbol lists per language (all 16 languages)
- Semantic checks: undefined-symbol, unused-symbol, unused-import
- Dead code detection with control flow analysis
- Ignore directive parsing and filtering

---

## Syntax Errors vs Lint Diagnostics

**Syntax Errors** (`syntax_diagnostics()`):

- Detected via tree-sitter ERROR nodes in parse tree
- Code that violates grammar rules and fails to parse correctly
- Example: `const const x = 1` → produces ERROR node
- Always `DiagnosticSeverity::Error`

**Lint Diagnostics** (`lint_diagnostics()`):

- Code that **parses correctly** but has semantic issues or problematic patterns
- Example: `let x = 1;` where `x` is never used → valid syntax, semantic issue
- Severity varies by rule (Error, Warning, Info)

These are complementary - syntax errors catch parse failures, lint diagnostics catch valid-but-problematic code.

---

## Phase 1: Reference Tracking Infrastructure

| Property | Value |
|----------|-------|
| **Complexity** | High |
| **Dependencies** | None |

**Objective:** Enable tracking of all identifier references within a file to support semantic checks.

**Deliverables:**

1. Add `QueryKind::References` to `lib/src/queries/mod.rs`
2. Create `references.scm` query files for all 16 languages in `lib/queries/{lang}/`
3. Implement `referenced_symbols()` method on `TreeFile`
4. Add `ReferencedSymbol` type to `lib/src/shared/symbol.rs`

**Key Files:**

- `tree-hugger/lib/src/queries/mod.rs`
- `tree-hugger/lib/src/file/tree_file.rs`
- `tree-hugger/lib/src/shared/symbol.rs`
- `tree-hugger/lib/queries/{lang}/references.scm` (16 files)

**Acceptance Criteria:**

- [ ] `referenced_symbols()` returns all identifier usages in a file
- [ ] References include name, range, and containing scope
- [ ] Test coverage for reference extraction in all 16 languages

**Future Consideration:** Capture the containing scope (function/method/block) for each reference. This enables future dependency analysis like "what symbols does function X depend on?" and call graph generation. The `ReferencedSymbol` type should include an optional `containing_scope: Option<String>` field to support this.

---

## Phase 2: Language Builtin Symbol Lists

| Property | Value |
|----------|-------|
| **Complexity** | High |
| **Dependencies** | None (parallel with Phase 1) |

**Objective:** Create per-language lists of "always defined" symbols to prevent false undefined-symbol errors for all 16 languages.

**Deliverables:**

1. Create `lib/src/builtins.rs` module
2. Implement `is_builtin(language: ProgrammingLanguage, name: &str) -> bool`
3. Add comprehensive builtin lists for ALL 16 languages:

| Language | Categories |
|----------|------------|
| **Rust** | Prelude (Option, Result, Vec), macros (println!, panic!), primitives |
| **TypeScript** | Globals (console, window), constructors (Array, Object), values (undefined, null) |
| **JavaScript** | Same as TypeScript |
| **Python** | Builtins (print, len, range), values (True, False, None), exceptions |
| **Go** | Builtins (make, new, len), types (int, string), values (nil, iota) |
| **Java** | System, String, Object, primitive wrappers, common exceptions |
| **C#** | Console, String, Object, common types, LINQ |
| **C** | printf, malloc, sizeof, NULL, standard library |
| **C++** | std::cout, std::vector, nullptr, standard library |
| **Swift** | print, String, Array, Optional, nil |
| **Scala** | println, List, Option, None, common collections |
| **PHP** | echo, print, array functions, superglobals |
| **Perl** | print, say, common operators, special variables |
| **Bash** | echo, read, built-in commands, special variables |
| **Zsh** | Same as Bash plus zsh-specific |
| **Lua** | print, pairs, table, string, math |

**Key Files:**

- `tree-hugger/lib/src/builtins.rs` (NEW)
- `tree-hugger/lib/src/lib.rs` (export module)

**Acceptance Criteria:**

- [ ] `is_builtin()` returns true for standard library symbols
- [ ] All 16 languages have comprehensive builtin lists
- [ ] No false positives on common language idioms

---

## Phase 3: Semantic Lint Rules

| Property | Value |
|----------|-------|
| **Complexity** | High |
| **Dependencies** | Phases 1 and 2 |

**Objective:** Implement the three core semantic lint checks.

**Deliverables:**

1. **`undefined-symbol`** (Error severity):
   - Reference NOT in definitions, imports, or builtins → error
   - Respect namespace imports (`import * as x`)

2. **`unused-symbol`** (Warning severity):
   - Definition NOT exported AND NOT referenced → warning
   - Exclude symbols starting with `_`

3. **`unused-import`** (Warning severity):
   - Imported symbol NOT referenced → warning
   - Namespace imports unused only if never accessed

**Implementation in `tree_file.rs`:**

```rust
pub fn lint_diagnostics(&self) -> Vec<LintDiagnostic> {
    let definitions = self.symbols()?;
    let imports = self.imported_symbols()?;
    let exports = self.exported_symbols()?;
    let references = self.referenced_symbols()?;  // NEW

    let mut diagnostics = Vec::new();

    diagnostics.extend(self.check_undefined_symbols(&references, &definitions, &imports));
    diagnostics.extend(self.check_unused_symbols(&definitions, &exports, &references));
    diagnostics.extend(self.check_unused_imports(&imports, &references));
    diagnostics.extend(self.run_pattern_queries());  // Existing

    diagnostics
}
```

**Key Files:**

- `tree-hugger/lib/src/file/tree_file.rs`

**Acceptance Criteria:**

- [ ] `undefined-symbol` flags references not in scope
- [ ] `unused-symbol` flags unreferenced non-exported definitions
- [ ] `unused-import` flags unreferenced imports
- [ ] No false positives on builtins or namespace imports

---

## Phase 4: Dead Code Detection

| Property | Value |
|----------|-------|
| **Complexity** | High |
| **Dependencies** | None (parallel with Phase 3) |

**Objective:** Detect code that can never execute due to preceding unconditional exits.

**Terminal Statements by Language:**

- **Rust:** `return`, `panic!()`, `unreachable!()`, `todo!()`, `unimplemented!()`
- **JavaScript/TypeScript:** `return`, `throw`
- **Python:** `return`, `raise` (unconditional)
- **Go:** `return`, `panic()`
- **Java/C#:** `return`, `throw`

**Deliverables:**

1. Create `lib/src/dead_code.rs` module
2. Implement terminal statement detection per language
3. Find sibling statements following terminals in same block
4. Generate `dead-code` diagnostics (Warning severity)

**Key Files:**

- `tree-hugger/lib/src/dead_code.rs` (NEW)
- `tree-hugger/lib/src/file/tree_file.rs` (integrate)

**Acceptance Criteria:**

- [ ] Statements after `return` flagged as dead code
- [ ] Language-specific terminals detected (panic!, throw, raise)
- [ ] Nested blocks handled correctly
- [ ] No false positives on conditional returns

---

## Phase 5: Ignore Directives

| Property | Value |
|----------|-------|
| **Complexity** | Medium |
| **Dependencies** | Phase 3 (needs diagnostics to filter) |

**Objective:** Allow users to suppress specific warnings via comments.

**Directive Patterns:**

```rust
// tree-hugger-ignore: rule1, rule2  // Ignore specific rules on next line
// tree-hugger-ignore                 // Ignore all rules on next line
// tree-hugger-ignore-file: rule1     // Ignore rule for entire file
```

**Deliverables:**

1. Create `lib/src/ignore_directives.rs` module
2. Implement `parse_ignore_directives()` method
3. Create `IgnoreDirectives` struct tracking suppressions
4. Filter diagnostics in `lint_diagnostics()` before returning

**Key Files:**

- `tree-hugger/lib/src/ignore_directives.rs` (NEW)
- `tree-hugger/lib/src/file/tree_file.rs` (integrate)

**Acceptance Criteria:**

- [ ] Line-level ignores suppress specific rules
- [ ] File-level ignores suppress for entire file
- [ ] Bare `// tree-hugger-ignore` suppresses all rules
- [ ] Unrecognized directives are ignored (no errors)

---

## Phase 6: Enhanced Pattern Rules

| Property | Value |
|----------|-------|
| **Complexity** | Medium |
| **Dependencies** | None (parallel with Phases 3-5) |

**Objective:** Add additional pattern-based lint rules and remove noisy ones.

**New Rules to Add:**

- **Rust:** `dbg-macro` (dbg!() calls)
- **JavaScript/TypeScript:** `debugger-statement`, `eval-call`
- **Python:** `breakpoint-call`, `eval-call`, `exec-call`

**Rules to Remove (too noisy):**

- `debug-print` (all languages)
- `empty-block` (all languages)
- `todo-comment` (removed per user request)

**Deliverables:**

1. Update `lint.scm` files for affected languages
2. Update `severity_for_rule()` and `format_rule_message()` for new rules
3. Remove noisy rules from all 16 language files

**Key Files:**

- `tree-hugger/lib/queries/{lang}/lint.scm` (multiple)
- `tree-hugger/lib/src/queries/mod.rs`

**Acceptance Criteria:**

- [ ] New rules detect target patterns
- [ ] Noisy rules removed from all languages
- [ ] Severity and messages correct for new rules

---

## Phase 7: Test Fixtures

| Property | Value |
|----------|-------|
| **Complexity** | High |
| **Dependencies** | Phases 1-6 |

**Objective:** Create comprehensive test fixtures for all lint rules.

**Fixture Organization:** `tests/fixtures/lint/{rule}/{lang}_{variant}.{ext}`

**Fixtures per Rule:**

| Rule | Positive Fixtures | Negative Fixtures | Edge Cases |
|------|-------------------|-------------------|------------|
| `undefined-symbol` | Reference to unknown | All refs defined | Builtins, namespace imports |
| `unused-symbol` | Unreferenced private | Referenced or exported | `_` prefix exclusion |
| `unused-import` | Unreferenced import | Used import | Namespace import usage |
| `dead-code` | Code after return | No unreachable code | Conditional returns |
| `unwrap-call` | `.unwrap()` calls | `.unwrap_or()` | Chained unwraps |
| `expect-call` | `.expect()` calls | Pattern matching | - |
| `dbg-macro` | `dbg!()` calls | Other macros | - |
| `eval-call` | `eval()` calls | Other functions | - |
| `debugger-statement` | `debugger;` | Other statements | - |

**Key Files:**

- `tree-hugger/lib/tests/fixtures/lint/` (new structure)
- `tree-hugger/lib/tests/lint_diagnostics.rs`

**Acceptance Criteria:**

- [ ] Every rule has positive and negative fixtures
- [ ] All 16 languages have coverage for applicable rules
- [ ] Edge cases tested for semantic rules
- [ ] SourceContext accuracy verified

---

## Phase 8: CLI and Documentation

| Property | Value |
|----------|-------|
| **Complexity** | Low |
| **Dependencies** | Phases 1-7 |

**Objective:** Update CLI output and documentation.

**Deliverables:**

1. Update CLI lint output to show semantic vs pattern rules
2. Update README with new rule descriptions
3. Add rule severity documentation
4. Document ignore directive syntax

**Key Files:**

- `tree-hugger/cli/src/main.rs`
- `tree-hugger/lib/README.md`

**Acceptance Criteria:**

- [ ] CLI shows all diagnostic types clearly
- [ ] README documents all rules with examples
- [ ] Ignore directive syntax documented

---

## Phase Dependencies

```
Phase 1 (References) ──────┬──► Phase 3 (Semantic Rules) ──► Phase 5 (Ignore) ──┐
                           │                                                     │
Phase 2 (Builtins) ────────┘                                                     ├──► Phase 7 (Fixtures)
                                                                                 │
Phase 4 (Dead Code) ───────────────────────────────────────────────────────────┤
                                                                                 │
Phase 6 (Pattern Rules) ────────────────────────────────────────────────────────┘
                                                                                 │
                                                                                 ▼
                                                                          Phase 8 (Docs)
```

**Parallel Execution:**

- Phases 1+2 in parallel
- Phases 4+6 parallel with Phase 3
- Phase 7 requires all implementation phases

---

## Summary

| Phase | Description | Complexity | Est. Hours |
|-------|-------------|------------|------------|
| 1 | Reference Tracking (16 langs) | High | 4-5 |
| 2 | Language Builtins (16 langs) | High | 4-5 |
| 3 | Semantic Lint Rules | High | 3-4 |
| 4 | Dead Code Detection | High | 2-3 |
| 5 | Ignore Directives | Medium | 1-2 |
| 6 | Enhanced Pattern Rules | Medium | 1-2 |
| 7 | Test Fixtures | High | 4-5 |
| 8 | CLI and Docs | Low | 1 |
| **Total** | | | **20-27** |

**Semantic Rules (new):**

- `undefined-symbol` - Reference not in definitions/imports/builtins
- `unused-symbol` - Definition not exported and not referenced
- `unused-import` - Import never used
- `dead-code` - Statements after unconditional exits

**Pattern Rules:**

- Rust: `unwrap-call`, `expect-call`, `dbg-macro`
- JS/TS: `eval-call`, `debugger-statement`
- Python: `breakpoint-call`, `eval-call`, `exec-call`

**Rules Removed:**

- `todo-comment` (per user request)
- `debug-print` (too noisy)
- `empty-block` (too noisy)

**Language Coverage:** All 16 languages get comprehensive reference tracking and builtin lists
