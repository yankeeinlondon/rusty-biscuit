# Restructuring Plan - 2025-12-28

This plan restructures the Dockhand monorepo to focus exclusively on "research" functionality, establishing a clear area-based architecture for future expansion.

---

## Phase 1: Changing Focus

**Goal:** Transform the project from a multi-purpose CLI to a research-focused toolset by restructuring modules into a `/research` area.

### 1.1 Move Library Module (`/lib` → `/research/lib`)

**Current state:**
- Location: `/lib`
- Package name: `dockhand-lib`
- Library crate: `dockhand_lib`
- Binary: `dockhand-dev` (development binary)

**Actions:**
1. Create `/research` directory
2. Move `/lib` to `/research/lib`
3. Update package name in `Cargo.toml`: `dockhand-lib` → `research-lib`
4. Update library crate name: `dockhand_lib` → `research_lib`
5. Update binary name: `dockhand-dev` → `research-dev` (if keeping dev binary)
6. Update all internal references

**Files to modify:**
- `/research/lib/Cargo.toml` - package name, lib name, bin name
- `/research/lib/src/lib.rs` - module documentation
- `/research/lib/src/main.rs` - any references

### 1.2 Move CLI Module (`/cli` → `/research/cli`)

**Current state:**
- Location: `/cli`
- Package name: `deckhand-cli`
- Binary: `deck`
- Command: `research` (subcommand)
- Dependency: `dockhand-lib`

**Actions:**
1. Move `/cli` to `/research/cli`
2. Update package name: `deckhand-cli` → `research-cli`
3. Update binary name: `deck` → `research`
4. Rename `Research` command to `Library` command
5. Update command documentation to reflect "library research"
6. Update dependency path: `../lib` → `../lib` (same relative path after move)
7. Update dependency name: `dockhand-lib` → `research-lib`

**Files to modify:**
- `/research/cli/Cargo.toml` - package name, binary name, dependency
- `/research/cli/src/main.rs` - command struct, imports, documentation

### 1.3 Move and Adapt justfile

**Current state:**
- Location: `/justfile`
- Targets: `default`, `build`, `test`, `install`, `cli`
- References: `deckhand-cli`

**Actions:**
1. Move `/justfile` to `/research/justfile`
2. Update references from `deckhand-cli` to `research-cli`
3. Update output messages to say "Research" instead of "Deckhand"
4. Update `cli` target to run `cargo run -p research-cli`
5. Update paths to be relative to `/research`

**New `/research/justfile` targets:**
- `default` - list available commands
- `build` - build research modules (cli, lib)
- `test` - test research modules
- `install` - install the `research` binary
- `cli` - run the debug CLI

### 1.4 Create New Root justfile

**Goal:** Delegate to area-specific justfiles with fallback messaging for missing targets.

**Actions:**
1. Create new `/justfile`
2. Implement `build`, `test`, `install` targets that:
   - Scan for area directories (currently just `/research`)
   - Check if each area has the corresponding target
   - Execute if present, log warning to STDERR if absent

**New `/justfile` structure:**
```just
# build - delegates to areas
build:
    @for area in research; do \
        if just -f "$area/justfile" --summary 2>/dev/null | grep -q "build"; then \
            just -f "$area/justfile" build; \
        else \
            echo "- no **build** command for the area **$area**" >&2; \
        fi \
    done

# Similar for test, install
```

### 1.5 Update Root Cargo.toml

**Current state:**
```toml
[workspace]
resolver = "2"
members = ["cli", "lib", "tui"]
```

**Actions:**
1. Update members to new paths: `["research/cli", "research/lib", "tui"]`

### 1.6 Update Documentation

**Files to update:**
- `/README.md` - Update module descriptions, paths, and terminology
- `/docs/system-prompt.md` - Update if it references old paths
- Any `CLAUDE.md` files if they exist

**Documentation changes:**
- Replace "Deckhand" with "Research" where appropriate
- Update path references from `/lib`, `/cli` to `/research/lib`, `/research/cli`
- Refer to modules as "Research Library" and "Research CLI"
- Update binary name from `deck` to `research`
- Update subcommand from `research` to `library`

---

## Phase 2: Adding a "Shared" Area

**Goal:** Create a shared utility library for cross-area functionality.

### 2.1 Initialize Shared Library

**Actions:**
1. Create `/shared` directory
2. Create `/shared/Cargo.toml`:
   ```toml
   [package]
   name = "shared"
   version = "0.1.0"
   edition = "2024"

   [lib]
   name = "shared"
   path = "src/lib.rs"
   ```
3. Create `/shared/src/lib.rs` with placeholder content
4. Create `/shared/src/mod.rs` if needed for module organization

### 2.2 Create Shared justfile

**Actions:**
1. Create `/shared/justfile` with targets:
   - `build` - build the shared library
   - `test` - run shared library tests

### 2.3 Update Root Cargo.toml

**Actions:**
1. Add `shared` to workspace members:
   ```toml
   members = ["research/cli", "research/lib", "tui", "shared"]
   ```

### 2.4 Update Root justfile

**Actions:**
1. Add `shared` to the list of areas to scan

### 2.5 Update Documentation

**Actions:**
1. Update `/README.md` to include Shared Library section
2. Document the shared library purpose and future intent

---

## Phase 3: Research Improvements (FUTURE - Requires User Clarification)

**Note:** This phase will NOT be executed until explicitly requested. Several areas require user clarification before implementation.

### 3.1 Change Research Output Location

**Current:** `research/${library_name}` (relative to CWD)
**New:** `${RESEARCH_DIR:-$HOME}/.research/library/${library_name}`

**Questions to clarify:**
- Should `RESEARCH_DIR` point to the parent of `.research` or replace the entire path?
- How should we handle the `.research` directory structure for other future research types?

### 3.2 Research Metadata (`metadata.json`)

**Structure:**
```rust
struct ResearchMetadata {
    kind: ResearchKind,
    additional_files: HashMap<String, String>, // filename -> prompt
}

enum ResearchKind {
    Library,
    // Future: Software, Standard, Company, etc.
}
```

**Questions to clarify:**
- Should metadata include timestamps, versions, or other tracking info?
- Should we store the library info (package manager, language) in metadata?

### 3.3 DRY Research Implementation

**Flow:**
1. Check if research exists for the library
2. If no existing research: run normal process
3. If existing research exists:
   - If user provided additional prompts:
     - Use Gemini 3 Flash to check overlap via `PromptOverlap` structure
     - If all new: add underlying docs, regenerate synthesis
     - If overlapping: interactive prompt for user to select which to include

**Questions to clarify:**
- What's the exact format for `PromptOverlap` response from Gemini?
- How should filenames be generated for additional prompts? (slugify? hash? numbered?)
- Should we also track when research was last updated?
- What happens if metadata.json is missing but research files exist?

### 3.4 Add Changelog Prompt (New Underlying Research)

**Purpose:** Add a new default prompt for library research that generates a comprehensive major-version change history document.

#### 3.4.1 Create Prompt Template

**File:** `/research/lib/prompts/changelog.md`

**Output:** `changelog.md` in research output directory

**Model:** OpenAI GPT-5.2 (stronger model required for repository analysis depth)

**Prompt content:**

```markdown
# Major-Version Change History for {{topic}}

You are a senior software release historian and technical writer. Your job is to reconstruct and document this library's change history at major-version granularity (SemVer: MAJOR.MINOR.PATCH, focusing primarily on MAJOR transitions, e.g., 1.x → 2.0, 2.x → 3.0).

You must base conclusions on evidence from the repository and/or hosting provider, and you must explicitly cite what you used for each major version summary (file path, tag name, release note, PR number, commit range, etc.). If you cannot find evidence, state that clearly and provide the best-supported inference you can, labeled as inference.

## Output requirements

Produce a Major Version Change History document with these sections:

### 1. Repository Overview
- What the project is (1–3 sentences)
- Versioning scheme observed (SemVer? date-based? mixed?)
- Evidence sources consulted (bullet list)

### 2. Major Version Timeline
A table: Major Version | Release Date (if known) | Evidence (tags/releases/commits) | Summary

### 3. Per-Major-Version Notes (repeat for each major version)
- What changed (executive summary) (3–8 bullets)
- Breaking changes (explicit, separate bullets)
- New capabilities (user-facing features)
- Notable deprecations/removals
- Migration notes (what a downstream user must do)
- Primary evidence (links/refs: changelog headings, release notes, PRs, commits, docs)

### 4. Confidence & Gaps
- Identify versions where evidence is weak or conflicting
- State what additional data would improve accuracy

## Major-version identification rules

Use the following precedence order:

1. **Authoritative sources:** CHANGELOG.md, Releases page, Git tags (v2.0.0), Package manifests
2. **Fallback sources:** PR titles/labels, Milestones, Commit messages (Conventional Commits), Docs changes, API surface diffs

## Evidence collection techniques

Apply as many as feasible:

**A) Repository files:** CHANGELOG.md, RELEASE_NOTES.md, HISTORY.md, /docs/, /migrations/, version declarations in manifests

**B) Provider API:** Releases, Tags, PRs between boundaries, Milestones

**C) Git history:** Identify boundary commits, compute change-sets, distill noise (de-emphasize deps, collapse repetitive commits)

**D) Heuristics for material changes:**
- Public API changes (exports, CLI flags, config formats)
- Runtime/platform support changes
- Data format changes
- Behavior changes that break assumptions
- Security/auth model changes
- Build/distribution changes

## Distillation method

1. **Extract:** Gather raw notes from files, releases, PR titles, commits
2. **Cluster:** Group into themes (API, CLI, config, performance, security, docs, tooling)
3. **Rank:** Select 5–12 most material changes (user impact)
4. **Validate:** Cross-check against at least two evidence sources
5. **Write:** Produce concise bullets with consistent verbs

## Style rules

- Write for experienced developers
- Prefer concrete statements: "Renamed CLI flag --foo → --bar (breaking)"
- Every section must include at least one evidence reference
- Prefix inferred statements with "Inference: …"
- Be neutral; do not oversell
```

#### 3.4.2 Implementation Changes

**Files to modify:**

1. `/research/lib/src/lib.rs`:
   - Add `CHANGELOG` constant to `prompts` module
   - Add changelog task to Phase 1 parallel execution
   - Use `openai.completion_model("gpt-5.2")` for this task (not Gemini)
   - Total Phase 1 tasks increases from 4 to 5 (plus user questions)

2. `/research/lib/prompts/changelog.md`:
   - Create new prompt template file (content above)

**Model selection rationale:**
- Changelog analysis requires deep reasoning about repository structure
- Must correlate multiple evidence sources (tags, releases, commits, changelogs)
- GPT-5.2 provides better structured output for complex historical analysis
- Worth the latency/cost trade-off for accuracy

#### 3.4.3 Update Existing Docs

Update the architecture.md template and README.md to reflect:
- New `changelog.md` output file
- Updated prompt templates table (9 templates now)
- Updated Phase 1 task count (5 default + N questions)

---

### 3.5 Documentation Updates

Phase 3 requires comprehensive documentation updates to reflect the new research architecture.

#### 3.5.1 Update `/README.md` (Root)

**Changes required:**
- Add section on research output location configuration (`RESEARCH_DIR` environment variable)
- Update "Library Research Flow" diagram to show the two-phase pipeline
- Add metadata system overview
- Document the DRY behavior (incremental research)

#### 3.5.2 Update `/research/README.md`

**Current state:** Incomplete draft with placeholder sections (a, b, c, d)

**Actions:**
1. Complete the "Underlying Research" section with all prompt types:
   - `overview.md` - Comprehensive library overview
   - `similar_libraries.md` - Alternative libraries and comparisons
   - `integration_partners.md` - Commonly paired libraries
   - `use_cases.md` - Common use cases and patterns
   - `changelog.md` - Major-version change history (uses GPT-5.2)
   - `question_N.md` - Additional user-provided prompts
2. Complete the "Summary Deliverables" section:
   - `skill/SKILL.md` - Claude Code skill entry point
   - `skill/*.md` - Supporting skill documents
   - `deep_dive.md` - Dense comprehensive reference
3. Add "Configuration" section:
   - `RESEARCH_DIR` environment variable
   - Default output location: `$HOME/.research/library/<pkg>`
4. Add "Metadata" section:
   - `metadata.json` structure and purpose
   - How additional prompts are tracked
5. Add "Incremental Research" section:
   - DRY behavior explanation
   - Overlap detection process
   - Interactive prompt selection
6. Link to `/research/docs/architecture.md` for detailed internals

#### 3.5.3 Create `/research/docs/architecture.md`

**Purpose:** Comprehensive technical documentation of the research system architecture.

**Document structure:**

```markdown
# Research Architecture

## Overview
Brief description of the research system's purpose and design philosophy.

## Two-Phase Research Pipeline

### Phase 1: Underlying Research
- Parallel LLM calls to gather raw research
- Prompt templates used (overview, similar_libraries, etc.)
- Additional user prompts handling
- Package manager detection and library identification

### Phase 2: Synthesis
- Context aggregation from Phase 1 outputs
- Skill generation (multi-file output parsing)
- Deep dive document generation

## LLM Provider Strategy

### Provider Configuration
- OpenAI GPT-5.2 (synthesis + changelog)
- Google Gemini gemini-3-flash-preview (Phase 1 parallel research)
- ZAI/GLM GLM-4-7 (overview)

### Model Selection Rationale
- Fast models (Gemini Flash) for parallel Phase 1 research where speed matters
- Stronger models (GPT-5.2) for:
  - Phase 2 synthesis (skill generation, deep dive)
  - Changelog analysis (requires deep reasoning about repository history)

## Package Manager Detection

### Supported Package Managers
- crates.io (Rust)
- npm (JavaScript/TypeScript)
- PyPI (Python)
- Packagist (PHP)
- LuaRocks (Lua)
- pkg.go.dev (Go)

### Detection Flow
- Concurrent API calls to all package managers
- Interactive selection if multiple matches
- Graceful fallback to "general topic" mode

## Prompt Templates

### Location
`/research/lib/prompts/*.md`

### Template Variables
- `{{topic}}` - Library/topic name
- `{{context}}` - Aggregated Phase 1 content
- `{{question}}` - User-provided additional question

### Templates
| File | Purpose | Phase | Model |
|------|---------|-------|-------|
| `overview.md` | Comprehensive library analysis | 1 | GLM-4-7 |
| `similar_libraries.md` | Alternatives and comparisons | 1 | Gemini Flash |
| `integration_partners.md` | Ecosystem libraries | 1 | Gemini Flash |
| `use_cases.md` | Common patterns and examples | 1 | Gemini Flash |
| `changelog.md` | Major-version change history | 1 | GPT-5.2 |
| `additional_question.md` | User-defined research | 1 | Gemini Flash |
| `context.md` | Phase 1 aggregation template | 2 | (template only) |
| `skill.md` | Claude Code skill generation | 2 | GPT-5.2 |
| `deep_dive.md` | Dense reference document | 2 | GPT-5.2 |

## Output Structure

### Directory Layout
```
$RESEARCH_DIR/.research/library/<pkg>/
├── metadata.json           # Research metadata
├── overview.md             # Phase 1: Library overview
├── similar_libraries.md    # Phase 1: Alternatives
├── integration_partners.md # Phase 1: Ecosystem
├── use_cases.md            # Phase 1: Patterns
├── changelog.md            # Phase 1: Major-version history
├── question_1.md           # Phase 1: Additional (optional)
├── question_N.md           # Phase 1: Additional (optional)
├── deep_dive.md            # Phase 2: Dense reference
└── skill/
    ├── SKILL.md            # Phase 2: Skill entry point
    └── *.md                # Phase 2: Supporting docs
```

### Metadata Schema
```json
{
  "kind": "library",
  "library_info": {
    "package_manager": "crates.io",
    "language": "Rust",
    "url": "https://crates.io/crates/<pkg>"
  },
  "additional_files": {
    "question_1.md": "How does it compare to X?",
    "question_2.md": "What are the performance characteristics?"
  },
  "created_at": "2025-12-28T10:00:00Z",
  "updated_at": "2025-12-28T10:00:00Z"
}
```

## Incremental Research (DRY)

### Existence Check
- Check `$RESEARCH_DIR/.research/library/<pkg>/metadata.json`
- If missing: full research pipeline
- If present: incremental mode

### Overlap Detection
- Use Gemini 3 Flash for semantic comparison
- Compare new prompts against existing underlying documents
- Return `PromptOverlap` structure for each prompt

### PromptOverlap Structure
```rust
struct PromptOverlap {
    prompt: String,
    filename: String,
    verdict: OverlapVerdict,
    conflict: Option<String>, // Conflicting file if overlap
}

enum OverlapVerdict {
    New,      // No overlap, proceed
    Conflict, // Potential overlap with existing doc
}
```

### Interactive Selection
- Single prompt with conflict: confirmation dialog
- Multiple prompts: multi-select with defaults
  - New prompts: selected by default
  - Conflicting prompts: unselected by default

### Regeneration
- Add new underlying documents
- Re-run Phase 2 synthesis with expanded corpus

## Markdown Normalization

### Purpose
Consistent formatting regardless of LLM output style.

### Implementation
- Parse with `pulldown-cmark` (CommonMark + extensions)
- Filter empty anchor tags
- Re-serialize with `pulldown-cmark-to-cmark`

## Cancellation Handling

### SIGINT Behavior
- Immediate exit on Ctrl+C
- Partial results are preserved (completed Phase 1 docs)
- TTS announcement skipped on cancellation

## Text-to-Speech Notification

### Completion Announcement
- Uses system TTS via `tts` crate
- Filters for English, non-compact voices
- Message: "Research for the {topic} library has completed"
```

---

## Execution Order

### Phase 1 (Execute Now)
1. Create `/research` directory
2. Move `/lib` to `/research/lib`
3. Move `/cli` to `/research/cli`
4. Update `/research/lib/Cargo.toml`
5. Update `/research/lib/src/lib.rs` and `main.rs`
6. Update `/research/cli/Cargo.toml`
7. Update `/research/cli/src/main.rs`
8. Move `/justfile` to `/research/justfile`
9. Update `/research/justfile`
10. Create new `/justfile`
11. Update root `/Cargo.toml`
12. Update `/README.md`
13. Verify build and test pass

### Phase 2 (Execute After Phase 1)
1. Create `/shared/Cargo.toml`
2. Create `/shared/src/lib.rs`
3. Create `/shared/justfile`
4. Update root `/Cargo.toml` to include shared
5. Update root `/justfile` to include shared area
6. Update `/README.md`
7. Verify build passes

### Phase 3 (Requires User Approval - DO NOT EXECUTE)

**Prerequisites:**
- Wait for user clarification on open questions (see 3.1-3.3)
- Wait for explicit request to proceed

**Execution steps:**

#### 3a. Documentation (can be done early)
1. Create `/research/docs/` directory
2. Create `/research/docs/architecture.md` with full architecture documentation
3. Update `/research/README.md` - complete all placeholder sections
4. Update `/README.md` - add Phase 3 features documentation

#### 3b. Add Changelog Prompt
5. Create `/research/lib/prompts/changelog.md` with prompt template
6. Add `CHANGELOG` constant to `prompts` module in `lib.rs`
7. Add changelog task to Phase 1 parallel execution
8. Use `openai.completion_model("gpt-5.2")` for changelog (not Gemini)
9. Update total Phase 1 task count (5 default + N questions)

#### 3c. Output Location Change
10. Update `default_output_dir()` in `/research/lib/src/lib.rs`
11. Add `RESEARCH_DIR` environment variable support
12. Update output path logic: `${RESEARCH_DIR:-$HOME}/.research/library/<pkg>`

#### 3d. Metadata System
13. Define `ResearchMetadata` struct in `/research/lib/src/lib.rs`
14. Define `ResearchKind` enum
15. Implement `metadata.json` writing after research completion
16. Store library info (package_manager, language, url)
17. Store additional_files mapping (filename → prompt)
18. Add timestamps (created_at, updated_at)

#### 3e. DRY Research Implementation
19. Implement existence check for `metadata.json`
20. Define `PromptOverlap` struct
21. Implement Gemini-based overlap detection
22. Implement interactive prompt selection (using `inquire`)
    - Single conflict: confirmation dialog
    - Multiple conflicts: multi-select
23. Implement incremental document addition
24. Implement Phase 2 re-synthesis with expanded corpus

#### 3f. Verification
25. Test full research flow (new library)
26. Test incremental research (existing library + new prompts)
27. Test overlap detection and interactive selection
28. Verify metadata.json correctness
29. Verify changelog.md generation with GPT-5.2
30. Update documentation if behavior differs from spec
