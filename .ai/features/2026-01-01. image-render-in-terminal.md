# Image Render in Terminal

Currently we display the `alt text` for an image when we encounter it in the terminal. The goal for this phase is to improve the experience for terminals which support the Kitty graphics terminal.

## Using the `viuer` crate

We will use the `viuer` crate to render images in the terminal.

## To Render or not to Render

We will test that the given console can support the Kitty graphics protocol:

- if they support Kitty then we will render the image
- if they can not then we will display:

    `▉ IMAGE[${alt_text}]`



## Example 1

Based on the search results, here's a comprehensive example showing how to integrate `viuer` with Kitty graphics protocol support into a markdown rendering pipeline using `pulldown_cmark` and `terminal_size`:

### Cargo.toml

```toml
[dependencies]
# Markdown parsing
pulldown-cmark = "0.9"
# Terminal size detection
terminal_size = "0.3"
# Image rendering in terminal
viuer = { version = "0.9", features = ["print-file"] }
# For image handling
image = "0.24"
```

### Integration Example

```rust
use pulldown_cmark::{Event, Parser, Tag, TagEnd};
use terminal_size::{terminal_size, Width, Height};
use viuer::{print_from_file, Config};
use std::path::{Path, PathBuf};

struct MarkdownRenderer {
    terminal_width: u16,
    terminal_height: u16,
    base_path: PathBuf,
}

impl MarkdownRenderer {
    fn new() -> Self {
        let (width, height) = match terminal_size() {
            Some((Width(w), Height(h))) => (w, h),
            None => (80, 24), // Fallback to standard terminal size
        };
        
        Self {
            terminal_width: width,
            terminal_height: height,
            base_path: std::env::current_dir().unwrap(),
        }
    }
    
    fn render_markdown(&self, markdown: &str) {
        let parser = Parser::new(markdown);
        let mut in_code_block = false;
        
        for event in parser {
            match event {
                Event::Start(Tag::Image { dest_url, .. }) => {
                    // Detect and render image with Kitty protocol if supported
                    self.render_image(&dest_url);
                }
                Event::Text(text) if !in_code_block => {
                    print!("{}", text);
                }
                Event::Code(code) => {
                    println!("`{}`", code);
                }
                Event::Start(Tag::CodeBlock(_)) => {
                    in_code_block = true;
                    println!("```");
                }
                Event::End(TagEnd::CodeBlock) => {
                    in_code_block = false;
                    println!("```");
                }
                Event::Rule => {
                    println!("{}", "─".repeat(self.terminal_width as usize));
                }
                _ => {}
            }
        }
    }
    
    fn render_image(&self, image_path: &str) {
        // Resolve relative paths
        let full_path = if Path::new(image_path).is_absolute() {
            PathBuf::from(image_path)
        } else {
            self.base_path.join(image_path)
        };
        
        if !full_path.exists() {
            eprintln!("Error: Image not found: {}", full_path.display());
            return;
        }
        
        // Configure viuer for Kitty graphics protocol
        let config = Config {
            // Use terminal width minus some padding
            width: Some((self.terminal_width - 4) as u32),
            // Maintain aspect ratio by not setting height
            height: None,
            // Start from current cursor position
            x: 0,
            y: 0,
            // Kitty-specific: Use absolute positioning
            absolute_offset: false,
            // Enable transparency support
            transparent: true,
            ..Default::default()
        };
        
        // Viuer automatically detects Kitty support and uses the graphics protocol
        // If Kitty is not available, it falls back to block characters
        match print_from_file(&full_path, &config) {
            Ok(_) => println!(), // Add newline after image
            Err(e) => eprintln!("Failed to render image: {}", e),
        }
    }
}

fn main() {
    let renderer = MarkdownRenderer::new();
    
    let markdown_content = r#"
# My Document

Here is an image:

![Example](assets/screenshot.png)

And some text after the image.
"#;
    
    renderer.render_markdown(markdown_content);
}
```

### Key Integration Points

1. **Terminal Size Detection**: The `terminal_size` crate  provides the actual terminal dimensions, which `viuer` uses to scale images appropriately.

2. **Kitty Protocol Auto-Detection**: `viuer` automatically detects if the terminal supports the Kitty graphics protocol  and uses it when available. No manual protocol implementation is needed.

3. **Image Configuration**: The `Config` struct  allows precise control over:
   - Dimensions (fitting to terminal width)
   - Positioning (relative to cursor)
   - Transparency support
   - Aspect ratio preservation

4. **Protocol Fallback**: If Kitty graphics aren't supported, `viuer` automatically falls back to Unicode half-block characters , ensuring compatibility across terminals.

5. **Markdown Integration**: The renderer hooks into `pulldown_cmark`'s `Event::Start(Tag::Image)` events to intercept image references and render them using `viuer`.

This approach gives you high-resolution image rendering in Kitty terminals while maintaining compatibility with other terminals through automatic fallback.


## Example 2



Integrating `viuer` into a Markdown rendering pipeline requires intercepting the parsing stream before the text renderer (`two-face` or `syntect`) prints the alt-text of the image.

Since `two-face` is a high-level wrapper, you typically need to drop down to the `pulldown_cmark` event loop to handle images (binary data) separately from text (ANSI strings).

Here is a conceptual example showing how to:

1. Iterate over `pulldown_cmark` events.
2. Detect `Image` tags.
3. Use `terminal_size` to configure `viuer`.
4. Render images with `viuer` (handling the Kitty protocol automatically).
5. Delegate text rendering to your existing stack (simulated here).

### Dependencies
Ensure your `Cargo.toml` includes:

```toml
[dependencies]
pulldown-cmark = "0.9"
viuer = "0.7"
terminal_size = "0.3"
# syntect and two-face are assumed to be part of your existing text stack
```

### Code Example

```rust
use pulldown_cmark::{Event, Parser, Tag, TagEnd};
use terminal_size::{Height, Width, terminal_size};
use viuer::{Config, print_from_file, KittySupport};
use std::path::Path;
use std::io::{self, Write};

fn main() -> io::Result<()> {
    // 1. Sample Markdown Content
    let markdown_content = r#"
# Image Rendering Test

Here is some text before the image.

![Alt text goes here](./examples/koyamin.jpg){width=40%}

And here is some text after the image.
"#;

    // 2. Setup Terminal Width for Viuer
    // We default to 80 if we can't detect the size.
    let term_size = terminal_size();
    let columns: u32 = term_size.map(|(Width(w), _)| w).unwrap_or(80) as u32;

    // 3. Configure Viuer
    // viuer auto-detects terminal support (Kitty, iTerm2, Sixel, or Block fallback).
    // We can enable transparency or specific Kitty modes here.
    let config = Config {
        width: Some(columns),
        // It is often good to limit height relative to terminal height
        height: Some(term_size.map(|(_, Height(h))| h).unwrap_or(24) as u32), 
        x: 0,
        y: 0,
        // If you specifically want to force Kitty protocol or check for it:
        // kitty_support: KittySupport::Detect, // This is the default
        ..Default::default()
    };

    // 4. Parse Markdown
    let parser = Parser::new(markdown_content);

    // We need a state to track if we are currently inside an image tag.
    // This is because pulldown-cmark emits: Start(Image) -> Text(Alt) -> End(Image).
    // We want to print the graphic, but SKIP the alt text printing.
    let mut in_image_tag = false;

    for event in parser {
        match event {
            // -- Image Handling --
            Event::Start(Tag::Image(link_type, dest, title)) => {
                in_image_tag = true;

                // 'dest' contains the path or URL.
                // Note: Markdown often uses URLs. Viuer handles local files best. 
                // You might need to download URLs to a temp file here first.
                let path = dest.as_ref();

                // Basic check if it's a local file
                if Path::new(path).exists() {
                    // 5. Render Image using Viuer
                    // This prints the binary escape codes directly to stdout.
                    if let Err(e) = print_from_file(path, &config) {
                        eprintln!("\n[Failed to render image '{}': {}]", path, e);
                        // If viuer fails, we might want to fallback to printing text
                        // by setting in_image_tag = false here.
                    }
                    println!(); // Add a newline after the image
                } else {
                    // If file doesn't exist or is a URL, we fallback to text link
                    println!("\n[Image: {}]", path);
                    // We keep in_image_tag = true to suppress the redundant alt text 
                    // from the subsequent Text event, OR set to false if we want it.
                    // Let's suppress alt text since we printed the path.
                }
            }
            Event::End(TagEnd::Image) => {
                in_image_tag = false;
            }

            // -- Text Rendering --
            Event::Text(text) => {
                // Only print text if we are not inside an image tag (suppressing alt text)
                if !in_image_tag {
                    // Here is where you would pass `text` to two-face / syntect
                    // For this example, we just print raw text.
                    print!("{}", text);
                    io::stdout().flush()?;
                }
            }
            
            // -- Handling Other Events (Headings, Code blocks, etc.) --
            Event::Start(tag) => {
                // You need to handle other tags to format output correctly
                // (e.g., adding newlines for headers)
                match tag {
                    Tag::Heading { .. } => print!("\n\n# "),
                    Tag::Paragraph => println!(),
                    Tag::CodeBlock(_) => print!("```\n"),
                    _ => {}
                }
            }
            Event::End(tag_end) => {
                match tag_end {
                    TagEnd::Heading(_) => println!(),
                    TagEnd::Paragraph => println!(),
                    TagEnd::CodeBlock => println!("```"),
                    _ => {}
                }
            }
            Event::Code(code) => {
                // Pass code to syntect for highlighting
                println!("Highlighted Code: {}", code);
            }
            _ => {}
        }
    }

    Ok(())
}
```

### Key Integration Details

1. **Event Filtering**: The critical logic is `in_image_tag`. Markdown parsers emit `Start(Image)`, then `Text(Alt Text)`, then `End(Image)`. If you send the alt text to `two-face`, it will print `Alt Text` right after your beautiful image. You must suppress the `Event::Text` if `in_image_tag` is true.
2. **Viuer Configuration**: `viuer` defaults to `KittySupport::Detect`. If the `$TERM` program supports Kitty graphics, it will send the necessary escape codes. If not, it will gracefully fallback to half-blocks or other modes.
3. **Buffering**: If you are using `two-face` to render entire chunks of HTML/Markdown to a `String` before printing, you will need to change your architecture. `viuer` writes directly to the terminal/stdout (via ANSI escape codes), while `two-face` produces a String. You must iterate the events, write the image immediately to `stdout`, and collect the text events into a buffer (or print them immediately) to ensure the image appears in the correct vertical position relative to the text.
4. **URL Handling**: Markdown usually contains URLs (`https://...`). `viuer` does not fetch URLs automatically. In the `Start(Tag::Image ...)` match block, you should check if `dest` is a URL. If it is, you need to use `reqwest` to download the bytes into a `Cursor` and use `viuer::print` (which accepts `DynamicImage` or bytes) instead of `print_from_file`.
