# Image Render in Terminal

Currently we display `alt text` for images in terminal output. This feature adds native image rendering for terminals supporting the Kitty graphics protocol.

## Implementation

**Crate**: `viuer` (handles Kitty/iTerm2/Sixel detection and rendering)

**Detection**: Use `viuer::get_kitty_support()` which returns:
- `KittySupport::Local` — Kitty running locally (can share files)
- `KittySupport::Remote` — Kitty via SSH (uses escape codes)
- `KittySupport::None` — Not supported

**Behavior**:
- Kitty supported → render image via `print_from_file()`
- Kitty unsupported → display `▉ IMAGE[${alt_text}]`

## Example 1: Basic Integration

A concise example showing `viuer` integration with `pulldown_cmark`:

### Cargo.toml

```toml
[dependencies]
pulldown-cmark = "0.13"
viuer = { version = "0.9", features = ["print-file"] }
```

### Code

```rust
use pulldown_cmark::{Event, Parser, Tag, TagEnd};
use viuer::{get_kitty_support, print_from_file, terminal_size, Config, KittySupport};
use std::path::{Path, PathBuf};

struct MarkdownRenderer {
    terminal_width: u16,
    base_path: PathBuf,
    kitty_supported: bool,
}

impl MarkdownRenderer {
    fn new() -> Self {
        let (width, _) = terminal_size().unwrap_or((80, 24));
        let kitty_supported = matches!(
            get_kitty_support(),
            KittySupport::Local | KittySupport::Remote
        );

        Self {
            terminal_width: width,
            base_path: std::env::current_dir().unwrap_or_default(),
            kitty_supported,
        }
    }

    fn render_markdown(&self, markdown: &str) {
        let parser = Parser::new(markdown);
        let mut in_image = false;
        let mut current_alt = String::new();
        let mut current_path = String::new();

        for event in parser {
            match event {
                Event::Start(Tag::Image { dest_url, .. }) => {
                    in_image = true;
                    current_alt.clear();
                    current_path = dest_url.to_string();
                }
                Event::Text(text) if in_image => {
                    current_alt.push_str(&text);
                }
                Event::End(TagEnd::Image) => {
                    self.render_image(&current_path, &current_alt);
                    in_image = false;
                }
                Event::Text(text) => print!("{}", text),
                _ => {}
            }
        }
    }

    fn render_image(&self, image_path: &str, alt_text: &str) {
        let full_path = if Path::new(image_path).is_absolute() {
            PathBuf::from(image_path)
        } else {
            self.base_path.join(image_path)
        };

        // Fallback if Kitty unsupported or file missing
        if !self.kitty_supported || !full_path.exists() {
            println!("▉ IMAGE[{}]", alt_text);
            return;
        }

        let config = Config {
            width: Some((self.terminal_width.saturating_sub(4)) as u32),
            transparent: true,
            ..Default::default()
        };

        if print_from_file(&full_path, &config).is_ok() {
            println!();
        } else {
            println!("▉ IMAGE[{}]", alt_text);
        }
    }
}
```

### Key Points

1. **Explicit Kitty Detection**: Use `get_kitty_support()` to check for `KittySupport::Local` or `KittySupport::Remote` before attempting graphics rendering.

2. **Custom Fallback**: When Kitty is unsupported, display `▉ IMAGE[alt_text]` instead of relying on viuer's block character fallback.

3. **Alt Text Handling**: The parser emits `Start(Image)` → `Text(alt)` → `End(Image)`. Capture alt text during the `Text` event while `in_image` is true.

4. **Terminal Size**: `viuer::terminal_size()` provides dimensions—no need for the separate `terminal_size` crate.

## Example 2: Integration with two-face/syntect

When using `two-face` or `syntect` for syntax highlighting, you must intercept images at the `pulldown_cmark` event level before text reaches the highlighter.

### Cargo.toml

```toml
[dependencies]
pulldown-cmark = "0.13"
viuer = { version = "0.9", features = ["print-file"] }
```

### Code

```rust
use pulldown_cmark::{Event, Parser, Tag, TagEnd};
use viuer::{get_kitty_support, print_from_file, terminal_size, Config, KittySupport};
use std::path::Path;
use std::io::{self, Write};

fn main() -> io::Result<()> {
    let markdown = r#"
# Image Test

![Alt text](./image.jpg)

Text after image.
"#;

    let (width, _) = terminal_size().unwrap_or((80, 24));
    let kitty_ok = matches!(get_kitty_support(), KittySupport::Local | KittySupport::Remote);

    let config = Config {
        width: Some(width as u32),
        transparent: true,
        ..Default::default()
    };

    let mut in_image = false;
    let mut alt_text = String::new();
    let mut img_path = String::new();

    for event in Parser::new(markdown) {
        match event {
            Event::Start(Tag::Image { dest_url, .. }) => {
                in_image = true;
                alt_text.clear();
                img_path = dest_url.to_string();
            }
            Event::Text(text) if in_image => {
                alt_text.push_str(&text);
            }
            Event::End(TagEnd::Image) => {
                let path = Path::new(&img_path);
                if kitty_ok && path.exists() {
                    let _ = print_from_file(path, &config);
                    println!();
                } else {
                    println!("▉ IMAGE[{}]", alt_text);
                }
                in_image = false;
            }
            Event::Text(text) => {
                // Pass to two-face/syntect here
                print!("{}", text);
                io::stdout().flush()?;
            }
            _ => {}
        }
    }
    Ok(())
}
```

### Key Details

1. **Event Suppression**: Track `in_image` to prevent alt text from reaching your highlighter. The sequence is `Start(Image)` → `Text(alt)` → `End(Image)`.

2. **Output Order**: `viuer` writes escape codes directly to stdout. Your text renderer must also write to stdout (not buffer to String) to maintain correct vertical ordering.

3. **URL Images**: `viuer` only handles local files. For URLs, download with `reqwest` to a temp file, or add the `image` crate and use `viuer::print()` with a `DynamicImage`.
