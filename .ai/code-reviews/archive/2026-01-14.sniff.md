# Sniff Code Review (2026-01-14)

## Scope
Reviewed the `sniff` package (CLI + lib + tests) with focus on DRY issues, file size, module structure, idiomatic Rust, and testing.

## Strengths
- Clear separation between CLI and library crates with extensive unit/regression coverage.
- Sensible use of `sysinfo` for CPU/memory/storage and `getifaddrs` for interface enumeration.
- Thoughtful JSON flattening and filter logic in the CLI.

## Suggested Changes

### Module size and structure
- Split large modules into smaller, single-purpose files to improve readability and ownership boundaries:
  - `sniff/lib/src/os/mod.rs` (OS detection, distro parsing, locale/time, package managers) could be broken into `os/distro.rs`, `os/locale.rs`, `os/time.rs`, and `os/package_manager.rs`.
  - `sniff/lib/src/package/mod.rs` (1000+ lines) is doing enum definitions, mappings, and traits; consider `package/os.rs`, `package/language.rs`, and `package/manager.rs`.
  - `sniff/lib/src/filesystem/git.rs` and `sniff/cli/src/output.rs` are similarly oversized and would benefit from module splits.

### DRY and data-driven mappings
- There is duplicated monorepo detection logic between `sniff/lib/src/filesystem/monorepo.rs` and `sniff/lib/src/filesystem/repo.rs`. Consolidate into one implementation or have one call into the other to avoid drifting behavior.
- `LanguagePackageManager` and `OsPackageManager` each map variant → executable name (and `Display`), plus language mapping. Consider a shared metadata table or a helper macro to keep mappings in one place (`sniff/lib/src/package/mod.rs`).
- In `sniff/cli/src/output.rs`, SIMD capability formatting and GPU capability formatting are repeated across `print_hardware_section`, `print_cpu_section`, and `print_gpu_section`. Extract helpers like `format_simd_caps` / `format_gpu_caps` to keep outputs consistent.

### Idiomatic Rust / performance
- `enrich_dependencies` claims parallel execution but awaits futures sequentially. Use `futures::future::join_all` or `FuturesUnordered` to match the comment and improve runtime when multiple dependencies are enriched (`sniff/lib/src/package/network.rs`).
- `get_repo_status` builds `dirty_paths` with repeated `Vec::contains` checks (O(n^2) on large repos). Consider using `HashSet<PathBuf>` for uniqueness, then collect into a `Vec` later (`sniff/lib/src/filesystem/git.rs`).
- `NetworkInterface.mac_address` is never populated. `getifaddrs` exposes link-layer addresses; consider filling this field when available or remove it if it’s intentionally unsupported (`sniff/lib/src/network/mod.rs`, `sniff/lib/src/network/interface.rs`).
- `detect_monorepo`/`expand_glob_patterns` only supports simple `*` patterns. Consider using `glob`/`globset` for consistent matching with workspace tools (`sniff/lib/src/filesystem/monorepo.rs`).

### sysinfo/getifaddrs considerations
- `sysinfo::System` is used correctly for CPU/memory/storage, but OS detection mixes `sysinfo` with manual parsing; splitting OS concerns could let you unit test parsers independently from `sysinfo` runtime data (`sniff/lib/src/os/mod.rs`).
- `getifaddrs` gives you per-address entries; flags are updated per entry. If you later add MAC extraction, be mindful of multiple address records per interface and prefer a deterministic merge strategy (`sniff/lib/src/network/mod.rs`).

### Testing strategy and coverage
- Network registry tests hit real registries and can be flaky/offline. Consider `wiremock` with `reqwest::Client` injection, or mark these tests as `#[ignore]` unless `NETWORK_TESTS=1` is set (`sniff/lib/src/package/network.rs`).
- Many integration tests depend on host configuration (package managers, timezone, network). They are valuable but might need conditional checks or feature flags to reduce CI variability (`sniff/lib/tests/integration.rs`).
- CLI integration tests are comprehensive but large; factoring repeated command invocations into helpers would reduce test boilerplate and ease maintenance (`sniff/cli/tests/cli.rs`).

## Optional follow-ups
- Consider a small `sniff_lib::util` module for shared formatting helpers used in the CLI output and future TUI.
- Add unit tests for parsing helpers in `os` (e.g., `parse_os_release_content`, `parse_lsb_release_content`, `parse_system_release_content`) if not already present in the remainder of the file.
