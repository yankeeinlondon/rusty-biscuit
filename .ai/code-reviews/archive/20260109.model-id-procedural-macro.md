# Code Review: `model_id` Procedural Macro

**Date:** 2026-01-09
**Scope:** `./model_id/` package
**Reviewer:** Claude Code

---

## Summary

The `model_id` crate provides a procedural macro to derive wire-format model IDs from enum variant names. The concept is sound and addresses real boilerplate in `ai-pipeline`'s provider model enums. However, the crate has critical configuration issues preventing compilation, and the implementation has several correctness and robustness concerns.

---

## Must Fix

### 1. Missing `proc-macro` crate type declaration

**Location:** `model_id/Cargo.toml:1-7`

The crate declares a proc-macro derive but doesn't configure Cargo to compile it as a proc-macro crate:

```toml
# Current
[package]
name = "model_id"
version = "0.1.0"
edition = "2024"

[dependencies]
syn = "2.0.114"
```

**Fix:** Add the lib section:

```toml
[package]
name = "model_id"
version = "0.1.0"
edition = "2024"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0.114", features = ["full", "parsing"] }
quote = "1.0"
proc-macro2 = "1.0"
```

### 2. Missing `quote` dependency

**Location:** `model_id/Cargo.toml`

The code uses `quote::{quote, ToTokens}` but `quote` is not in dependencies.

### 3. Invalid edition "2024"

**Location:** `model_id/Cargo.toml:4`

Rust edition "2024" is not yet stable (as of January 2026). This should be `2021` unless you're intentionally using nightly features:

```toml
edition = "2021"
```

### 4. Fragile type detection for `Bespoke(String)`

**Location:** `model_id/src/lib.rs:51-56`

```rust
let is_single_string_field = matches!(
    &v.fields,
    Fields::Unnamed(u)
        if u.unnamed.len() == 1
            && u.unnamed[0].ty.to_token_stream().to_string() == "String"
);
```

This string comparison is fragile:
- `std::string::String` would not match
- `String` with extra whitespace from token formatting could fail
- Aliased types like `type Str = String;` would not match

**Suggested fix:** Check by variant name convention instead, or use a more robust type matching:

```rust
// Option A: Name-based detection (simpler, explicit)
let is_bespoke = v_ident == "Bespoke";

// Option B: Check for any single-field newtype with String-like name
fn is_string_type(ty: &syn::Type) -> bool {
    if let syn::Type::Path(p) = ty {
        if let Some(segment) = p.path.segments.last() {
            return segment.ident == "String";
        }
    }
    false
}
```

### 5. Missing `syn` features

**Location:** `model_id/Cargo.toml`

For `parse_macro_input!`, `DeriveInput`, and attribute parsing, you need:

```toml
syn = { version = "2.0", features = ["derive", "parsing", "full"] }
```

---

## Suggested Improvements

### 1. Add comprehensive tests

**Location:** Missing `model_id/tests/` directory

Proc macros are notoriously difficult to debug. Add `trybuild` tests for compile-pass and compile-fail cases:

```toml
# Cargo.toml
[dev-dependencies]
trybuild = "1.0"
```

```rust
// tests/ui.rs
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    t.pass("tests/pass/*.rs");
    t.compile_fail("tests/fail/*.rs");
}
```

Example test cases:
- `tests/pass/primary_provider.rs` - basic model enum
- `tests/pass/aggregator_provider.rs` - with `___` delimiter
- `tests/pass/with_override.rs` - `#[model_id("...")]` attribute
- `tests/fail/not_enum.rs` - derive on struct should error
- `tests/fail/bad_attribute.rs` - malformed `#[model_id]`

### 2. Add `FromStr` / `TryFrom<&str>` implementation

The macro only generates `model_id() -> &str`. For round-tripping (parsing wire IDs back to variants), consider also generating a `TryFrom<&str>` or `FromStr` impl:

```rust
impl std::str::FromStr for ProviderModelOpenAi {
    type Err = UnknownModelError;
    fn from_str(s: &str) -> Result<Self, Self::Err> { ... }
}
```

This would allow:
```rust
let model: ProviderModelOpenAi = "gpt-4o".parse()?;
```

### 3. Support `Cow<'static, str>` return type

Currently, `model_id()` returns `&str`. This works but requires the caller to handle the lifetime. Consider using `Cow`:

```rust
pub fn model_id(&self) -> Cow<'static, str> {
    match self {
        Self::Gpt_4o => Cow::Borrowed("gpt-4o"),
        Self::Bespoke(s) => Cow::Owned(s.clone()),  // or Cow::Borrowed if &'a str
    }
}
```

This is more flexible for serialization contexts.

### 4. Document the `#[model_id("...")]` override attribute

**Location:** `model_id/README.md`

The README documents rules 1-6 but doesn't mention the `#[model_id("...")]` override attribute that exists in the code. Add:

```markdown
## Override Attribute

For variant names that don't follow the encoding rules, use the `#[model_id("...")]`
attribute to specify the exact wire ID:

```rust
#[derive(ModelId)]
pub enum ProviderOpenAi {
    #[model_id("gpt-4-turbo-preview")]
    Gpt4TurboPreview,  // Custom mapping
}
```

### 5. Consider generating a `const` array of all models

For discovery/validation, it's useful to have a list of all known models:

```rust
impl ProviderModelOpenAi {
    pub const ALL: &'static [Self] = &[
        Self::Gpt_4o,
        Self::Gpt_4,
        // ... (excludes Bespoke)
    ];
}
```

### 6. Add `#[must_use]` to generated method

```rust
#[must_use]
pub fn model_id(&self) -> &str { ... }
```

### 7. Handle edge case: multiple `___` in variant name

**Location:** `model_id/src/lib.rs:70`

The `split_once` function handles this correctly (splits on first occurrence), but the README should clarify behavior:

```markdown
## Edge Cases

If a variant name contains multiple `___` delimiters, only the first is treated as
the provider separator. Example: `OpenAi___Gpt___4` becomes `"openai/gpt-4"`.
```

---

## Nits

### 1. Trailing newlines in `lib.rs`

**Location:** `model_id/src/lib.rs:155-156`

Two trailing blank lines. Most Rust style guides prefer exactly one.

### 2. The `split_once` helper duplicates `str::split_once`

**Location:** `model_id/src/lib.rs:101-105`

`str::split_once` has been stable since Rust 1.52. This helper can be removed:

```rust
// Before
let canonical: String = if let Some((provider_raw, model_raw)) = split_once(&raw, "___") {

// After
let canonical: String = if let Some((provider_raw, model_raw)) = raw.split_once("___") {
```

### 3. Comment in `normalize_provider` is outdated

**Location:** `model_id/src/lib.rs:109`

```rust
/// - `_` -> '-'  (if you ever need it)
```

The "if you ever need it" comment is unclear since the function does perform this replacement.

---

## Positive Observations

1. **Clear encoding rules** - The README documents the underscore conventions well, making it easy to understand how to name variants.

2. **Override escape hatch** - The `#[model_id("...")]` attribute provides flexibility for edge cases that don't fit the naming convention.

3. **Bespoke variant pattern** - Supporting a `Bespoke(String)` variant as a catch-all is a practical design that allows forward compatibility with new models.

4. **Defensive normalization** - The `decode_model` function collapses repeated dashes/dots, handling potential edge cases gracefully.

5. **Good error messages** - Returning proper `syn::Error` with spans ensures the compiler points to the problematic code location.

6. **Solves real boilerplate** - Looking at `ai-pipeline/lib/src/rigging/providers/models/openai.rs` with 100+ manual match arms, this macro will significantly reduce maintenance burden.

---

## Verification Checklist

Before merging, ensure:

- [ ] `cargo check -p model_id` passes
- [ ] `cargo test -p model_id` passes (after adding tests)
- [ ] Convert at least one existing manual impl (e.g., `ProviderModelOpenAi`) to use the derive
- [ ] Verify generated code with `cargo expand -p ai-pipeline` matches expected output
- [ ] Document the override attribute in README

---

## Related Files

- `ai-pipeline/lib/src/rigging/providers/models/zenmux.rs` - Already using (but won't compile until fixes applied)
- `ai-pipeline/lib/src/rigging/providers/models/openai.rs` - Candidate for conversion (110+ match arms)
- `ai-pipeline/lib/src/rigging/providers/models/anthropic.rs` - Candidate for conversion
