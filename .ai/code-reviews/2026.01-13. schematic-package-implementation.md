# Code Review: Schematic Package Implementation

**Date**: 2026-01-13
**Scope**: `schematic/define/` and `schematic/gen/` packages
**Reviewer**: Claude (using `rust` and `rust-testing` skills)
**Branch**: `feature/schematic`

## Overview

The schematic package is a two-crate code generator for producing strongly-typed Rust REST API clients from declarative API definitions. The implementation is well-architected with clear separation of concerns:

- **schematic-define**: Type definitions for REST APIs (endpoints, auth, responses)
- **schematic-gen**: Code generator that transforms definitions into Rust source code

## Positive Observations

### Excellent Architecture

1. **Clean separation of concerns**: The define/gen split follows the generator pattern well. Definitions are runtime-agnostic, and the generator handles all the `syn`/`quote`/`prettyplease` complexity.

2. **Type-safe code generation**: Using `proc_macro2::TokenStream` and validating with `syn::parse2` before writing ensures generated code is always syntactically valid.

3. **Atomic file writes** (`output.rs:147-172`): The temp file + rename pattern prevents partial writes and ensures file integrity.

4. **Comprehensive auth strategy support** (`client.rs:114-146`): All four auth patterns (None, Bearer, ApiKey, Basic) are handled with proper code generation for each.

5. **Path parameter extraction** (`parser.rs`): Simple, correct implementation using character iteration rather than regex.

### Strong Testing

1. **106 unit tests** across both packages, all passing
2. **Integration tests** verify end-to-end generation and compilation
3. **Edge case coverage**: empty APIs, consecutive path params, all HTTP methods, all auth strategies
4. **Property-like testing patterns**: tests iterate over all enum variants (e.g., `all_http_methods_generate_correct_string`)
5. **Compile-time validation tests** (marked `#[ignore]`): `generated_code_compiles` and `generated_code_passes_clippy`

### Good Documentation

1. **Module-level documentation** with examples in all files
2. **Doc comments on all public items** with usage examples
3. **Clear rustdoc structure** following H2 conventions (`## Examples`, `## Errors`, etc.)

## Must Fix

### 1. Silent Authentication Failure

**Location**: `client.rs:120-121`, `client.rs:126-129`, `client.rs:137-142`

**Issue**: When environment variables for authentication are missing, the request proceeds without auth rather than failing. This could cause confusing 401 errors at runtime.

```rust
// Current behavior - silently proceeds without auth
if let Ok(token) = std::env::var(#env_var) {
    req_builder = req_builder.header(#header_name, format!("Bearer {}", token));
}
```

**Why it matters**: Users won't get a helpful error message indicating the missing env var. They'll get a cryptic 401 from the API.

**Planned fix**: Restructure auth configuration to:

1. **Separate concerns**: Move env vars from `AuthStrategy` to `RestApi`. AuthStrategy describes *how* to auth (Bearer, ApiKey, Basic), while `RestApi` specifies *where* to get credentials.

2. **Fallback chain**: Support one or more env vars via `env_auth: Vec<String>` on `RestApi`. Try each in order until one is found.

3. **Fail at request time**: Return `SchematicError::MissingCredential { env_vars }` when all env vars in the chain are missing.

```rust
// Planned: AuthStrategy contains ONLY the auth method, no env vars
pub enum AuthStrategy {
    None,
    BearerToken { header: Option<String> },  // Just the header name
    ApiKey { header: String },                // Just the header name
    Basic,                                     // No env vars here
}

// Planned: RestApi gets env var fields
pub struct RestApi {
    // ...
    pub auth: AuthStrategy,
    pub env_auth: Vec<String>,        // Fallback chain: ["OPENAI_API_KEY", "OPENAI_KEY"]
    pub env_username: Option<String>, // For Basic auth only
    // ...
}

// Generated code errors if no credentials found
let token = self.env_auth.iter()
    .find_map(|var| std::env::var(var).ok())
    .ok_or_else(|| SchematicError::MissingCredential {
        env_vars: self.env_auth.clone(),
    })?;
```

**Note**: This is planned for implementation - see auth restructuring plan.

### 2. Body Serialization Silently Ignores Errors

**Location**: `request_structs.rs:166-168`

**Issue**: The `into_parts()` method uses `.ok()` on serialization, which silently converts errors to `None`:

```rust
let body_expr = if has_body {
    quote! { serde_json::to_string(&self.body).ok() }
} else {
    quote! { None }
};
```

**Why it matters**: If a request body fails to serialize (e.g., contains non-string keys in a map), the request will be sent without a body, causing server-side errors that are difficult to debug.

**Suggested fix**: Propagate the error:

```rust
// Return Result from into_parts or add a separate method
pub fn into_parts(self) -> Result<(&'static str, String, Option<String>), SchematicError> {
    let body = serde_json::to_string(&self.body)
        .map_err(|e| SchematicError::SerializationError(e.to_string()))?;
    Ok((method, path, Some(body)))
}
```

### 3. Missing `Serialize`/`Deserialize` on Request Structs

**Location**: `request_structs.rs:57` (`generate_derives` function)

**Issue**: Generated request structs only derive `Debug, Clone, Default` but not `Serialize, Deserialize`. This limits their utility for logging, caching, or replay scenarios.

```rust
fn generate_derives(has_body: bool) -> TokenStream {
    if has_body {
        quote! { #[derive(Debug, Clone)] }
    } else {
        quote! { #[derive(Debug, Clone, Default)] }
    }
}
```

**Suggested fix**: Add serde derives:

```rust
quote! { #[derive(Debug, Clone, Serialize, Deserialize)] }
```

## Suggested Improvements

### 1. Add `PartialEq` to Core Types

**Location**: `schema.rs:80-86`, `response.rs:40-64`, `types.rs:105-124`, `types.rs:171-189`

**Issue**: `Schema`, `ApiResponse`, `RestApi`, and `Endpoint` don't derive `PartialEq`, making testing more difficult and preventing comparison operations.

```rust
// Current
#[derive(Debug, Clone)]
pub struct Schema { ... }

// Suggested
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Schema { ... }
```

### 2. Add Runtime Variant Support to Generated Clients

**Location**: `api_struct.rs`, `client.rs`

**Issue**: Generated clients have hardcoded base URLs and env var names. Many APIs (OpenAI, Azure OpenAI, OpenRouter, local Ollama) share the same interface but use different credentials and endpoints.

**Suggested**: Add a `variant()` method to generated clients:

```rust
impl OpenAI {
    pub fn variant(
        base_url: impl Into<String>,
        env: impl Into<String>,
        strategy: VariantStrategy,
    ) -> Self { ... }
}
```

This allows runtime configuration for different API providers without redefining the API.

**Note**: This is planned for implementation - see auth restructuring plan.

### 3. Add Response Type Handling Beyond JSON

**Location**: `client.rs:103`

**Issue**: The generated client always calls `response.json::<T>()`, but `ApiResponse` supports `Text`, `Binary`, and `Empty` variants that aren't used.

```rust
// client.rs currently ignores response type
let result = response.json::<T>().await?;
```

**Suggested**: Generate different handling based on `ApiResponse` variant, or document that only JSON is currently supported.

### 4. Consider Custom HTTP Client Support

**Location**: `api_struct.rs:71-74`

**Issue**: The generated client always creates a new `reqwest::Client`. For applications with custom timeouts, connection pools, or middleware, this limits flexibility.

```rust
// Current - always creates new client
pub fn new() -> Self {
    Self {
        client: reqwest::Client::new(),
        base_url: Self::BASE_URL.to_string(),
    }
}
```

**Suggested**: Add constructor that accepts an existing client:

```rust
pub fn with_client(client: reqwest::Client) -> Self { ... }
```

### 5. Add Tracing/Logging to Generated Client

**Location**: `client.rs:47-108`

**Issue**: The generated `request()` method has no observability hooks. Following the project's tracing patterns (per `CLAUDE.md`), structured events would be valuable.

**Suggested**: Add optional tracing instrumentation:

```rust
#[tracing::instrument(skip(self), fields(method = %method, path = %path))]
pub async fn request<T>(&self, request: impl Into<Request>) -> Result<T, SchematicError> {
    // ...
}
```

## Nits

### 1. Inconsistent Use of `format_ident!` vs String Interpolation

**Location**: Various codegen files

Some places use `format_ident!("{}Request", endpoint.id)` while others build strings then convert. This is cosmetic but could be standardized.

### 2. Test Helper Functions Could Be Shared

**Location**: `output.rs:229-284`, `request_structs.rs:239-253`, `request_enum.rs:136-156`

Multiple test modules have similar `make_api()` and `make_endpoint()` helpers. Consider a `tests/common/mod.rs` module.

### 3. `write_atomic` Temp File Extension

**Location**: `output.rs:159`

Using `.rs.tmp` as the extension is slightly unusual. Consider `.tmp` alone:

```rust
let temp_path = path.with_extension("tmp");
```

## Test Coverage Analysis

| Module | Unit Tests | Integration Tests | Coverage Quality |
|--------|-----------|-------------------|------------------|
| `schematic-define` | 14 | - | Good - covers serde, parsing, all variants |
| `parser.rs` | 9 | - | Excellent - edge cases covered |
| `request_structs.rs` | 14 | 12 | Excellent - all HTTP methods, body/no-body |
| `request_enum.rs` | 9 | - | Good - empty API, multiple variants |
| `api_struct.rs` | 5 | - | Adequate - basic functionality |
| `client.rs` | 16 | 24 | Excellent - all auth strategies |
| `error.rs` | 9 | - | Good - all variants validated |
| `output.rs` | 24 | - | Excellent - atomic writes, full pipeline |
| `cargo_gen.rs` | 16 | - | Good - TOML validation |
| **E2E** | - | 4 (2 ignored) | Good - compilation verification |

**Overall**: Excellent test coverage. The ignored E2E tests (`generated_code_compiles`, `generated_code_passes_clippy`) are appropriately marked slow and verify the most important invariant: generated code compiles.

## Summary

This is a well-implemented code generator with:

- Clean architecture separating definition from generation
- Comprehensive test coverage (106 tests)
- Good documentation
- Proper use of Rust 2024 edition features (let-chains in `output.rs:149-151`)

The main concerns are around silent failures (missing auth credentials, serialization errors) which could make debugging production issues difficult. The suggested improvements are mostly about expanding functionality rather than fixing bugs.

**Recommendation**: Address the "Must Fix" items before production use, particularly the silent auth failure which could cause confusing runtime errors.
