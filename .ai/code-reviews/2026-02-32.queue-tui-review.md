# Queue Review Plan (Performance, Bugs, Tests, Docs)

## Goals
- Identify performance bottlenecks and hot paths in task scheduling, history persistence, and TUI rendering.
- Detect correctness risks in parsing, state transitions, and execution targets.
- Assess test coverage depth and identify missing scenarios.
- Verify documentation quality for public APIs and user-facing behavior.

## Scope
- `queue/lib`: executor, history store, parsing, terminal detection, types, errors.
- `queue/cli`: CLI args, TUI state/events, rendering, modal flows.

## Review Steps

### 1) Architecture and Data Flow
- Trace the flow from CLI args to TUI to scheduling to executor to history persistence.
- Map key types and where they are mutated (`ScheduledTask`, `TaskStatus`, history store).
- Confirm threading/async boundaries (tokio tasks, channels).

### 2) Performance Review
- Executor: review per-task tokio spawn, sleep scheduling, channel backpressure, and potential task buildup.
- History store: check JSONL read/write strategy, lock usage, and scalability for large histories.
- TUI render loop: inspect event/tick cadence, repaint frequency, and allocations in render path.
- Terminal detection: verify detection is cached or not repeated excessively.

### 3) Bug/Correctness Review
- Parsing: validate edge cases for `parse_at_time` and `parse_delay` (midnight, DST, invalid units, negative).
- Task lifecycle: confirm status transitions are consistent and history updates are durable.
- Execution targets: review command escaping/quoting for pane/window/background spawns.
- Error handling: ensure no `unwrap`/`expect` in production paths and errors surface cleanly.

### 4) Test Coverage Audit
- Inventory existing tests (executor unit tests, history integration, CLI integration).
- Identify gaps:
  - Invalid/edge parsing inputs and time zone/DST behavior.
  - History lock contention or corrupted JSONL handling.
  - Executor failure paths (non-zero exit, spawn errors).
  - TUI navigation and modal state transitions (input history, cancel, remove mode).
- Propose targeted unit/integration tests for gaps.

### 5) Documentation Review
- Verify Rustdoc coverage for all public items (lib exports).
- Cross-check README vs. actual CLI flags/behavior.
- Document platform-specific behavior (wezterm/osascript, terminal fallbacks).
- Ensure doc examples compile and are accurate.

### 6) Deliverables
- Review report with:
  - Performance hotspots and suggested mitigations.
  - Bug findings with severity and repro notes.
  - Test coverage gaps with suggested tests.
  - Documentation fixes or additions.

## Suggested Commands (if/when executing)
- `cargo test -p queue-lib`
- `cargo test -p queue-cli`
- `cargo clippy -p queue-lib -p queue-cli`
- Optional profiling: `cargo flamegraph -p queue-cli` after identifying hotspots
