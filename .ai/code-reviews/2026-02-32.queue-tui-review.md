# Queue Review Plan (Performance, Bugs, Tests, Docs)

## Goals
- Identify performance bottlenecks and hot paths in task scheduling, history persistence, and TUI rendering.
- Detect correctness risks in parsing, state transitions, and execution targets.
- Assess test coverage depth and identify missing scenarios.
- Verify documentation quality for public APIs and user-facing behavior.

## Scope
- `queue/lib`: executor, history store, parsing, terminal detection, types, errors.
- `queue/cli`: CLI args, TUI state/events, rendering, modal flows.
- Documentation: `queue/README.md`, `queue/lib/README.md`, `queue/cli/README.md`.

## Review Steps

### 1) Architecture and Data Flow
- Trace the flow from CLI args to TUI to scheduling to executor to history persistence.
- Map key types and where they are mutated (`ScheduledTask`, `TaskStatus`, history store).
- Confirm threading/async boundaries (tokio tasks, channels).

### 2) Performance Review
- Executor: review per-task tokio spawn, sleep scheduling, channel backpressure, and potential task buildup.
- History store: check JSONL read/write strategy, lock usage, and scalability for large histories.
- TUI render loop: inspect event/tick cadence, repaint frequency, and allocations in render path.
- Terminal detection: verify detection is cached or not repeated excessively.

### 3) Bug/Correctness Review
- Parsing: validate edge cases for `parse_at_time` and `parse_delay` (midnight, DST, invalid units, negative).
- Task lifecycle: confirm status transitions are consistent and history updates are durable.
- Execution targets: review command escaping/quoting for pane/window/background spawns.
- Error handling: ensure no `unwrap`/`expect` in production paths and errors surface cleanly.

### 4) Test Coverage Audit
- Inventory existing tests (executor unit tests, history integration, CLI integration).
- Identify gaps:
  - Invalid/edge parsing inputs and time zone/DST behavior.
  - History lock contention or corrupted JSONL handling.
  - Executor failure paths (non-zero exit, spawn errors).
  - TUI navigation and modal state transitions (input history, cancel, remove mode).
  - Terminal capability matrix behavior (pane/window/background options).
  - Wezterm split pane flow and task pane ID wiring.
  - History modal filtering behavior and selection reset.
  - Input modal validation rules vs parser behavior.
- Propose targeted unit/integration tests for gaps.

### 5) Documentation Review
- Verify Rustdoc coverage for all public items (lib exports).
- Cross-check README vs. actual CLI flags/behavior (including hidden flags like `--tui-pane`).
- Validate terminal matrix and execution targets match `TerminalDetector` and executor behavior.
- Validate Wezterm split workflow steps against CLI startup and pane wiring.
- Confirm history file path and JSONL structure match persistence behavior.
- Verify TUI keybinds and mode transitions align with handlers.
- Document platform-specific behavior (wezterm/osascript, terminal fallbacks).
- Ensure doc examples compile and are accurate.

### 6) Deliverables
- Review report with:
  - Performance hotspots and suggested mitigations.
  - Bug findings with severity and repro notes.
  - Test coverage gaps with suggested tests.
  - Documentation fixes or additions.
  - Docs accuracy deltas (doc statements that diverge from code).

## Suggested Commands (if/when executing)
- `cargo test -p queue-lib`
- `cargo test -p queue-cli`
- `cargo clippy -p queue-lib -p queue-cli`
- Optional profiling: `cargo flamegraph -p queue-cli` after identifying hotspots
