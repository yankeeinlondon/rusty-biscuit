# Code Review: Shared Library Module

**Date:** 2026-01-04
**Scope:** `/shared/src/` - Core shared utilities for the Dockhand monorepo
**Focus Areas:** DRY violations, inefficient code, function decomposition, reuse opportunities

---

## Executive Summary

The shared library is a substantial codebase (~28,500 lines across 59 files) providing common utilities for provider management, markdown processing, agent tools, and text-to-speech. While the code is generally well-structured with good documentation, there are several opportunities to improve DRY compliance, reduce function complexity, and enhance reuse.

### Key Metrics

| Complexity Hotspots | Lines | Concern |
|---------------------|-------|---------|
| `markdown/output/terminal.rs` | 6,358 | Monolithic rendering logic |
| `render/link.rs` | 2,094 | Large struct with many output methods |
| `providers/types.rs` | 1,746 | Auto-generated enum, acceptable |
| `tools/screen_scrape.rs` | 1,367 | Repetitive HTML extraction patterns |
| `providers/base.rs` | 1,157 | Well-factored, but lazy_static redundancy |

---

## Must Fix

### 1. Duplicated ANSI Escape Code Generation (DRY Violation)

**Location:** `markdown/output/terminal.rs:1198-1276`

Multiple functions generate nearly identical ANSI escape sequences:

```rust
// emit_prose_text (line 1208)
result.push_str(&format!("\x1b[38;2;{};{};{}m{}\x1b[0m", fg.r, fg.g, fg.b, text));

// emit_inline_code (line 1258)
format!("\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m{}\x1b[0m", ...)

// emit_code_text (line 1498, cfg(test))
format!("\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m{}\x1b[0m", ...)

// emit_padding_row (line 1613)
format!("\x1b[48;2;{};{};{}m\x1b[K\x1b[0m\n", ...)

// format_header_row (line 1545, multiple times)
format!("\x1b[1m\x1b[48;2;{};{};{}m\x1b[38;2;{};{};{}m {} \x1b[0m", ...)

// LineWrapper::emit_blockquote_prefix (line 1675)
format!("\x1b[38;2;100;100;100m\x1b[48;2;{};{};{}m{}\x1b[0m", ...)
```

**Recommendation:** Create an `AnsiBuilder` struct or module with composable methods:

```rust
// Proposed: shared/src/terminal/ansi.rs
pub struct AnsiBuilder {
    codes: Vec<String>,
}

impl AnsiBuilder {
    pub fn new() -> Self { Self { codes: vec![] } }

    pub fn fg(mut self, r: u8, g: u8, b: u8) -> Self {
        self.codes.push(format!("38;2;{};{};{}", r, g, b));
        self
    }

    pub fn bg(mut self, r: u8, g: u8, b: u8) -> Self {
        self.codes.push(format!("48;2;{};{};{}", r, g, b));
        self
    }

    pub fn bold(mut self) -> Self { self.codes.push("1".into()); self }
    pub fn italic(mut self) -> Self { self.codes.push("3".into()); self }
    pub fn underline(mut self) -> Self { self.codes.push("4".into()); self }
    pub fn strikethrough(mut self) -> Self { self.codes.push("9".into()); self }

    pub fn wrap(self, text: &str) -> String {
        if self.codes.is_empty() {
            text.to_string()
        } else {
            format!("\x1b[{}m{}\x1b[0m", self.codes.join(";"), text)
        }
    }
}
```

**Impact:** Reduces ~50 lines of duplicated escape sequence formatting, improves consistency, and makes terminal styling testable in isolation.

---

### 2. `write_terminal` Function is Too Long (628 lines)

**Location:** `markdown/output/terminal.rs:567-1196`

The `write_terminal` function handles the entire markdown rendering pipeline in one massive function with deeply nested match arms. This makes it difficult to:
- Test individual rendering components
- Reuse rendering logic for specific elements
- Understand the control flow

**Current structure (simplified):**
```rust
pub fn write_terminal<W>(...) -> Result<(), MarkdownError> {
    // 50 lines of setup
    for event in events {
        match event {
            InlineEvent::Start(InlineTag::Mark) => { /* 5 lines */ }
            InlineEvent::End(InlineTag::Mark) => { /* 3 lines */ }
            InlineEvent::Standard(Event::Start(Tag::CodeBlock(kind))) => { /* 15 lines */ }
            InlineEvent::Standard(Event::End(TagEnd::CodeBlock)) => { /* 100+ lines for mermaid/code */ }
            InlineEvent::Standard(Event::Text(text)) if in_code_block => { /* ... */ }
            // ... 40+ more match arms
        }
    }
    // cleanup
}
```

**Recommendation:** Extract a `TerminalRenderer` struct with methods per element type:

```rust
struct TerminalRenderer<'a, W: std::io::Write> {
    writer: &'a mut W,
    wrapper: LineWrapper,
    options: TerminalOptions,
    state: RenderState,  // in_code_block, list_stack, table_state, etc.
}

impl<'a, W: std::io::Write> TerminalRenderer<'a, W> {
    fn render_code_block(&mut self, code: &str, lang: &str, meta: &CodeBlockMeta) -> Result<(), MarkdownError>;
    fn render_heading(&mut self, level: HeadingLevel, text: &str) -> Result<(), MarkdownError>;
    fn render_table(&mut self, rows: &[Vec<String>], alignments: &[Alignment]) -> Result<(), MarkdownError>;
    fn render_blockquote_start(&mut self) -> Result<(), MarkdownError>;
    fn render_list_item(&mut self, content: &str, is_ordered: bool, number: Option<u64>) -> Result<(), MarkdownError>;
    fn render_image(&mut self, path: &str, alt: &str) -> Result<(), MarkdownError>;
    // etc.
}
```

**Impact:** Each method becomes independently testable, reusable, and maintainable. The main loop becomes a simple dispatch.

---

### 3. Repeated HTML Extraction Patterns in ScreenScrapeTool

**Location:** `tools/screen_scrape.rs:353-400+`

Multiple methods repeat the same selector-try-extract pattern:

```rust
fn extract_main_content(html: &str) -> String {
    let document = Html::parse_document(html);
    let selectors = ["article", "main", "[role='main']", ...];

    for selector_str in selectors {
        if let Ok(selector) = Selector::parse(selector_str)
            && let Some(element) = document.select(&selector).next()
        {
            let content: String = element.text().collect::<Vec<_>>().join("\n");
            if !content.trim().is_empty() {
                return content;
            }
        }
    }
    // fallback...
}

fn html_to_markdown(html: &str) -> String {
    let document = Html::parse_document(html);
    // Similar pattern for h1-h6, p, ul, ol, etc.
    for level in 1..=6 {
        if let Ok(selector) = Selector::parse(&format!("h{}", level)) {
            for element in document.select(&selector) {
                // ...
            }
        }
    }
    // ...
}
```

**Recommendation:** Create an `HtmlExtractor` helper:

```rust
struct HtmlExtractor<'a> {
    document: &'a Html,
}

impl<'a> HtmlExtractor<'a> {
    fn first_text(&self, selectors: &[&str]) -> Option<String>;
    fn all_text(&self, selector: &str) -> Vec<String>;
    fn elements(&self, selector: &str) -> impl Iterator<Item = ElementRef<'a>>;
    fn extract_with_fallback<F>(&self, selectors: &[&str], fallback: F) -> String
    where F: FnOnce() -> String;
}
```

**Impact:** Reduces ~100 lines of repeated selector parsing and error handling.

---

## Suggested Improvements

### 4. `lazy_static!` Provider Tables Could Be Consolidated

**Location:** `providers/base.rs:75-148`

Five separate `lazy_static!` blocks define related provider data:

```rust
lazy_static! { static ref PROVIDER_ENV_VARIABLES: HashMap<Provider, Vec<&'static str>> = { ... }; }
lazy_static! { static ref PROVIDER_AUTH: HashMap<Provider, ApiAuthMethod> = { ... }; }
lazy_static! { static ref LOCAL_PROVIDERS: Vec<Provider> = { ... }; }
lazy_static! { pub static ref PROVIDER_BASE_URLS: HashMap<Provider, &'static str> = { ... }; }
lazy_static! { pub static ref PROVIDER_MODELS_ENDPOINT: HashMap<Provider, &'static str> = { ... }; }
```

**Recommendation:** Consolidate into a single `ProviderConfig` struct:

```rust
pub struct ProviderConfig {
    pub env_vars: &'static [&'static str],
    pub auth_method: ApiAuthMethod,
    pub base_url: &'static str,
    pub models_endpoint: &'static str,
    pub is_local: bool,
}

lazy_static! {
    static ref PROVIDER_CONFIGS: HashMap<Provider, ProviderConfig> = {
        let mut m = HashMap::new();
        m.insert(Provider::OpenAi, ProviderConfig {
            env_vars: &["OPENAI_API_KEY"],
            auth_method: ApiAuthMethod::BearerToken,
            base_url: "https://api.openai.com",
            models_endpoint: "/v1/models",
            is_local: false,
        });
        // ... other providers
        m
    };
}

impl Provider {
    pub fn config(&self) -> &'static ProviderConfig {
        PROVIDER_CONFIGS.get(self).expect("All providers must have config")
    }
}
```

**Impact:** Single source of truth per provider, easier to add new providers, reduces hash lookups.

---

### 5. `Link` Struct Output Methods Have Duplication

**Location:** `render/link.rs:305-398`

Three output methods (`to_terminal`, `to_browser`, `to_markdown`) build strings with similar patterns:

```rust
pub fn to_browser(&self) -> String {
    let mut attrs = format!(r#"href="{}""#, html_escape(&self.link_to));
    if let Some(class) = &self.class {
        attrs.push_str(&format!(r#" class="{}""#, html_escape(class)));
    }
    if let Some(style) = &self.style {
        attrs.push_str(&format!(r#" style="{}""#, html_escape(style)));
    }
    if let Some(target) = &self.target {
        attrs.push_str(&format!(r#" target="{}""#, html_escape(target)));
    }
    // ... 4 more if-let patterns
}
```

**Recommendation:** Use a helper for optional attribute building:

```rust
fn maybe_attr(attrs: &mut String, name: &str, value: &Option<String>) {
    if let Some(v) = value {
        attrs.push_str(&format!(r#" {}="{}""#, name, html_escape(v)));
    }
}

pub fn to_browser(&self) -> String {
    let mut attrs = format!(r#"href="{}""#, html_escape(&self.link_to));
    maybe_attr(&mut attrs, "class", &self.class);
    maybe_attr(&mut attrs, "style", &self.style);
    maybe_attr(&mut attrs, "target", &self.target);
    maybe_attr(&mut attrs, "title", &self.title);
    // ... cleaner
}
```

---

### 6. `LineWrapper` Methods Have Repeated `unicode_width` Imports

**Location:** `markdown/output/terminal.rs:1662-1905`

Multiple methods import `unicode_width::UnicodeWidthStr` redundantly:

```rust
fn emit_blockquote_prefix(&mut self, depth: usize, bg: Color) {
    use unicode_width::UnicodeWidthStr;  // <-- repeated
    // ...
}

fn emit_newline_with_prefix(&mut self) {
    use unicode_width::UnicodeWidthStr;  // <-- repeated
    // ...
}

fn emit_word(&mut self, ...) {
    use unicode_width::UnicodeWidthStr;  // <-- repeated
    // ...
}
```

**Recommendation:** Move the import to the struct impl block or module level.

---

### 7. `compute_highlight_bg` and `compute_blockquote_bg` Are Nearly Identical

**Location:** `markdown/output/terminal.rs:1924-1962`

```rust
fn compute_highlight_bg(theme_bg: Color, color_mode: ColorMode) -> Color {
    match color_mode {
        ColorMode::Dark => Color {
            r: theme_bg.r.saturating_add(30).min(235),
            g: theme_bg.g.saturating_add(25).min(235),
            b: theme_bg.b,
            a: 255,
        },
        ColorMode::Light => Color { /* subtract instead */ },
    }
}

fn compute_blockquote_bg(theme_bg: Color, color_mode: ColorMode) -> Color {
    match color_mode {
        ColorMode::Dark => Color {
            r: theme_bg.r.saturating_add(20),
            g: theme_bg.g.saturating_add(20),
            b: theme_bg.b.saturating_add(20),
            a: 255,
        },
        ColorMode::Light => Color { /* subtract instead */ },
    }
}
```

**Recommendation:** Create a generic `adjust_background` function:

```rust
fn adjust_background(base: Color, color_mode: ColorMode, adjustments: (i16, i16, i16)) -> Color {
    let (dr, dg, db) = adjustments;
    let adjust = |v: u8, delta: i16| -> u8 {
        match color_mode {
            ColorMode::Dark => v.saturating_add(delta.max(0) as u8).min(235),
            ColorMode::Light => v.saturating_sub((-delta).max(0) as u8),
        }
    };
    Color {
        r: adjust(base.r, dr),
        g: adjust(base.g, dg),
        b: adjust(base.b, db),
        a: 255,
    }
}

// Usage:
let highlight_bg = adjust_background(theme_bg, color_mode, (30, 25, 0));
let blockquote_bg = adjust_background(theme_bg, color_mode, (20, 20, 20));
```

---

### 8. Table Rendering Logic Should Be Extracted

**Location:** `markdown/output/terminal.rs:1376-1495`

The `render_table` function is 120 lines and handles:
- Width constraint calculation
- comfy-table setup
- Column constraint scaling
- Header styling
- Data row iteration

**Recommendation:** Extract into `TableRenderer` struct in a separate submodule:

```rust
// markdown/output/table.rs
pub struct TableRenderer {
    terminal_width: u16,
    preset: &'static str,
}

impl TableRenderer {
    pub fn render(&self, rows: &[Vec<String>], alignments: &[CellAlignment]) -> String;
    fn calculate_constraints(&self, rows: &[Vec<String>]) -> Vec<ColumnConstraint>;
    fn build_header_row(&self, header: &[String], alignments: &[CellAlignment]) -> Row;
}
```

---

### 9. `ScrapeArgs` Default Implementation Is Redundant

**Location:** `tools/screen_scrape.rs:180-199`

```rust
impl Default for ScrapeArgs {
    fn default() -> Self {
        Self {
            url: String::new(),
            formats: vec![OutputFormat::Markdown],
            only_main_content: false,
            include_tags: vec![],
            exclude_tags: vec![],
            wait_for: None,
            actions: vec![],
            mobile: false,
            skip_tls_verification: false,
            remove_base64_images: false,
            proxy: ProxyMode::None,
            user_agent: None,
            timeout: 30,
            follow_redirects: true,
            headers: None,
        }
    }
}
```

All fields already have `#[serde(default)]` or have obvious defaults. The struct could use `#[derive(Default)]` with a few field-level `#[serde(default = "...")]` attributes.

---

## Nits (Optional)

### 10. Inconsistent Error Handling Patterns

Some modules use `thiserror`, others use manual `impl std::error::Error`. Consider standardizing on `thiserror` throughout.

### 11. Magic Numbers in Terminal Detection

**Location:** `terminal.rs:74-84`
```rust
if depth >= 16_777_216 { Self::TrueColor }
else if depth >= 256 { Self::Colors256 }
```
Consider named constants: `const TRUE_COLOR_DEPTH: u32 = 16_777_216;`

### 12. Test Functions Without `#[test]` Prefix Convention

Some test function names use `test_` prefix while being inside `#[cfg(test)]` modules. This is fine but inconsistent with Rust convention.

---

## Positive Observations

### Well-Structured Documentation
Module-level doc comments are excellent, with examples, usage notes, and cross-references. The `providers/base.rs` module is particularly well-documented with environment variable tables and example code.

### Good Use of Type Safety
The `ProviderModel` enum with static variants for common models and String outlets for bleeding-edge models is a nice pattern that balances compile-time safety with runtime flexibility.

### Thoughtful Error Types
Error types like `ProviderError` and `ScrapeError` are comprehensive, using `thiserror` effectively with descriptive variants.

### Tracing Instrumentation
Consistent use of `#[instrument]` with OpenTelemetry semantic conventions (`tool.name`, `tool.query`, etc.) makes the code observable without cluttering business logic.

### Test Infrastructure
The `ScopedEnv` RAII helper for environment variable tests with `#[serial_test::serial]` is a robust pattern for avoiding test interference.

### Graceful Degradation
The mermaid rendering in terminal.rs falls back cleanly from image to text mode, and the image renderer handles unsupported terminals gracefully.

---

## Summary of Recommendations

| Priority | Issue | Effort | Impact |
|----------|-------|--------|--------|
| High | Extract ANSI builder utility | Medium | High (DRY, testability) |
| High | Decompose `write_terminal` | High | High (maintainability) |
| Medium | Consolidate provider configs | Medium | Medium (DRY, extensibility) |
| Medium | HTML extraction helper | Medium | Medium (DRY) |
| Low | `Link` attribute builder | Low | Low (minor DRY) |
| Low | Color adjustment function | Low | Low (minor DRY) |
| Low | Table renderer extraction | Medium | Low (organization) |

---

*Review conducted using `rig` and local skills per CLAUDE.md instructions.*
