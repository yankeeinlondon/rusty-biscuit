# Tree-hugger Linting + Syntax Review (2026-01-21)

## Scope
Reviewed linting and syntax diagnostics for tree-hugger across supported grammars, with attention to tree-sitter usage patterns, performance, reuse opportunities, and test coverage.

---

## Implementation Plan

### Executive Summary

This plan incorporates all HIGH-priority recommendations, evaluated MEDIUM-priority items, and the 4 correctness error fixes. Key changes from the original plan:

1. **Phase 4 dependency update**: Now depends on Phase 6 (SourceContext helper provides pattern for source text access)
2. **Phase 8 decoupled from Phase 3**: Unified API works with optional SourceContext, reducing critical path
3. **Phase 1 expanded**: Added language-specific comment query patterns
4. **Phase 4 expanded**: Added source text parameter to `is_terminal_statement` signature
5. **Phase 5 expanded**: Defined qualifier validation rules and severity
6. **Phase 9 restructured**: Separate `LintArgs` struct for proper argument handling
7. **Error fixes applied**: Query syntax location, UTF-8 safety, serde annotations

### Dependency Graph (Optimized)

```
Group A (parallel): Phases 1, 2, 4*, 5, 6, 7
                    * Phase 4 depends on Phase 6
Group B: Phase 3 depends on Phase 6
Group C: Phase 8 (independent - decoupled from Phase 3)
Group D: Phase 9 depends on Phase 8
Group E: Phase 10 (incremental - unit tests after each phase)

Critical Path: 6 -> 4 -> (3, 8) -> 9 -> 10
Reduced from 5 sequential phases to 4 when 8 is decoupled
```

---

## Phase 1: Comment Captures for Ignore Directives

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/ignore_directives.rs`, `tree-hugger/lib/queries/{language}/comments.scm` (new) |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust |
| Suggested Skills | rust-testing (for directive parsing tests) |

### Description

Use tree-sitter comment captures for ignore directives instead of line-based string scanning. This prevents false positives for `//` appearing in strings and enables proper block comment support.

### Implementation Details

1. Create comment query files for each language in `tree-hugger/lib/queries/{language}/comments.scm`:

   **Rust/Go/Java/C/C++/Swift/Scala/JavaScript/TypeScript:**
   ```scheme
   [(line_comment) (block_comment)] @comment
   ```

   **Python:**
   ```scheme
   (comment) @comment
   ```

   **Bash/Zsh:**
   ```scheme
   (comment) @comment
   ```

   **Lua:**
   ```scheme
   [(comment) (block_comment)] @comment
   ```

   **Perl:**
   ```scheme
   [(comment) (pod)] @comment
   ```

   **PHP:**
   ```scheme
   [(comment) (shell_comment)] @comment
   ```

2. Add `QueryKind::Comments` variant to `queries/mod.rs`

3. Refactor `IgnoreDirectives::parse` to accept comment nodes:
   ```rust
   pub fn parse_from_comments(comments: &[(usize, &str)]) -> Self
   ```

4. Update `TreeFile::lint_diagnostics` to extract comments via query before parsing directives

### Acceptance Criteria

- [ ] Ignore directives inside string literals are not processed
- [ ] Block comments with ignore directives work correctly
- [ ] Existing tests pass with new implementation

---

## Phase 2: Fast Path for Syntax Diagnostics

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/file/tree_file.rs` |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust |
| Suggested Skills | None |

### Description

Add early return when `root.has_error()` is false to avoid traversing the entire tree for files without syntax errors.

### Implementation Details

Update `syntax_diagnostics()`:

```rust
pub fn syntax_diagnostics(&self) -> Vec<SyntaxDiagnostic> {
    let root = self.tree.root_node();

    // Fast path: no errors in tree
    if !root.has_error() {
        return Vec::new();
    }

    // Existing traversal logic...
}
```

### Notes

- `has_error()` exists on `Node` (verified in tree-sitter API)
- This optimization is significant for large files without syntax errors

### Acceptance Criteria

- [ ] Files without syntax errors return immediately
- [ ] Files with syntax errors still report all diagnostics
- [ ] Performance improvement measurable on large clean files

---

## Phase 3: Syntax Error Messaging with SourceContext

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/shared/symbol.rs`, `tree-hugger/lib/src/file/tree_file.rs` |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust, thiserror |
| Suggested Skills | None |
| **Depends On** | Phase 6 |

### Description

Improve syntax error messaging by including expected node kinds for missing nodes and add optional `SourceContext` to `SyntaxDiagnostic` for consistent UX.

### Implementation Details

1. Update `SyntaxDiagnostic` struct in `shared/symbol.rs`:

   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct SyntaxDiagnostic {
       pub message: String,
       pub range: CodeRange,
       pub severity: DiagnosticSeverity,
       /// Source context for visual display (optional for backward compatibility).
       #[serde(skip_serializing_if = "Option::is_none")]
       pub context: Option<SourceContext>,
   }
   ```

2. Update `syntax_diagnostics()` to use `build_source_context_from_range()` (from Phase 6):

   ```rust
   let message = if node.is_missing() {
       format!("Missing: expected {}", node.kind())
   } else {
       format!("Syntax error: unexpected {}", node.kind())
   };

   let range = range_for_node(node);
   let context = self.build_source_context_from_range(&range);

   diagnostics.push(SyntaxDiagnostic {
       message,
       range,
       severity: DiagnosticSeverity::Error,
       context: Some(context),
   });
   ```

### Acceptance Criteria

- [ ] Missing nodes show expected kind (e.g., "Missing: expected semicolon")
- [ ] Syntax diagnostics include source context when available
- [ ] JSON output excludes null context fields

---

## Phase 4: Dead-Code Terminal Pattern Matching

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/dead_code.rs`, `tree-hugger/lib/src/file/tree_file.rs` |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust |
| Suggested Skills | rust-testing (for terminal detection tests) |
| **Depends On** | Phase 6 |

### Description

Tighten dead-code detection to match specific terminal calls/macros via node text instead of treating all macro invocations/call expressions as terminal. Requires passing source text through the call chain.

### Implementation Details

1. Update `is_terminal_statement` signature to accept source text:

   ```rust
   pub fn is_terminal_statement(node: Node, language: ProgrammingLanguage, source: &str) -> bool
   ```

2. Update call site in `check_dead_code()`:

   ```rust
   if is_terminal_statement(node, self.language, &self.source) {
   ```

3. Implement safe UTF-8 extraction in helper functions:

   **Rust panic macros:**
   ```rust
   fn is_rust_panic_macro(node: Node, source: &str) -> bool {
       if node.kind() != "macro_invocation" {
           return false;
       }

       if let Some(macro_node) = node.child_by_field_name("macro") {
           if let Ok(text) = macro_node.utf8_text(source.as_bytes()) {
               return matches!(text, "panic" | "unreachable" | "todo" | "unimplemented");
           }
       }
       false
   }
   ```

   **Go panic:**
   ```rust
   fn is_go_panic_call(node: Node, source: &str) -> bool {
       if node.kind() != "call_expression" {
           return false;
       }
       if let Some(func_node) = node.child_by_field_name("function") {
           if func_node.kind() == "identifier" {
               if let Ok(text) = func_node.utf8_text(source.as_bytes()) {
                   return text == "panic";
               }
           }
       }
       false
   }
   ```

   **C/C++ exit/abort:**
   ```rust
   fn is_c_exit_call(node: Node, source: &str) -> bool {
       if node.kind() != "call_expression" {
           return false;
       }
       if let Some(func_node) = node.child_by_field_name("function") {
           if func_node.kind() == "identifier" {
               if let Ok(text) = func_node.utf8_text(source.as_bytes()) {
                   return matches!(text, "exit" | "abort" | "_exit" | "_Exit");
               }
           }
       }
       false
   }
   ```

4. Apply similar patterns for Swift (`fatalError`, `preconditionFailure`), Perl (`die`, `exit`), Lua (`error`, `os.exit`), PHP (`exit`, `die`)

### Acceptance Criteria

- [ ] Only known panic/exit functions trigger dead code detection
- [ ] Random macro invocations don't cause false positives
- [ ] UTF-8 extraction uses safe `if let Ok(text)` pattern (no unwrap)
- [ ] All 16 languages have specific terminal patterns

---

## Phase 5: Qualified Reference Validation

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/file/tree_file.rs`, `tree-hugger/lib/queries/{language}/references.scm` |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust |
| Suggested Skills | None |

### Description

Add validation for qualifiers in qualified references (`foo.bar`, `module::symbol`) instead of skipping them entirely. Reports `undefined-module` for unknown qualifiers.

### Implementation Details

1. Define validation rules:
   - Severity: `Warning` (not Error, as external modules may not be in scope)
   - Rule ID: `undefined-module`
   - Qualified references to validate: member access (`.`), namespace resolution (`::`)

2. Update `check_undefined_symbols()`:

   ```rust
   for reference in references {
       if reference.is_qualified {
           // Check if qualifier is a known module/namespace
           if let Some(qualifier) = &reference.qualifier {
               if !defined_names.contains(qualifier.as_str())
                   && !imported_names.contains(qualifier.as_str())
                   && !is_builtin(self.language, qualifier)
               {
                   diagnostics.push(LintDiagnostic {
                       message: format!("Reference to undefined module: {}", qualifier),
                       range: reference.range.clone(),
                       severity: DiagnosticSeverity::Warning,
                       rule: Some("undefined-module".to_string()),
                       context: Some(self.build_source_context_from_range(&reference.range)),
                   });
               }
           }
           continue; // Still skip the member itself
       }
       // ... existing undefined symbol check
   }
   ```

3. Add `undefined-module` to `severity_for_rule()` and `format_rule_message()` in `queries/mod.rs`

### Acceptance Criteria

- [ ] Qualified references with unknown qualifiers report warnings
- [ ] Known modules/namespaces don't trigger warnings
- [ ] Builtins (like `std::`, `Math.`) are recognized

---

## Phase 6: Consolidated SourceContext Helper

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/file/tree_file.rs` |
| Subagent | `coder-agent` |
| Required Skills | rust |
| Suggested Skills | None |

### Description

Consolidate SourceContext creation into a single helper that operates from a `CodeRange` and reuse a precomputed line index. Refactor existing `build_source_context(Node)` to use this new helper.

### Implementation Details

1. Add range-based helper:

   ```rust
   /// Builds source context from a code range.
   fn build_source_context_from_range(&self, range: &CodeRange) -> SourceContext {
       let line_text = self
           .source
           .lines()
           .nth(range.start_line.saturating_sub(1))
           .unwrap_or("")
           .to_string();

       let underline_length = if range.start_line == range.end_line {
           range.end_column.saturating_sub(range.start_column).max(1)
       } else {
           line_text.len().saturating_sub(range.start_column.saturating_sub(1)).max(1)
       };

       SourceContext {
           line_text,
           underline_column: range.start_column.saturating_sub(1),
           underline_length,
       }
   }
   ```

2. Refactor existing `build_source_context(Node)`:

   ```rust
   fn build_source_context(&self, node: &Node<'_>) -> SourceContext {
       self.build_source_context_from_range(&range_for_node(*node))
   }
   ```

3. Update `check_dead_code()` to use the new helper (removing duplicated logic)

### Notes

- Existing `build_source_context(Node)` at line 1293 should delegate to the new range-based helper
- Consider future optimization: precompute line offsets for O(1) line access

### Acceptance Criteria

- [ ] Single source of truth for SourceContext creation
- [ ] All existing usages updated to use consolidated helper
- [ ] No code duplication for context building

---

## Phase 7: Skip Query::new for Empty Lint Files

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/queries/mod.rs` |
| Subagent | `coder-agent` |
| Required Skills | tree-sitter, rust |
| Suggested Skills | None |

### Description

When a lint query resolves to an empty or comment-only file, skip `Query::new` to avoid unnecessary compilation overhead. Detection should happen at `resolve_query_text` level.

### Implementation Details

1. Update `resolve_query_text` to detect empty/comment-only queries:

   ```rust
   fn resolve_query_text(
       language: ProgrammingLanguage,
       kind: QueryKind,
   ) -> Result<String, TreeHuggerError> {
       // ... existing code ...

       if kind == QueryKind::Lint {
           let text = lint_query_by_name(language.query_name())
               .unwrap_or("")
               .to_string();

           // Check if query is effectively empty (only comments/whitespace)
           if is_query_empty(&text) {
               return Ok(String::new());
           }

           return Ok(text);
       }
       // ...
   }

   /// Checks if a query string is empty or contains only comments.
   fn is_query_empty(query: &str) -> bool {
       query.lines().all(|line| {
           let trimmed = line.trim();
           trimmed.is_empty() || trimmed.starts_with(';')
       })
   }
   ```

2. The existing `pattern_count() == 0` check in `run_pattern_diagnostics()` already handles empty queries, but this optimization avoids the `Query::new` call entirely.

### Notes

- Existing `pattern_count` check already handles empty queries at runtime
- This optimization moves the check earlier to avoid query compilation
- Languages like Lua, Swift have comment-only lint files (verified)

### Acceptance Criteria

- [ ] Comment-only lint.scm files don't trigger Query::new
- [ ] Empty string queries return early
- [ ] Performance improvement for languages without pattern rules

---

## Phase 8: Unified Diagnostics API

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/src/shared/symbol.rs`, `tree-hugger/lib/src/file/tree_file.rs`, `tree-hugger/cli/src/main.rs` |
| Subagent | `coder-agent` |
| Required Skills | rust, clap |
| Suggested Skills | None |
| **Independent** | Can proceed without Phase 3 |

### Description

Expose a unified `diagnostics` list that merges lint and syntax results with a `kind` field. This simplifies CLI/JSON consumption while preserving internal distinctions.

### Implementation Details

1. Add `DiagnosticKind` enum to `shared/symbol.rs`:

   ```rust
   /// Distinguishes the source of a diagnostic.
   #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
   pub enum DiagnosticKind {
       /// Pattern-based lint rule match
       Lint,
       /// Semantic analysis (undefined-symbol, unused-symbol, etc.)
       Semantic,
       /// Syntax error from parser
       Syntax,
   }
   ```

2. Add unified `Diagnostic` struct:

   ```rust
   /// A unified diagnostic combining lint, semantic, and syntax issues.
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct Diagnostic {
       pub kind: DiagnosticKind,
       pub message: String,
       pub range: CodeRange,
       pub severity: DiagnosticSeverity,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub rule: Option<String>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub context: Option<SourceContext>,
   }
   ```

3. Add `TreeFile::diagnostics()` method:

   ```rust
   /// Returns all diagnostics (lint, semantic, and syntax) for this file.
   pub fn diagnostics(&self) -> Vec<Diagnostic> {
       let mut all = Vec::new();

       // Convert lint diagnostics
       for lint in self.lint_diagnostics() {
           all.push(Diagnostic {
               kind: DiagnosticKind::Lint, // or Semantic based on rule
               message: lint.message,
               range: lint.range,
               severity: lint.severity,
               rule: lint.rule,
               context: lint.context,
           });
       }

       // Convert syntax diagnostics
       for syntax in self.syntax_diagnostics() {
           all.push(Diagnostic {
               kind: DiagnosticKind::Syntax,
               message: syntax.message,
               range: syntax.range,
               severity: syntax.severity,
               rule: None,
               context: syntax.context, // Will be Some after Phase 3
           });
       }

       all
   }
   ```

4. Distinguish semantic diagnostics by rule ID:

   ```rust
   let kind = match lint.rule.as_deref() {
       Some("undefined-symbol" | "unused-symbol" | "unused-import" | "dead-code" | "undefined-module") => {
           DiagnosticKind::Semantic
       }
       _ => DiagnosticKind::Lint,
   };
   ```

### Notes

- Phase 8 can proceed independently of Phase 3
- When Phase 3 is complete, syntax diagnostics will have context
- Until then, `context` for syntax diagnostics will be `None`

### Acceptance Criteria

- [ ] `TreeFile::diagnostics()` returns unified list
- [ ] Each diagnostic has appropriate `kind` field
- [ ] Existing `lint_diagnostics()` and `syntax_diagnostics()` still work

---

## Phase 9: CLI Diagnostic Filters

| Property | Value |
|----------|-------|
| Files | `tree-hugger/cli/src/main.rs` |
| Subagent | `coder-agent` |
| Required Skills | clap, rust |
| Suggested Skills | None |
| **Depends On** | Phase 8 |

### Description

Add CLI filters `--lint-only` and `--syntax-only` to narrow diagnostic output. Requires restructuring to use separate `LintArgs` struct.

### Implementation Details

1. Create `LintArgs` struct (separate from `CommonArgs`):

   ```rust
   /// Arguments for the lint command
   #[derive(clap::Args, Debug, Clone)]
   struct LintArgs {
       /// Glob patterns for files to include
       #[arg(value_name = "GLOB", num_args = 1..)]
       inputs: Vec<String>,

       /// Show only lint/semantic diagnostics (exclude syntax errors)
       #[arg(long)]
       lint_only: bool,

       /// Show only syntax diagnostics (exclude lint warnings)
       #[arg(long)]
       syntax_only: bool,
   }
   ```

2. Update `Command` enum:

   ```rust
   #[derive(Subcommand, Debug, Clone)]
   enum Command {
       // ... existing variants ...
       /// Run lint diagnostics on the file(s)
       Lint(LintArgs),
   }
   ```

3. Update `Command::inputs()`:

   ```rust
   fn inputs(&self) -> &[String] {
       match self {
           Self::Functions(args)
           | Self::Types(args)
           | Self::Symbols(args)
           | Self::Exports(args)
           | Self::Imports(args) => &args.inputs,
           Self::Lint(args) => &args.inputs,
           Self::Classes(args) => &args.inputs,
       }
   }
   ```

4. Add `CommandKind::Lint` variant with filter fields:

   ```rust
   enum CommandKind {
       // ... existing variants ...
       Lint {
           lint_only: bool,
           syntax_only: bool,
       },
   }
   ```

5. Filter diagnostics in render logic:

   ```rust
   CommandKind::Lint { lint_only, syntax_only } => {
       let diagnostics = tree_file.diagnostics();
       let filtered: Vec<_> = diagnostics.into_iter().filter(|d| {
           match d.kind {
               DiagnosticKind::Syntax => !lint_only,
               DiagnosticKind::Lint | DiagnosticKind::Semantic => !syntax_only,
           }
       }).collect();
       // render filtered diagnostics
   }
   ```

6. JSON output interaction: When `--json` is used with filters, only matching diagnostics appear in output

### Acceptance Criteria

- [ ] `--lint-only` excludes syntax errors
- [ ] `--syntax-only` excludes lint/semantic warnings
- [ ] Filters work with both pretty and JSON output
- [ ] Help text documents the new flags

---

## Phase 10: Test Coverage

| Property | Value |
|----------|-------|
| Files | `tree-hugger/lib/tests/tree_file.rs`, `tree-hugger/lib/tests/lint_diagnostics.rs`, `tree-hugger/lib/tests/fixtures/*` |
| Subagent | `tester-agent` |
| Required Skills | rust-testing |
| Suggested Skills | tree-sitter (for fixture design) |
| **Incremental** | Run unit tests after each phase |

### Description

Add comprehensive test coverage for all new functionality. Tests should be run incrementally after each phase.

### Test Scenarios

**Phase 1 Tests (Comment Captures):**
- Ignore directive in string literal (should NOT be processed)
- Block comment with ignore directive (should work)
- Mixed line/block comments in same file

**Phase 2 Tests (Fast Path):**
- File without syntax errors returns immediately
- File with syntax errors still reports all
- Performance benchmark (optional)

**Phase 3 Tests (Syntax Messaging):**
- Missing node shows expected kind
- Syntax diagnostic includes context
- JSON excludes null context

**Phase 4 Tests (Dead Code):**
- Rust: `panic!`, `unreachable!`, `todo!` detected
- Go: `panic()` detected, other functions not
- C: `exit()`, `abort()` detected
- Non-terminal macros don't trigger false positives

**Phase 5 Tests (Qualified References):**
- Unknown qualifier reports `undefined-module`
- Known module doesn't trigger warning
- Builtin modules recognized

**Phase 6 Tests (SourceContext):**
- Context built correctly from range
- Multi-line ranges handle underline properly

**Phase 7 Tests (Empty Query):**
- Comment-only lint.scm doesn't compile query
- Empty string query returns early

**Phase 8 Tests (Unified API):**
- `diagnostics()` includes both lint and syntax
- `kind` field correctly identifies source
- Semantic rules tagged as `Semantic`

**Phase 9 Tests (CLI Filters):**
- `--lint-only` excludes syntax
- `--syntax-only` excludes lint
- Both flags mutually exclusive behavior

### Acceptance Criteria

- [ ] All new functionality has test coverage
- [ ] Regression tests prevent future breakage
- [ ] Fixtures cover representative subset of languages

---

## Rejected Recommendations

| Recommendation | Rationale |
|----------------|-----------|
| Phase 4 split by language family (8 sub-phases) | Complexity overhead exceeds parallelism benefit; single phase with language-specific helpers is cleaner |
| Precomputed line index for SourceContext | Premature optimization; current `lines().nth()` is sufficient for typical file sizes; can add later if profiling shows need |

---

## Suggested Changes (Original Review)

### Tree-sitter usage and correctness

- Use tree-sitter comment captures for ignore directives instead of line-based string scanning so `tree-hugger-ignore` only triggers on real comments (avoids false positives for `//` in strings and enables block comments) in `tree-hugger/lib/src/ignore_directives.rs` and `tree-hugger/lib/src/file/tree_file.rs:905`.
- Add a fast path for syntax diagnostics by returning early when `root.has_error()` is false, rather than traversing the entire tree every call, in `tree-hugger/lib/src/file/tree_file.rs:1324`.
- Improve syntax error messaging by including expected node kinds for missing nodes and consider adding `SourceContext` to syntax diagnostics for consistent UX; this will touch `tree-hugger/lib/src/shared/symbol.rs:595` and `tree-hugger/lib/src/file/tree_file.rs:1324`.
- Tighten dead-code detection to match specific terminal calls/macros via node text or query captures instead of treating all macro invocations/call expressions as terminal, reducing false positives across languages in `tree-hugger/lib/src/dead_code.rs` and `tree-hugger/lib/src/file/tree_file.rs:1032`.
- Consider validating qualifiers in qualified references (`foo.bar`, `module::symbol`) instead of skipping them entirely so undefined-module cases are still caught across languages in `tree-hugger/lib/src/file/tree_file.rs:1090`.

### Performance and reuse

- Consolidate SourceContext creation into a single helper that operates from a `CodeRange` and reuse a precomputed line index to avoid repeated `source.lines().nth()` scans in `tree-hugger/lib/src/file/tree_file.rs`.
- When a lint query resolves to an empty or comment-only file, skip `Query::new` and cache a no-op path so languages without pattern rules do not incur repeated query compilation errors or overhead in `tree-hugger/lib/src/queries/mod.rs:79` and `tree-hugger/lib/queries/*/lint.scm`.

### Diagnostics model

- Consider exposing a unified `diagnostics` list that merges lint and syntax results with a `kind` field (`Lint` | `Syntax`) to simplify CLI/JSON consumption while preserving internal distinctions in `tree-hugger/lib/src/shared/symbol.rs` and `tree-hugger/lib/src/file/tree_file.rs`.
- For CLI UX, default to showing both kinds but add filters `--lint-only` and `--syntax-only` so users can narrow output without changing the core data model.

### Test coverage

- Add syntax error regression tests with invalid fixtures (missing delimiters, incomplete statements) for a representative subset of languages to exercise `syntax_diagnostics` in `tree-hugger/lib/tests/tree_file.rs`.
- Add semantic lint coverage for `undefined-symbol`, `unused-symbol`, `unused-import`, and `dead-code` so cross-grammar behavior is validated beyond pattern rules in `tree-hugger/lib/tests/lint_diagnostics.rs` and `tree-hugger/lib/tests/fixtures`.

## Updates Implemented

- Added semantic lint diagnostics tests for `undefined-symbol`, `unused-symbol`, `unused-import`, and `dead-code` in `tree-hugger/lib/tests/lint_diagnostics.rs`.
- Added syntax diagnostics regression tests for invalid Rust, JavaScript, and Python snippets using temp files in `tree-hugger/lib/tests/tree_file.rs`.
