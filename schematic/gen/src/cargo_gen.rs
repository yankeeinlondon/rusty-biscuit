//! Cargo.toml generation for the schema package.
//!
//! This module generates the Cargo.toml file for the schematic-schema package,
//! which contains the generated API client code. The generated manifest includes
//! all runtime dependencies needed by the generated code.

use std::fs;
use std::path::Path;

use crate::errors::GeneratorError;
use crate::output::write_atomic;

/// Template for the generated Cargo.toml (before substitution).
const CARGO_TOML_TEMPLATE: &str = r#"[package]
name = "schematic-schema"
version = "0.1.0"
edition = "2024"
license = "AGPL-3.0-only"
description = "Generated REST API client code from schematic definitions"

# This file was automatically generated by schematic-gen.
# Do not edit manually - changes will be overwritten.

[dependencies]
bytes = "1"
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls"] }
schematic-define = { version = "0.1.0", path = "{{DEFINE_PATH}}" }
schematic-definitions = { version = "0.1.0", path = "{{DEFINITIONS_PATH}}" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
tokio = { version = "1.43", features = ["rt", "macros"] }

[dev-dependencies]
wiremock = "0.6"
"#;

/// Generates the Cargo.toml content for the schema package.
///
/// Returns the complete Cargo.toml content as a string, ready to be written
/// to the schema package directory.
///
/// ## Arguments
///
/// * `workspace_root` - Optional path to the workspace root. When provided, uses
///   absolute paths to the schematic-define and schematic-definitions packages.
///   When `None`, uses the default relative paths (`../define`, `../definitions`).
///
/// ## Examples
///
/// ```
/// use schematic_gen::cargo_gen::generate_cargo_toml;
///
/// // Default relative paths (production use)
/// let content = generate_cargo_toml(None);
/// assert!(content.contains("schematic-schema"));
/// assert!(content.contains("edition = \"2024\""));
/// assert!(content.contains("path = \"../define\""));
///
/// // Absolute paths (for testing)
/// let content = generate_cargo_toml(Some("/workspace/schematic"));
/// assert!(content.contains("path = \"/workspace/schematic/define\""));
/// ```
pub fn generate_cargo_toml(workspace_root: Option<&str>) -> String {
    let (define_path, definitions_path) = match workspace_root {
        Some(root) => (format!("{}/define", root), format!("{}/definitions", root)),
        None => ("../define".to_string(), "../definitions".to_string()),
    };

    CARGO_TOML_TEMPLATE
        .replace("{{DEFINE_PATH}}", &define_path)
        .replace("{{DEFINITIONS_PATH}}", &definitions_path)
}

/// Writes the Cargo.toml to the output directory.
///
/// Creates the output directory if it doesn't exist and writes the Cargo.toml
/// file atomically using temp file + rename pattern.
///
/// ## Arguments
///
/// * `output_dir` - Parent directory for the schema package (not src/)
/// * `dry_run` - If true, print content instead of writing
/// * `workspace_root` - Optional path to workspace root for absolute paths (testing)
///
/// ## Examples
///
/// ```no_run
/// use std::path::Path;
/// use schematic_gen::cargo_gen::write_cargo_toml;
///
/// // Dry run mode - prints to stdout
/// write_cargo_toml(Path::new("schematic/schema"), true, None).unwrap();
///
/// // Normal mode - writes to file (production)
/// write_cargo_toml(Path::new("schematic/schema"), false, None).unwrap();
///
/// // For tests - use absolute paths to workspace packages
/// write_cargo_toml(Path::new("/tmp/test/schema"), false, Some("/workspace/schematic")).unwrap();
/// ```
///
/// ## Errors
///
/// Returns `GeneratorError::WriteError` if:
/// - The output directory cannot be created
/// - The file cannot be written
pub fn write_cargo_toml(
    output_dir: &Path,
    dry_run: bool,
    workspace_root: Option<&str>,
) -> Result<(), GeneratorError> {
    let content = generate_cargo_toml(workspace_root);

    if dry_run {
        println!(
            "# Cargo.toml would be written to: {}/Cargo.toml",
            output_dir.display()
        );
        println!("{}", content);
        return Ok(());
    }

    // Ensure the output directory exists
    fs::create_dir_all(output_dir).map_err(|e| GeneratorError::WriteError {
        path: output_dir.display().to_string(),
        source: e,
    })?;

    let cargo_path = output_dir.join("Cargo.toml");
    write_atomic(&cargo_path, &content)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    // === generate_cargo_toml tests ===

    #[test]
    fn generate_cargo_toml_produces_valid_toml() {
        let content = generate_cargo_toml(None);

        // Parse as TOML to validate syntax
        let parsed: toml::Table =
            toml::from_str(&content).expect("Generated content should be valid TOML");

        // Verify package section exists
        assert!(parsed.contains_key("package"));
        assert!(parsed.contains_key("dependencies"));
    }

    #[test]
    fn generate_cargo_toml_has_correct_package_name() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let package = parsed.get("package").unwrap().as_table().unwrap();
        assert_eq!(
            package.get("name").unwrap().as_str().unwrap(),
            "schematic-schema"
        );
    }

    #[test]
    fn generate_cargo_toml_uses_edition_2024() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let package = parsed.get("package").unwrap().as_table().unwrap();
        assert_eq!(package.get("edition").unwrap().as_str().unwrap(), "2024");
    }

    #[test]
    fn generate_cargo_toml_has_correct_license() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let package = parsed.get("package").unwrap().as_table().unwrap();
        assert_eq!(
            package.get("license").unwrap().as_str().unwrap(),
            "AGPL-3.0-only"
        );
    }

    #[test]
    fn generate_cargo_toml_includes_reqwest() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(
            deps.contains_key("reqwest"),
            "reqwest dependency is required"
        );

        // Verify reqwest has expected features
        let reqwest = deps.get("reqwest").unwrap().as_table().unwrap();
        let features = reqwest.get("features").unwrap().as_array().unwrap();
        assert!(features.iter().any(|f| f.as_str() == Some("json")));
        assert!(features.iter().any(|f| f.as_str() == Some("rustls-tls")));
    }

    #[test]
    fn generate_cargo_toml_includes_serde_with_derive() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(deps.contains_key("serde"), "serde dependency is required");

        // Verify serde has derive feature
        let serde = deps.get("serde").unwrap().as_table().unwrap();
        let features = serde.get("features").unwrap().as_array().unwrap();
        assert!(features.iter().any(|f| f.as_str() == Some("derive")));
    }

    #[test]
    fn generate_cargo_toml_includes_serde_json() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(
            deps.contains_key("serde_json"),
            "serde_json dependency is required"
        );
    }

    #[test]
    fn generate_cargo_toml_includes_thiserror() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(
            deps.contains_key("thiserror"),
            "thiserror dependency is required"
        );
    }

    #[test]
    fn generate_cargo_toml_includes_tokio() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(deps.contains_key("tokio"), "tokio dependency is required");

        // Verify tokio has expected features
        let tokio = deps.get("tokio").unwrap().as_table().unwrap();
        let features = tokio.get("features").unwrap().as_array().unwrap();
        assert!(features.iter().any(|f| f.as_str() == Some("rt")));
        assert!(features.iter().any(|f| f.as_str() == Some("macros")));
    }

    #[test]
    fn generate_cargo_toml_includes_bytes() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(
            deps.contains_key("bytes"),
            "bytes dependency is required for binary responses"
        );
    }

    #[test]
    fn generate_cargo_toml_includes_schematic_define() {
        let content = generate_cargo_toml(None);
        let parsed: toml::Table = toml::from_str(&content).unwrap();

        let deps = parsed.get("dependencies").unwrap().as_table().unwrap();
        assert!(
            deps.contains_key("schematic-define"),
            "schematic-define dependency is required for AuthStrategy and UpdateStrategy types"
        );

        // Verify schematic-define has path dependency
        let schematic_define = deps.get("schematic-define").unwrap().as_table().unwrap();
        assert!(
            schematic_define.contains_key("path"),
            "schematic-define should use path dependency"
        );
    }

    #[test]
    fn generate_cargo_toml_includes_generated_notice() {
        let content = generate_cargo_toml(None);

        assert!(content.contains("automatically generated"));
        assert!(content.contains("Do not edit manually"));
    }

    // === write_cargo_toml tests ===

    #[test]
    fn write_cargo_toml_dry_run_does_not_create_file() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("schema");

        let result = write_cargo_toml(&output_dir, true, None);

        assert!(result.is_ok());
        assert!(!output_dir.join("Cargo.toml").exists());
    }

    #[test]
    fn write_cargo_toml_creates_file() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("schema");

        let result = write_cargo_toml(&output_dir, false, None);

        assert!(result.is_ok());
        assert!(output_dir.join("Cargo.toml").exists());
    }

    #[test]
    fn write_cargo_toml_creates_parent_directories() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("nested/deep/schema");

        let result = write_cargo_toml(&output_dir, false, None);

        assert!(result.is_ok());
        assert!(output_dir.join("Cargo.toml").exists());
    }

    #[test]
    fn write_cargo_toml_file_contains_expected_content() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("schema");

        write_cargo_toml(&output_dir, false, None).unwrap();

        let content = fs::read_to_string(output_dir.join("Cargo.toml")).unwrap();

        // Verify content matches what generate_cargo_toml produces
        assert_eq!(content, generate_cargo_toml(None));
    }

    #[test]
    fn write_cargo_toml_overwrites_existing_file() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("schema");
        fs::create_dir_all(&output_dir).unwrap();

        // Write initial content
        let cargo_path = output_dir.join("Cargo.toml");
        fs::write(&cargo_path, "# old content").unwrap();

        // Overwrite with generated content
        write_cargo_toml(&output_dir, false, None).unwrap();

        let content = fs::read_to_string(&cargo_path).unwrap();
        assert!(content.contains("schematic-schema"));
        assert!(!content.contains("old content"));
    }

    #[test]
    fn write_cargo_toml_no_temp_file_left_behind() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("schema");

        write_cargo_toml(&output_dir, false, None).unwrap();

        // Check no .tmp file exists
        let temp_path = output_dir.join("Cargo.toml.tmp");
        assert!(!temp_path.exists());

        // Also check with .rs.tmp extension (the write_atomic pattern)
        let temp_path2 = output_dir.join("Cargo.toml.rs.tmp");
        assert!(!temp_path2.exists());
    }

    #[test]
    fn generate_cargo_toml_with_workspace_root_uses_absolute_paths() {
        let content = generate_cargo_toml(Some("/workspace/schematic"));

        assert!(content.contains("path = \"/workspace/schematic/define\""));
        assert!(content.contains("path = \"/workspace/schematic/definitions\""));
    }

    #[test]
    fn generate_cargo_toml_without_workspace_root_uses_relative_paths() {
        let content = generate_cargo_toml(None);

        assert!(content.contains("path = \"../define\""));
        assert!(content.contains("path = \"../definitions\""));
    }
}
