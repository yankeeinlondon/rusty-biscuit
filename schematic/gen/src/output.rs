//! Output assembly and file writing for generated code.
//!
//! This module handles the final phase of code generation: assembling all generated
//! pieces into a complete Rust file, validating the output, formatting it, and
//! writing it to disk atomically.
//!
//! ## Safety Guarantees
//!
//! - **Validation**: All generated code is validated with `syn` before writing
//! - **Formatting**: Output is formatted with `prettyplease` for consistent style
//! - **Atomic writes**: Uses temp file + rename pattern to prevent partial writes

use std::fs;
use std::path::Path;

use proc_macro2::TokenStream;
use quote::quote;
use schematic_define::RestApi;

use crate::codegen::{
    generate_api_struct, generate_error_type, generate_request_enum, generate_request_method,
    generate_request_struct,
};
use crate::errors::GeneratorError;

/// Assembles all generated code for an API into a single TokenStream.
///
/// This function combines all the code generation pieces in the correct order:
/// 1. Module documentation and lint attributes
/// 2. Import statements
/// 3. Error type definition
/// 4. Per-endpoint request structs
/// 5. Request enum (unifying all endpoints)
/// 6. API client struct
/// 7. Request method implementation
///
/// ## Arguments
///
/// * `api` - The REST API definition to generate code for
///
/// ## Returns
///
/// A TokenStream containing the complete generated code.
pub fn assemble_api_code(api: &RestApi) -> TokenStream {
    let api_name = &api.name;

    // Generate error type
    let error_type = generate_error_type();

    // Generate request structs for each endpoint
    let request_structs: TokenStream = api.endpoints.iter().map(generate_request_struct).collect();

    // Generate request enum
    let request_enum = generate_request_enum(api);

    // Generate API struct
    let api_struct = generate_api_struct(api);

    // Generate request method
    let request_method = generate_request_method(api);

    // Module-level doc comment
    let module_doc = format!("Generated API client for {}.", api_name);
    let generated_notice = "This code was automatically generated by schematic-gen. Do not edit manually.";

    // Combine all pieces with necessary imports
    quote! {
        #![doc = #module_doc]
        //!
        #![doc = #generated_notice]

        #![allow(dead_code)]
        #![allow(unused_imports)]

        use serde::{Deserialize, Serialize};

        #error_type

        #request_structs

        #request_enum

        #api_struct

        #request_method
    }
}

/// Validates generated code using syn.
///
/// Parses the token stream as a complete Rust file to ensure it's syntactically
/// valid before writing to disk.
///
/// ## Arguments
///
/// * `tokens` - The generated code to validate
///
/// ## Returns
///
/// The parsed `syn::File` on success, or an error if the code is invalid.
///
/// ## Errors
///
/// Returns `GeneratorError::CodeGenError` if the code fails to parse.
pub fn validate_code(tokens: &TokenStream) -> Result<syn::File, GeneratorError> {
    syn::parse2(tokens.clone())
        .map_err(|e| GeneratorError::CodeGenError(format!("Generated code is invalid: {}", e)))
}

/// Formats generated code using prettyplease.
///
/// Converts a parsed syn::File back to a nicely formatted string.
///
/// ## Arguments
///
/// * `file` - The parsed Rust file to format
///
/// ## Returns
///
/// A formatted string representation of the code.
pub fn format_code(file: &syn::File) -> String {
    prettyplease::unparse(file)
}

/// Writes content to a file atomically using temp file + rename.
///
/// This pattern ensures that:
/// - The file is never left in a partially-written state
/// - Other processes see either the old or new content, never a mix
/// - Power failures or crashes don't corrupt the file
///
/// ## Arguments
///
/// * `path` - The target file path
/// * `content` - The content to write
///
/// ## Returns
///
/// `Ok(())` on success.
///
/// ## Errors
///
/// Returns `GeneratorError::WriteError` if:
/// - Parent directories cannot be created
/// - The temp file cannot be written
/// - The rename operation fails
pub fn write_atomic(path: &Path, content: &str) -> Result<(), GeneratorError> {
    // Create parent directories if needed
    if let Some(parent) = path.parent()
        && !parent.as_os_str().is_empty()
    {
        fs::create_dir_all(parent).map_err(|e| GeneratorError::WriteError {
            path: parent.display().to_string(),
            source: e,
        })?;
    }

    // Write to temp file first
    let temp_path = path.with_extension("tmp");
    fs::write(&temp_path, content).map_err(|e| GeneratorError::WriteError {
        path: temp_path.display().to_string(),
        source: e,
    })?;

    // Atomically rename to final path
    fs::rename(&temp_path, path).map_err(|e| GeneratorError::WriteError {
        path: path.display().to_string(),
        source: e,
    })?;

    Ok(())
}

/// Generates and writes API code to the output directory.
///
/// This is the main entry point for code generation. It:
/// 1. Assembles all code pieces
/// 2. Validates the result with syn
/// 3. Formats with prettyplease
/// 4. Either prints (dry run) or writes atomically
///
/// ## Arguments
///
/// * `api` - The API definition to generate code for
/// * `output_dir` - Directory to write generated files to
/// * `dry_run` - If true, print code instead of writing files
///
/// ## Returns
///
/// The formatted code string (useful for dry-run mode or testing).
///
/// ## Errors
///
/// Returns an error if:
/// - Code generation produces invalid Rust
/// - File writing fails
pub fn generate_and_write(
    api: &RestApi,
    output_dir: &Path,
    dry_run: bool,
) -> Result<String, GeneratorError> {
    // Assemble code
    let tokens = assemble_api_code(api);

    // Validate with syn
    let file = validate_code(&tokens)?;

    // Format with prettyplease
    let formatted = format_code(&file);

    if dry_run {
        println!("{}", formatted);
    } else {
        // Write to output file
        let output_path = output_dir.join("lib.rs");
        write_atomic(&output_path, &formatted)?;
    }

    Ok(formatted)
}

#[cfg(test)]
mod tests {
    use super::*;
    use schematic_define::{ApiResponse, AuthStrategy, Endpoint, RestMethod, Schema};
    use std::fs;
    use tempfile::TempDir;

    fn make_simple_api() -> RestApi {
        RestApi {
            name: "TestApi".to_string(),
            description: "Test API".to_string(),
            base_url: "https://api.test.com/v1".to_string(),
            docs_url: None,
            auth: AuthStrategy::None,
            env_auth: vec![],
            env_username: None,
            env_password: None,
            endpoints: vec![Endpoint {
                id: "ListItems".to_string(),
                method: RestMethod::Get,
                path: "/items".to_string(),
                description: "List all items".to_string(),
                request: None,
                response: ApiResponse::json_type("ListItemsResponse"),
            }],
        }
    }

    fn make_complex_api() -> RestApi {
        RestApi {
            name: "OpenAI".to_string(),
            description: "OpenAI REST API".to_string(),
            base_url: "https://api.openai.com/v1".to_string(),
            docs_url: Some("https://platform.openai.com/docs".to_string()),
            auth: AuthStrategy::BearerToken { header: None },
            env_auth: vec!["OPENAI_API_KEY".to_string()],
            env_username: None,
            env_password: None,
            endpoints: vec![
                Endpoint {
                    id: "ListModels".to_string(),
                    method: RestMethod::Get,
                    path: "/models".to_string(),
                    description: "Lists available models".to_string(),
                    request: None,
                    response: ApiResponse::json_type("ListModelsResponse"),
                },
                Endpoint {
                    id: "RetrieveModel".to_string(),
                    method: RestMethod::Get,
                    path: "/models/{model}".to_string(),
                    description: "Retrieves a model".to_string(),
                    request: None,
                    response: ApiResponse::json_type("Model"),
                },
                Endpoint {
                    id: "CreateCompletion".to_string(),
                    method: RestMethod::Post,
                    path: "/completions".to_string(),
                    description: "Creates a completion".to_string(),
                    request: Some(Schema::new("CreateCompletionRequest")),
                    response: ApiResponse::json_type("Completion"),
                },
            ],
        }
    }

    // === assemble_api_code tests ===

    #[test]
    fn assemble_api_code_produces_valid_tokenstream() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);

        // Should produce non-empty output
        assert!(!tokens.is_empty());
    }

    #[test]
    fn assemble_api_code_includes_all_components() {
        let api = make_complex_api();
        let tokens = assemble_api_code(&api);
        let code = tokens.to_string();

        // Should include error type
        assert!(code.contains("SchematicError"));

        // Should include request structs
        assert!(code.contains("ListModelsRequest"));
        assert!(code.contains("RetrieveModelRequest"));
        assert!(code.contains("CreateCompletionRequest"));

        // Should include request enum
        assert!(code.contains("OpenAIRequest"));

        // Should include API struct
        assert!(code.contains("struct OpenAI"));

        // Should include request method
        assert!(code.contains("async fn request"));
    }

    #[test]
    fn assemble_api_code_includes_imports() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);
        let code = tokens.to_string();

        assert!(code.contains("serde"));
    }

    #[test]
    fn assemble_api_code_includes_lint_attributes() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);
        let code = tokens.to_string();

        assert!(code.contains("dead_code"));
        assert!(code.contains("unused_imports"));
    }

    // === validate_code tests ===

    #[test]
    fn validate_code_accepts_valid_code() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);

        let result = validate_code(&tokens);
        assert!(result.is_ok());
    }

    #[test]
    fn validate_code_accepts_complex_api() {
        let api = make_complex_api();
        let tokens = assemble_api_code(&api);

        let result = validate_code(&tokens);
        assert!(result.is_ok());
    }

    #[test]
    fn validate_code_rejects_invalid_code() {
        // Create a token stream that is valid tokens but not a valid Rust file
        // "let x =" is an incomplete statement that won't parse as a file
        let invalid_tokens = quote! {
            let x =
        };

        let result = validate_code(&invalid_tokens);
        assert!(result.is_err());

        match result {
            Err(GeneratorError::CodeGenError(_)) => {} // Expected
            Err(other) => panic!("Unexpected error type: {:?}", other),
            Ok(_) => panic!("Expected error but got success"),
        }
    }

    // === format_code tests ===

    #[test]
    fn format_code_produces_string() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);
        let file = validate_code(&tokens).unwrap();

        let formatted = format_code(&file);
        assert!(!formatted.is_empty());
    }

    #[test]
    fn format_code_produces_readable_output() {
        let api = make_simple_api();
        let tokens = assemble_api_code(&api);
        let file = validate_code(&tokens).unwrap();

        let formatted = format_code(&file);

        // Should have proper indentation and newlines
        assert!(formatted.contains('\n'));
        // Should have doc comments
        assert!(formatted.contains("///") || formatted.contains("//!"));
    }

    #[test]
    fn format_code_preserves_structure() {
        let api = make_complex_api();
        let tokens = assemble_api_code(&api);
        let file = validate_code(&tokens).unwrap();

        let formatted = format_code(&file);

        // All major elements should be present
        assert!(formatted.contains("pub enum SchematicError"));
        assert!(formatted.contains("pub struct OpenAI"));
        assert!(formatted.contains("pub enum OpenAIRequest"));
    }

    // === write_atomic tests ===

    #[test]
    fn write_atomic_creates_file() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.rs");

        let content = "// Test content";
        let result = write_atomic(&file_path, content);

        assert!(result.is_ok());
        assert!(file_path.exists());

        let read_content = fs::read_to_string(&file_path).unwrap();
        assert_eq!(read_content, content);
    }

    #[test]
    fn write_atomic_creates_parent_directories() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("nested/deep/test.rs");

        let content = "// Nested content";
        let result = write_atomic(&file_path, content);

        assert!(result.is_ok());
        assert!(file_path.exists());
    }

    #[test]
    fn write_atomic_overwrites_existing_file() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("existing.rs");

        // Write initial content
        fs::write(&file_path, "// Old content").unwrap();

        // Overwrite with atomic write
        let new_content = "// New content";
        let result = write_atomic(&file_path, new_content);

        assert!(result.is_ok());
        let read_content = fs::read_to_string(&file_path).unwrap();
        assert_eq!(read_content, new_content);
    }

    #[test]
    fn write_atomic_no_temp_file_left_behind() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("clean.rs");

        write_atomic(&file_path, "// Content").unwrap();

        // Check no .tmp file exists
        let temp_path = file_path.with_extension("tmp");
        assert!(!temp_path.exists());
    }

    // === generate_and_write tests ===

    #[test]
    fn generate_and_write_dry_run_returns_code() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();

        let result = generate_and_write(&api, temp_dir.path(), true);

        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("pub struct TestApi"));
    }

    #[test]
    fn generate_and_write_dry_run_no_file_created() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();

        generate_and_write(&api, temp_dir.path(), true).unwrap();

        // No file should be created in dry run
        let output_path = temp_dir.path().join("lib.rs");
        assert!(!output_path.exists());
    }

    #[test]
    fn generate_and_write_creates_lib_rs() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();

        let result = generate_and_write(&api, temp_dir.path(), false);

        assert!(result.is_ok());

        let output_path = temp_dir.path().join("lib.rs");
        assert!(output_path.exists());
    }

    #[test]
    fn generate_and_write_file_contains_formatted_code() {
        let api = make_complex_api();
        let temp_dir = TempDir::new().unwrap();

        generate_and_write(&api, temp_dir.path(), false).unwrap();

        let output_path = temp_dir.path().join("lib.rs");
        let content = fs::read_to_string(output_path).unwrap();

        // Should be properly formatted (has indentation)
        assert!(content.contains("    ")); // 4-space indent
        // Should have all components
        assert!(content.contains("pub struct OpenAI"));
        assert!(content.contains("pub enum OpenAIRequest"));
        assert!(content.contains("pub enum SchematicError"));
    }

    #[test]
    fn generate_and_write_returns_same_as_file_content() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();

        let returned = generate_and_write(&api, temp_dir.path(), false).unwrap();

        let output_path = temp_dir.path().join("lib.rs");
        let file_content = fs::read_to_string(output_path).unwrap();

        assert_eq!(returned, file_content);
    }

    #[test]
    fn generate_and_write_creates_nested_output_dir() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();
        let nested_dir = temp_dir.path().join("src/generated");

        let result = generate_and_write(&api, &nested_dir, false);

        assert!(result.is_ok());
        let output_path = nested_dir.join("lib.rs");
        assert!(output_path.exists());
    }

    // === Integration tests ===

    #[test]
    fn full_pipeline_with_all_auth_strategies() {
        // Test configurations: (auth, env_auth, env_username, env_password)
        let test_cases: Vec<(AuthStrategy, Vec<String>, Option<String>, Option<String>)> = vec![
            (AuthStrategy::None, vec![], None, None),
            (
                AuthStrategy::BearerToken { header: None },
                vec!["TOKEN".to_string()],
                None,
                None,
            ),
            (
                AuthStrategy::ApiKey {
                    header: "X-API-Key".to_string(),
                },
                vec!["KEY".to_string()],
                None,
                None,
            ),
            (
                AuthStrategy::Basic,
                vec![],
                Some("USER".to_string()),
                Some("PASS".to_string()),
            ),
        ];

        for (auth, env_auth, env_username, env_password) in test_cases {
            let api = RestApi {
                name: "TestApi".to_string(),
                description: "Test".to_string(),
                base_url: "https://test.com".to_string(),
                docs_url: None,
                auth: auth.clone(),
                env_auth,
                env_username,
                env_password,
                endpoints: vec![Endpoint {
                    id: "Test".to_string(),
                    method: RestMethod::Get,
                    path: "/test".to_string(),
                    description: "Test endpoint".to_string(),
                    request: None,
                    response: ApiResponse::json_type("TestResponse"),
                }],
            };

            let temp_dir = TempDir::new().unwrap();
            let result = generate_and_write(&api, temp_dir.path(), false);
            assert!(result.is_ok(), "Failed for auth strategy: {:?}", auth);
        }
    }

    #[test]
    fn full_pipeline_with_all_http_methods() {
        let methods = [
            RestMethod::Get,
            RestMethod::Post,
            RestMethod::Put,
            RestMethod::Patch,
            RestMethod::Delete,
            RestMethod::Head,
            RestMethod::Options,
        ];

        let endpoints: Vec<Endpoint> = methods
            .iter()
            .enumerate()
            .map(|(i, method)| Endpoint {
                id: format!("Endpoint{}", i),
                method: *method,
                path: format!("/path{}", i),
                description: format!("{:?} endpoint", method),
                request: None,
                response: ApiResponse::json_type("Response"),
            })
            .collect();

        let api = RestApi {
            name: "AllMethods".to_string(),
            description: "API with all HTTP methods".to_string(),
            base_url: "https://test.com".to_string(),
            docs_url: None,
            auth: AuthStrategy::None,
            env_auth: vec![],
            env_username: None,
            env_password: None,
            endpoints,
        };

        let temp_dir = TempDir::new().unwrap();
        let result = generate_and_write(&api, temp_dir.path(), false);
        assert!(result.is_ok());

        let content = result.unwrap();
        for method in methods {
            let method_str = format!("{:?}", method).to_uppercase();
            assert!(
                content.contains(&format!("\"{}\"", method_str)),
                "Missing method: {}",
                method_str
            );
        }
    }

    #[test]
    fn full_pipeline_empty_api_produces_valid_code() {
        let api = RestApi {
            name: "EmptyApi".to_string(),
            description: "API with no endpoints".to_string(),
            base_url: "https://empty.com".to_string(),
            docs_url: None,
            auth: AuthStrategy::None,
            env_auth: vec![],
            env_username: None,
            env_password: None,
            endpoints: vec![],
        };

        let temp_dir = TempDir::new().unwrap();
        let result = generate_and_write(&api, temp_dir.path(), false);

        // Even empty API should produce valid code
        assert!(result.is_ok());
    }

    #[test]
    fn generated_code_has_module_documentation() {
        let api = make_simple_api();
        let temp_dir = TempDir::new().unwrap();

        let code = generate_and_write(&api, temp_dir.path(), true).unwrap();

        // Should have module-level doc comments
        assert!(code.contains("//!"));
        assert!(code.contains("Generated API client"));
        assert!(code.contains("Do not edit manually"));
    }
}
