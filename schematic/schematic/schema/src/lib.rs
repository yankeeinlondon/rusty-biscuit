//!Generated API client for OpenAI.
//!
//!This code was automatically generated by schematic-gen. Do not edit manually.
#![allow(dead_code)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
/// Errors that can occur when making API requests.
///
/// This enum captures all error conditions that may arise during
/// API communication, including network failures, serialization
/// issues, and API-level errors.
#[derive(Debug, thiserror::Error)]
pub enum SchematicError {
    /// HTTP request failed (network error, timeout, etc.).
    #[error("HTTP request failed: {0}")]
    Http(#[from] reqwest::Error),
    /// Failed to deserialize JSON response.
    #[error("JSON deserialization failed: {0}")]
    Json(#[from] serde_json::Error),
    /// API returned an error response (non-2xx status code).
    #[error("API error (status {status}): {body}")]
    ApiError {
        /// HTTP status code from the response.
        status: u16,
        /// Response body text (may contain error details from the API).
        body: String,
    },
    /// Unsupported HTTP method encountered.
    ///
    /// This error should never occur when using generated request types,
    /// as they always produce valid HTTP methods.
    #[error("Unsupported HTTP method: {0}")]
    UnsupportedMethod(String),
    /// Failed to serialize request body to JSON.
    #[error("Failed to serialize request body: {0}")]
    SerializationError(String),
    /// Missing authentication credentials.
    ///
    /// None of the configured environment variables contained a value.
    #[error(
        "Missing credentials: none of the following environment variables are set: {env_vars:?}"
    )]
    MissingCredential {
        /// The environment variable names that were checked.
        env_vars: Vec<String>,
    },
}
///Request for ListModels endpoint.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelsRequest {}
impl ListModelsRequest {
    /// Converts the request into (method, path, body) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<(&'static str, String, Option<String>), SchematicError> {
        let path = "/models".to_string();
        Ok(("GET", path, None))
    }
}
///Request for RetrieveModel endpoint.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct RetrieveModelRequest {
    ///Path parameter: model
    pub model: String,
}
impl RetrieveModelRequest {
    /// Converts the request into (method, path, body) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<(&'static str, String, Option<String>), SchematicError> {
        let path = format!("/models/{}", self.model);
        Ok(("GET", path, None))
    }
}
///Request for DeleteModel endpoint.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteModelRequest {
    ///Path parameter: model
    pub model: String,
}
impl DeleteModelRequest {
    /// Converts the request into (method, path, body) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<(&'static str, String, Option<String>), SchematicError> {
        let path = format!("/models/{}", self.model);
        Ok(("DELETE", path, None))
    }
}
///Request enum for OpenAI API.
///
///Each variant wraps a strongly-typed request struct.
pub enum OpenAIRequest {
    ///Lists the currently available models
    ListModels(ListModelsRequest),
    ///Retrieves a model instance
    RetrieveModel(RetrieveModelRequest),
    ///Delete a fine-tuned model
    DeleteModel(DeleteModelRequest),
}
impl OpenAIRequest {
    /// Converts the request into (method, path, body) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    pub fn into_parts(self) -> (&'static str, String, Option<String>) {
        match self {
            Self::ListModels(req) => req.into_parts(),
            Self::RetrieveModel(req) => req.into_parts(),
            Self::DeleteModel(req) => req.into_parts(),
        }
    }
}
impl From<ListModelsRequest> for OpenAIRequest {
    fn from(req: ListModelsRequest) -> Self {
        Self::ListModels(req)
    }
}
impl From<RetrieveModelRequest> for OpenAIRequest {
    fn from(req: RetrieveModelRequest) -> Self {
        Self::RetrieveModel(req)
    }
}
impl From<DeleteModelRequest> for OpenAIRequest {
    fn from(req: DeleteModelRequest) -> Self {
        Self::DeleteModel(req)
    }
}
///OpenAI REST API for model management client.
pub struct OpenAI {
    client: reqwest::Client,
    base_url: String,
}
impl OpenAI {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "https://api.openai.com/v1";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
        }
    }
}
impl Default for OpenAI {
    fn default() -> Self {
        Self::new()
    }
}
impl OpenAI {
    /// Executes an API request.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<OpenAIRequest>,
    ) -> Result<T, SchematicError> {
        let request = request.into();
        let (method, path, body) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        let token = ["OPENAI_API_KEY"]
            .iter()
            .find_map(|var| std::env::var(var).ok())
            .ok_or_else(|| SchematicError::MissingCredential {
                env_vars: vec!["OPENAI_API_KEY".to_string()],
            })?;
        req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        let result = response.json::<T>().await?;
        Ok(result)
    }
}

