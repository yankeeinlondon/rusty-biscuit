// This code was automatically generated by schematic-gen. Do not edit manually.

/*! Generated API client for [Anthropic](https://docs.anthropic.com/en/api/messages).

 Anthropic Messages API for Claude AI interactions and agent tool use*/
//!
/*! ## Authentication

 Uses API key authentication via the `X-Api-Key` header. Set via environment variable: `ANTHROPIC_API_KEY`.*/
//!
/*! ## Features

 **GET**:
 - `ListModels` - List available Claude models
 - `RetrieveModel` - Get information about a specific model

 **POST**:
 - `CreateMessage` - Create a message with optional tool use for agent interactions
 - `CountTokens` - Count tokens in a message before sending
*/
//!
/*! ## Example

 ```ignore
 use schematic_schema::prelude::*;

 #[tokio::main]
 async fn main() -> Result<(), SchematicError> {
     let client = Anthropic::new();
     let response = client.list_models().await?;
     println!("{:?}", response);
     Ok(())
 }
 ```*/
use serde::{Deserialize, Serialize};
pub use schematic_definitions::anthropic::*;
use crate::shared::{RequestParts, SchematicError};
/// Request for `CreateMessage` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::anthropic::{CreateMessageRequest, CreateMessageBody};
///
/// let body = CreateMessageBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateMessageRequest::new(body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CreateMessageRequest {
    /// Request body
    pub body: CreateMessageBody,
}
impl CreateMessageRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CreateMessageBody) -> Self {
        Self { body }
    }
}
impl CreateMessageRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/messages".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `CountTokens` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::anthropic::{CountTokensRequest, CountTokensBody};
///
/// let body = CountTokensBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CountTokensRequest::new(body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CountTokensRequest {
    /// Request body
    pub body: CountTokensBody,
}
impl CountTokensRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CountTokensBody) -> Self {
        Self { body }
    }
}
impl CountTokensRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/messages/count_tokens".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListModels` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::anthropic::ListModelsRequest;
///
/// let request = ListModelsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelsRequest {}
impl ListModelsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/models".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `RetrieveModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::anthropic::RetrieveModelRequest;
///
/// let request = RetrieveModelRequest::new("model_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct RetrieveModelRequest {
    /// Path parameter: model_id
    pub model_id: String,
}
impl RetrieveModelRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(model_id: impl Into<String>) -> Self {
        Self { model_id: model_id.into() }
    }
}
impl RetrieveModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/models/{}", self.model_id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request enum for Anthropic API.
///
/// Each variant wraps a strongly-typed request struct.
pub enum AnthropicRequest {
    /// Create a message with optional tool use for agent interactions
    CreateMessage(CreateMessageRequest),
    /// Count tokens in a message before sending
    CountTokens(CountTokensRequest),
    /// List available Claude models
    ListModels(ListModelsRequest),
    /// Get information about a specific model
    RetrieveModel(RetrieveModelRequest),
}
impl AnthropicRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        match self {
            Self::CreateMessage(req) => req.into_parts(),
            Self::CountTokens(req) => req.into_parts(),
            Self::ListModels(req) => req.into_parts(),
            Self::RetrieveModel(req) => req.into_parts(),
        }
    }
}
impl From<CreateMessageRequest> for AnthropicRequest {
    fn from(req: CreateMessageRequest) -> Self {
        Self::CreateMessage(req)
    }
}
impl From<CountTokensRequest> for AnthropicRequest {
    fn from(req: CountTokensRequest) -> Self {
        Self::CountTokens(req)
    }
}
impl From<ListModelsRequest> for AnthropicRequest {
    fn from(req: ListModelsRequest) -> Self {
        Self::ListModels(req)
    }
}
impl From<RetrieveModelRequest> for AnthropicRequest {
    fn from(req: RetrieveModelRequest) -> Self {
        Self::RetrieveModel(req)
    }
}
/// Anthropic Messages API for Claude AI interactions and agent tool use client.
pub struct Anthropic {
    client: reqwest::Client,
    base_url: String,
    /// Environment variable names for authentication credentials.
    env_auth: Vec<String>,
    /// Authentication strategy for this API client.
    auth_strategy: schematic_define::AuthStrategy,
    /// Environment variable for Basic auth username.
    env_username: Option<String>,
    /// Default HTTP headers to include with every request.
    headers: Vec<(String, String)>,
}
impl Anthropic {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "https://api.anthropic.com/v1";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec!["ANTHROPIC_API_KEY".to_string()],
            auth_strategy: schematic_define::AuthStrategy::ApiKey {
                header: "X-Api-Key".to_string(),
            },
            env_username: None,
            headers: vec![("anthropic-version".to_string(), "2023-06-01".to_string())],
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
            env_auth: vec!["ANTHROPIC_API_KEY".to_string()],
            auth_strategy: schematic_define::AuthStrategy::ApiKey {
                header: "X-Api-Key".to_string(),
            },
            env_username: None,
            headers: vec![("anthropic-version".to_string(), "2023-06-01".to_string())],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec!["ANTHROPIC_API_KEY".to_string()],
            auth_strategy: schematic_define::AuthStrategy::ApiKey {
                header: "X-Api-Key".to_string(),
            },
            env_username: None,
            headers: vec![("anthropic-version".to_string(), "2023-06-01".to_string())],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
            env_auth: vec!["ANTHROPIC_API_KEY".to_string()],
            auth_strategy: schematic_define::AuthStrategy::ApiKey {
                header: "X-Api-Key".to_string(),
            },
            env_username: None,
            headers: vec![("anthropic-version".to_string(), "2023-06-01".to_string())],
        }
    }
    /// Creates a variant of this API client with different configuration.
    ///
    /// This method clones the underlying HTTP client and allows customizing:
    /// - Base URL (for proxies, mock servers, or different environments)
    /// - Authentication credentials (different env var names)
    /// - Authentication strategy (via `UpdateStrategy`)
    ///
    /// ## Arguments
    ///
    /// * `base_url` - New base URL for this variant
    /// * `env_auth` - New environment variable names for credentials
    /// * `strategy` - How to update the auth strategy:
    ///   - `UpdateStrategy::NoChange` - Keep current auth strategy
    ///   - `UpdateStrategy::ChangeTo(auth)` - Use specified auth strategy
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// use schematic_define::UpdateStrategy;
    ///
    /// let api = Api::new();
    ///
    /// // Create a variant pointing to a staging server
    /// let staging = api.variant(
    ///     "https://staging.api.com/v1",
    ///     vec!["STAGING_API_KEY".to_string()],
    ///     UpdateStrategy::NoChange,
    /// );
    ///
    /// // Create a variant with different auth
    /// let other = api.variant(
    ///     "https://other.api.com/v1",
    ///     vec!["OTHER_TOKEN".to_string()],
    ///     UpdateStrategy::ChangeTo(schematic_define::AuthStrategy::ApiKey {
    ///         header: "X-API-Key".to_string(),
    ///     }),
    /// );
    /// ```
    pub fn variant(
        &self,
        base_url: impl Into<String>,
        env_auth: Vec<String>,
        strategy: schematic_define::UpdateStrategy,
    ) -> Self {
        let auth_strategy = match strategy {
            schematic_define::UpdateStrategy::NoChange => self.auth_strategy.clone(),
            schematic_define::UpdateStrategy::ChangeTo(auth) => auth,
        };
        Self {
            client: self.client.clone(),
            base_url: base_url.into(),
            env_auth,
            auth_strategy,
            env_username: self.env_username.clone(),
            headers: self.headers.clone(),
        }
    }
    /// Returns a reference to the underlying HTTP client.
    ///
    /// Use this for custom requests that aren't covered by the generated methods,
    /// such as paginated endpoints that require query parameters.
    pub fn http_client(&self) -> &reqwest::Client {
        &self.client
    }
    /// Returns the base URL for this API client.
    pub fn api_base_url(&self) -> &str {
        &self.base_url
    }
    /// Returns the API key header name and value for authentication.
    ///
    /// Returns `None` if the authentication strategy is not `ApiKey`
    /// or if the API key environment variable is not set.
    pub fn api_key_header(&self) -> Option<(String, String)> {
        match &self.auth_strategy {
            schematic_define::AuthStrategy::ApiKey { header } => {
                for env_name in &self.env_auth {
                    if let Ok(value) = std::env::var(env_name) {
                        return Some((header.clone(), value));
                    }
                }
                None
            }
            _ => None,
        }
    }
}
impl Default for Anthropic {
    fn default() -> Self {
        Self::new()
    }
}
impl Anthropic {
    /// Builds and sends an HTTP request, returning the raw response.
    ///
    /// This is an internal helper method used by the public request methods.
    async fn build_and_send_request(
        &self,
        request: impl Into<AnthropicRequest>,
    ) -> Result<reqwest::Response, SchematicError> {
        let request = request.into();
        let (method, path, body, endpoint_headers) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        match &self.auth_strategy {
            schematic_define::AuthStrategy::None => {}
            schematic_define::AuthStrategy::BearerToken { header } => {
                let header_name = header.as_deref().unwrap_or("Authorization");
                let token = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder
                    .header(header_name, format!("Bearer {}", token));
            }
            schematic_define::AuthStrategy::ApiKey { header } => {
                let key = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder.header(header.as_str(), key);
            }
            schematic_define::AuthStrategy::Basic => {
                let username_env = self.env_username.as_deref().unwrap_or("USERNAME");
                let password_env = self
                    .env_auth
                    .first()
                    .map(String::as_str)
                    .unwrap_or("PASSWORD");
                let username = std::env::var(username_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![username_env.to_string()],
                    })?;
                let password = std::env::var(password_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![password_env.to_string()],
                    })?;
                req_builder = req_builder.basic_auth(username, Some(password));
            }
        }
        let merged_headers = Self::merge_headers(&self.headers, &endpoint_headers);
        for (key, value) in merged_headers {
            req_builder = req_builder.header(key.as_str(), value.as_str());
        }
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        Ok(response)
    }
    /// Merges API-level and endpoint-level headers.
    ///
    /// Endpoint headers override API headers for matching keys (case-insensitive).
    /// Returns a new Vec with the merged headers.
    fn merge_headers(
        api_headers: &[(String, String)],
        endpoint_headers: &[(String, String)],
    ) -> Vec<(String, String)> {
        let mut result: Vec<(String, String)> = Vec::new();
        for (api_key, api_value) in api_headers {
            let has_override = endpoint_headers
                .iter()
                .any(|(k, _)| k.eq_ignore_ascii_case(api_key));
            if !has_override {
                result.push((api_key.clone(), api_value.clone()));
            }
        }
        for (key, value) in endpoint_headers {
            result.push((key.clone(), value.clone()));
        }
        result
    }
    /// Executes an API request expecting a JSON response.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<AnthropicRequest>,
    ) -> Result<T, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let result = response.json::<T>().await?;
        Ok(result)
    }
}
