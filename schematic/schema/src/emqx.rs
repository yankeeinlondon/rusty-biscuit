// This code was automatically generated by schematic-gen. Do not edit manually.

/*! Generated API client for [EmqxBearer](https://docs.emqx.com/en/emqx/latest/admin/api.html).

 EMQX Broker REST API with Bearer Token authentication (JWT)*/
//!
/*! ## Authentication

 Uses Bearer token authentication via the `Authorization` header. Set via environment variable: `EMQX_TOKEN`.*/
//!
/*! ## Features

 **DELETE**:
 - `DisconnectClient` - Forcefully disconnect a client from the broker
 - `DeleteRule` - Delete a rule from the rules engine
 - `DeleteAuthUser` - Delete a user from a built-in database authenticator
 - `DeleteRetained` - Delete a retained message
 - `DeleteBan` - Remove a ban by type (clientid, username, peerhost) and value

 **GET**:
 - `ListNodes` - List all nodes in the EMQX cluster
 - `GetNode` - Get detailed information about a specific node
 - `GetCluster` - Get cluster status and node membership
 - `ListClients` - List connected MQTT clients with pagination
 - `GetClient` - Get detailed information about a specific client
 - `ListSubscriptions` - List all subscriptions across the cluster
 - `ListRules` - List all rules in the rules engine
 - `GetRule` - Get details of a specific rule
 - `ListAuthenticators` - List all configured authentication providers
 - `GetAuthenticator` - Get details of a specific authenticator
 - `ListAuthUsers` - List users in a built-in database authenticator
 - `ListAuthzSources` - List all authorization sources
 - `ListListeners` - List all configured listeners
 - `GetListener` - Get details of a specific listener
 - `ListMetrics` - Get broker metrics for all nodes
 - `ListStats` - Get broker statistics for all nodes
 - `GetPrometheus` - Get metrics in Prometheus format
 - `ListTopics` - List active topics in the broker
 - `ListRetained` - List retained messages with pagination
 - `GetRetained` - Get a specific retained message by topic
 - `ListAlarms` - List active alarms
 - `ListBanned` - List all banned clients, usernames, and hosts

 **POST**:
 - `Login` - Authenticate with username/password and receive a JWT token
 - `Logout` - Invalidate the current bearer token
 - `SubscribeClient` - Create a subscription for a connected client
 - `UnsubscribeClient` - Remove a subscription from a connected client
 - `Publish` - Publish an MQTT message to a topic
 - `PublishBulk` - Publish multiple MQTT messages in a single request
 - `CreateRule` - Create a new rule in the rules engine
 - `TestRule` - Test a rule with sample data
 - `CreateAuthUser` - Create a new user in a built-in database authenticator
 - `CreateBan` - Ban a client, username, or host

 **PUT**:
 - `UpdateRule` - Update an existing rule
*/
//!
/*! ## Example

 ```ignore
 use schematic_schema::prelude::*;

 #[tokio::main]
 async fn main() -> Result<(), SchematicError> {
     let client = EmqxBearer::new();
     let response = client.list_nodes().await?;
     println!("{:?}", response);
     Ok(())
 }
 ```*/
use serde::{Deserialize, Serialize};
pub use schematic_definitions::emqx::*;
use crate::shared::{RequestParts, SchematicError};
/// Request for `Login` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{LoginBearerRequest, LoginBody};
///
/// let body = LoginBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = LoginBearerRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoginBearerRequest {
    /// Request body
    pub body: LoginBody,
}
impl Default for LoginBearerRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl LoginBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: LoginBody) -> Self {
        Self { body }
    }
}
impl LoginBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/login".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `Logout` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::LogoutBearerRequest;
///
/// let request = LogoutBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LogoutBearerRequest {}
impl LogoutBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/logout".to_string();
        Ok(("POST", path, None, vec![]))
    }
}
/// Request for `ListNodes` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListNodesBearerRequest;
///
/// let request = ListNodesBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListNodesBearerRequest {}
impl ListNodesBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/nodes".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetNode` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetNodeBearerRequest;
///
/// let request = GetNodeBearerRequest::new("node_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetNodeBearerRequest {
    /// Path parameter: node
    pub node: String,
}
impl GetNodeBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(node: impl Into<String>) -> Self {
        Self { node: node.into() }
    }
}
impl GetNodeBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/nodes/{}", self.node);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetCluster` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetClusterBearerRequest;
///
/// let request = GetClusterBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetClusterBearerRequest {}
impl GetClusterBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/cluster".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListClients` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListClientsBearerRequest;
///
/// let request = ListClientsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListClientsBearerRequest {}
impl ListClientsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/clients".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetClient` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetClientBearerRequest;
///
/// let request = GetClientBearerRequest::new("clientid_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetClientBearerRequest {
    /// Path parameter: clientid
    pub clientid: String,
}
impl GetClientBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(clientid: impl Into<String>) -> Self {
        Self { clientid: clientid.into() }
    }
}
impl GetClientBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/clients/{}", self.clientid);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `DisconnectClient` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::DisconnectClientBearerRequest;
///
/// let request = DisconnectClientBearerRequest::new("clientid_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DisconnectClientBearerRequest {
    /// Path parameter: clientid
    pub clientid: String,
}
impl DisconnectClientBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(clientid: impl Into<String>) -> Self {
        Self { clientid: clientid.into() }
    }
}
impl DisconnectClientBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/clients/{}", self.clientid);
        Ok(("DELETE", path, None, vec![]))
    }
}
/// Request for `SubscribeClient` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{SubscribeClientBearerRequest, SubscribeBody};
///
/// let body = SubscribeBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = SubscribeClientBearerRequest::new("clientid_value", body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubscribeClientBearerRequest {
    /// Path parameter: clientid
    pub clientid: String,
    /// Request body
    pub body: SubscribeBody,
}
impl Default for SubscribeClientBearerRequest {
    fn default() -> Self {
        Self {
            clientid: String::new(),
            body: Default::default(),
        }
    }
}
impl SubscribeClientBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(clientid: impl Into<String>, body: SubscribeBody) -> Self {
        Self {
            clientid: clientid.into(),
            body,
        }
    }
}
impl SubscribeClientBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/clients/{}/subscribe", self.clientid);
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `UnsubscribeClient` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{UnsubscribeClientBearerRequest, SubscribeBody};
///
/// let body = SubscribeBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = UnsubscribeClientBearerRequest::new("clientid_value", body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnsubscribeClientBearerRequest {
    /// Path parameter: clientid
    pub clientid: String,
    /// Request body
    pub body: SubscribeBody,
}
impl Default for UnsubscribeClientBearerRequest {
    fn default() -> Self {
        Self {
            clientid: String::new(),
            body: Default::default(),
        }
    }
}
impl UnsubscribeClientBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(clientid: impl Into<String>, body: SubscribeBody) -> Self {
        Self {
            clientid: clientid.into(),
            body,
        }
    }
}
impl UnsubscribeClientBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/clients/{}/unsubscribe", self.clientid);
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListSubscriptions` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListSubscriptionsBearerRequest;
///
/// let request = ListSubscriptionsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListSubscriptionsBearerRequest {}
impl ListSubscriptionsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/subscriptions".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `Publish` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{PublishBearerRequest, PublishBody};
///
/// let body = PublishBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = PublishBearerRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublishBearerRequest {
    /// Request body
    pub body: PublishBody,
}
impl Default for PublishBearerRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl PublishBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: PublishBody) -> Self {
        Self { body }
    }
}
impl PublishBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/publish".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `PublishBulk` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{PublishBulkBearerRequest, PublishBatchBody};
///
/// let body = PublishBatchBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = PublishBulkBearerRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublishBulkBearerRequest {
    /// Request body
    pub body: PublishBatchBody,
}
impl Default for PublishBulkBearerRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl PublishBulkBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: PublishBatchBody) -> Self {
        Self { body }
    }
}
impl PublishBulkBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/publish/bulk".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListRules` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListRulesBearerRequest;
///
/// let request = ListRulesBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListRulesBearerRequest {}
impl ListRulesBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/rules".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `CreateRule` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{CreateRuleBearerRequest, CreateRuleBody};
///
/// let body = CreateRuleBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateRuleBearerRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateRuleBearerRequest {
    /// Request body
    pub body: CreateRuleBody,
}
impl Default for CreateRuleBearerRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl CreateRuleBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CreateRuleBody) -> Self {
        Self { body }
    }
}
impl CreateRuleBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/rules".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `GetRule` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetRuleBearerRequest;
///
/// let request = GetRuleBearerRequest::new("id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetRuleBearerRequest {
    /// Path parameter: id
    pub id: String,
}
impl GetRuleBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>) -> Self {
        Self { id: id.into() }
    }
}
impl GetRuleBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/rules/{}", self.id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `UpdateRule` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{UpdateRuleBearerRequest, CreateRuleBody};
///
/// let body = CreateRuleBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = UpdateRuleBearerRequest::new("id_value", body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateRuleBearerRequest {
    /// Path parameter: id
    pub id: String,
    /// Request body
    pub body: CreateRuleBody,
}
impl Default for UpdateRuleBearerRequest {
    fn default() -> Self {
        Self {
            id: String::new(),
            body: Default::default(),
        }
    }
}
impl UpdateRuleBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(id: impl Into<String>, body: CreateRuleBody) -> Self {
        Self { id: id.into(), body }
    }
}
impl UpdateRuleBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/rules/{}", self.id);
        Ok((
            "PUT",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `DeleteRule` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::DeleteRuleBearerRequest;
///
/// let request = DeleteRuleBearerRequest::new("id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteRuleBearerRequest {
    /// Path parameter: id
    pub id: String,
}
impl DeleteRuleBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>) -> Self {
        Self { id: id.into() }
    }
}
impl DeleteRuleBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/rules/{}", self.id);
        Ok(("DELETE", path, None, vec![]))
    }
}
/// Request for `TestRule` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{TestRuleBearerRequest, TestRuleBody};
///
/// let body = TestRuleBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = TestRuleBearerRequest::new("id_value", body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestRuleBearerRequest {
    /// Path parameter: id
    pub id: String,
    /// Request body
    pub body: TestRuleBody,
}
impl Default for TestRuleBearerRequest {
    fn default() -> Self {
        Self {
            id: String::new(),
            body: Default::default(),
        }
    }
}
impl TestRuleBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(id: impl Into<String>, body: TestRuleBody) -> Self {
        Self { id: id.into(), body }
    }
}
impl TestRuleBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/rules/{}/test", self.id);
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListAuthenticators` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListAuthenticatorsBearerRequest;
///
/// let request = ListAuthenticatorsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListAuthenticatorsBearerRequest {}
impl ListAuthenticatorsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/authentication".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetAuthenticator` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetAuthenticatorBearerRequest;
///
/// let request = GetAuthenticatorBearerRequest::new("id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetAuthenticatorBearerRequest {
    /// Path parameter: id
    pub id: String,
}
impl GetAuthenticatorBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>) -> Self {
        Self { id: id.into() }
    }
}
impl GetAuthenticatorBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/authentication/{}", self.id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListAuthUsers` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListAuthUsersBearerRequest;
///
/// let request = ListAuthUsersBearerRequest::new("id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListAuthUsersBearerRequest {
    /// Path parameter: id
    pub id: String,
}
impl ListAuthUsersBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>) -> Self {
        Self { id: id.into() }
    }
}
impl ListAuthUsersBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/authentication/{}/users", self.id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `CreateAuthUser` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{CreateAuthUserBearerRequest, CreateAuthUserBody};
///
/// let body = CreateAuthUserBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateAuthUserBearerRequest::new("id_value", body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateAuthUserBearerRequest {
    /// Path parameter: id
    pub id: String,
    /// Request body
    pub body: CreateAuthUserBody,
}
impl Default for CreateAuthUserBearerRequest {
    fn default() -> Self {
        Self {
            id: String::new(),
            body: Default::default(),
        }
    }
}
impl CreateAuthUserBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(id: impl Into<String>, body: CreateAuthUserBody) -> Self {
        Self { id: id.into(), body }
    }
}
impl CreateAuthUserBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/authentication/{}/users", self.id);
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `DeleteAuthUser` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::DeleteAuthUserBearerRequest;
///
/// let request = DeleteAuthUserBearerRequest::new("id_value", "user_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteAuthUserBearerRequest {
    /// Path parameter: id
    pub id: String,
    /// Path parameter: user_id
    pub user_id: String,
}
impl DeleteAuthUserBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>, user_id: impl Into<String>) -> Self {
        Self {
            id: id.into(),
            user_id: user_id.into(),
        }
    }
}
impl DeleteAuthUserBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/authentication/{}/users/{}", self.id, self.user_id);
        Ok(("DELETE", path, None, vec![]))
    }
}
/// Request for `ListAuthzSources` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListAuthzSourcesBearerRequest;
///
/// let request = ListAuthzSourcesBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListAuthzSourcesBearerRequest {}
impl ListAuthzSourcesBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/authorization/sources".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListListeners` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListListenersBearerRequest;
///
/// let request = ListListenersBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListListenersBearerRequest {}
impl ListListenersBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/listeners".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetListener` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetListenerBearerRequest;
///
/// let request = GetListenerBearerRequest::new("id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetListenerBearerRequest {
    /// Path parameter: id
    pub id: String,
}
impl GetListenerBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(id: impl Into<String>) -> Self {
        Self { id: id.into() }
    }
}
impl GetListenerBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/listeners/{}", self.id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListMetrics` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListMetricsBearerRequest;
///
/// let request = ListMetricsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListMetricsBearerRequest {}
impl ListMetricsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/metrics".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListStats` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListStatsBearerRequest;
///
/// let request = ListStatsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListStatsBearerRequest {}
impl ListStatsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/stats".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetPrometheus` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetPrometheusBearerRequest;
///
/// let request = GetPrometheusBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetPrometheusBearerRequest {}
impl GetPrometheusBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/prometheus/stats".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListTopics` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListTopicsBearerRequest;
///
/// let request = ListTopicsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListTopicsBearerRequest {}
impl ListTopicsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/topics".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListRetained` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListRetainedBearerRequest;
///
/// let request = ListRetainedBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListRetainedBearerRequest {}
impl ListRetainedBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/retainer/messages".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetRetained` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::GetRetainedBearerRequest;
///
/// let request = GetRetainedBearerRequest::new("topic_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetRetainedBearerRequest {
    /// Path parameter: topic
    pub topic: String,
}
impl GetRetainedBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(topic: impl Into<String>) -> Self {
        Self { topic: topic.into() }
    }
}
impl GetRetainedBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/retainer/messages/{}", self.topic);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `DeleteRetained` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::DeleteRetainedBearerRequest;
///
/// let request = DeleteRetainedBearerRequest::new("topic_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteRetainedBearerRequest {
    /// Path parameter: topic
    pub topic: String,
}
impl DeleteRetainedBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(topic: impl Into<String>) -> Self {
        Self { topic: topic.into() }
    }
}
impl DeleteRetainedBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/retainer/messages/{}", self.topic);
        Ok(("DELETE", path, None, vec![]))
    }
}
/// Request for `ListAlarms` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListAlarmsBearerRequest;
///
/// let request = ListAlarmsBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListAlarmsBearerRequest {}
impl ListAlarmsBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/alarms".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListBanned` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::ListBannedBearerRequest;
///
/// let request = ListBannedBearerRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListBannedBearerRequest {}
impl ListBannedBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/banned".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `CreateBan` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::{CreateBanBearerRequest, CreateBanBody};
///
/// let body = CreateBanBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateBanBearerRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateBanBearerRequest {
    /// Request body
    pub body: CreateBanBody,
}
impl Default for CreateBanBearerRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl CreateBanBearerRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CreateBanBody) -> Self {
        Self { body }
    }
}
impl CreateBanBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/banned".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `DeleteBan` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::emqx::DeleteBanBearerRequest;
///
/// let request = DeleteBanBearerRequest::new("ban_type_value", "who_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteBanBearerRequest {
    /// Path parameter: ban_type
    pub ban_type: String,
    /// Path parameter: who
    pub who: String,
}
impl DeleteBanBearerRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(ban_type: impl Into<String>, who: impl Into<String>) -> Self {
        Self {
            ban_type: ban_type.into(),
            who: who.into(),
        }
    }
}
impl DeleteBanBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/banned/{}/{}", self.ban_type, self.who);
        Ok(("DELETE", path, None, vec![]))
    }
}
/// Request enum for EmqxBearer API.
///
/// Each variant wraps a strongly-typed request struct.
pub enum EmqxBearerRequest {
    /// Authenticate with username/password and receive a JWT token
    Login(LoginBearerRequest),
    /// Invalidate the current bearer token
    Logout(LogoutBearerRequest),
    /// List all nodes in the EMQX cluster
    ListNodes(ListNodesBearerRequest),
    /// Get detailed information about a specific node
    GetNode(GetNodeBearerRequest),
    /// Get cluster status and node membership
    GetCluster(GetClusterBearerRequest),
    /// List connected MQTT clients with pagination
    ListClients(ListClientsBearerRequest),
    /// Get detailed information about a specific client
    GetClient(GetClientBearerRequest),
    /// Forcefully disconnect a client from the broker
    DisconnectClient(DisconnectClientBearerRequest),
    /// Create a subscription for a connected client
    SubscribeClient(SubscribeClientBearerRequest),
    /// Remove a subscription from a connected client
    UnsubscribeClient(UnsubscribeClientBearerRequest),
    /// List all subscriptions across the cluster
    ListSubscriptions(ListSubscriptionsBearerRequest),
    /// Publish an MQTT message to a topic
    Publish(PublishBearerRequest),
    /// Publish multiple MQTT messages in a single request
    PublishBulk(PublishBulkBearerRequest),
    /// List all rules in the rules engine
    ListRules(ListRulesBearerRequest),
    /// Create a new rule in the rules engine
    CreateRule(CreateRuleBearerRequest),
    /// Get details of a specific rule
    GetRule(GetRuleBearerRequest),
    /// Update an existing rule
    UpdateRule(UpdateRuleBearerRequest),
    /// Delete a rule from the rules engine
    DeleteRule(DeleteRuleBearerRequest),
    /// Test a rule with sample data
    TestRule(TestRuleBearerRequest),
    /// List all configured authentication providers
    ListAuthenticators(ListAuthenticatorsBearerRequest),
    /// Get details of a specific authenticator
    GetAuthenticator(GetAuthenticatorBearerRequest),
    /// List users in a built-in database authenticator
    ListAuthUsers(ListAuthUsersBearerRequest),
    /// Create a new user in a built-in database authenticator
    CreateAuthUser(CreateAuthUserBearerRequest),
    /// Delete a user from a built-in database authenticator
    DeleteAuthUser(DeleteAuthUserBearerRequest),
    /// List all authorization sources
    ListAuthzSources(ListAuthzSourcesBearerRequest),
    /// List all configured listeners
    ListListeners(ListListenersBearerRequest),
    /// Get details of a specific listener
    GetListener(GetListenerBearerRequest),
    /// Get broker metrics for all nodes
    ListMetrics(ListMetricsBearerRequest),
    /// Get broker statistics for all nodes
    ListStats(ListStatsBearerRequest),
    /// Get metrics in Prometheus format
    GetPrometheus(GetPrometheusBearerRequest),
    /// List active topics in the broker
    ListTopics(ListTopicsBearerRequest),
    /// List retained messages with pagination
    ListRetained(ListRetainedBearerRequest),
    /// Get a specific retained message by topic
    GetRetained(GetRetainedBearerRequest),
    /// Delete a retained message
    DeleteRetained(DeleteRetainedBearerRequest),
    /// List active alarms
    ListAlarms(ListAlarmsBearerRequest),
    /// List all banned clients, usernames, and hosts
    ListBanned(ListBannedBearerRequest),
    /// Ban a client, username, or host
    CreateBan(CreateBanBearerRequest),
    /// Remove a ban by type (clientid, username, peerhost) and value
    DeleteBan(DeleteBanBearerRequest),
}
impl EmqxBearerRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        match self {
            Self::Login(req) => req.into_parts(),
            Self::Logout(req) => req.into_parts(),
            Self::ListNodes(req) => req.into_parts(),
            Self::GetNode(req) => req.into_parts(),
            Self::GetCluster(req) => req.into_parts(),
            Self::ListClients(req) => req.into_parts(),
            Self::GetClient(req) => req.into_parts(),
            Self::DisconnectClient(req) => req.into_parts(),
            Self::SubscribeClient(req) => req.into_parts(),
            Self::UnsubscribeClient(req) => req.into_parts(),
            Self::ListSubscriptions(req) => req.into_parts(),
            Self::Publish(req) => req.into_parts(),
            Self::PublishBulk(req) => req.into_parts(),
            Self::ListRules(req) => req.into_parts(),
            Self::CreateRule(req) => req.into_parts(),
            Self::GetRule(req) => req.into_parts(),
            Self::UpdateRule(req) => req.into_parts(),
            Self::DeleteRule(req) => req.into_parts(),
            Self::TestRule(req) => req.into_parts(),
            Self::ListAuthenticators(req) => req.into_parts(),
            Self::GetAuthenticator(req) => req.into_parts(),
            Self::ListAuthUsers(req) => req.into_parts(),
            Self::CreateAuthUser(req) => req.into_parts(),
            Self::DeleteAuthUser(req) => req.into_parts(),
            Self::ListAuthzSources(req) => req.into_parts(),
            Self::ListListeners(req) => req.into_parts(),
            Self::GetListener(req) => req.into_parts(),
            Self::ListMetrics(req) => req.into_parts(),
            Self::ListStats(req) => req.into_parts(),
            Self::GetPrometheus(req) => req.into_parts(),
            Self::ListTopics(req) => req.into_parts(),
            Self::ListRetained(req) => req.into_parts(),
            Self::GetRetained(req) => req.into_parts(),
            Self::DeleteRetained(req) => req.into_parts(),
            Self::ListAlarms(req) => req.into_parts(),
            Self::ListBanned(req) => req.into_parts(),
            Self::CreateBan(req) => req.into_parts(),
            Self::DeleteBan(req) => req.into_parts(),
        }
    }
}
impl From<LoginBearerRequest> for EmqxBearerRequest {
    fn from(req: LoginBearerRequest) -> Self {
        Self::Login(req)
    }
}
impl From<LogoutBearerRequest> for EmqxBearerRequest {
    fn from(req: LogoutBearerRequest) -> Self {
        Self::Logout(req)
    }
}
impl From<ListNodesBearerRequest> for EmqxBearerRequest {
    fn from(req: ListNodesBearerRequest) -> Self {
        Self::ListNodes(req)
    }
}
impl From<GetNodeBearerRequest> for EmqxBearerRequest {
    fn from(req: GetNodeBearerRequest) -> Self {
        Self::GetNode(req)
    }
}
impl From<GetClusterBearerRequest> for EmqxBearerRequest {
    fn from(req: GetClusterBearerRequest) -> Self {
        Self::GetCluster(req)
    }
}
impl From<ListClientsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListClientsBearerRequest) -> Self {
        Self::ListClients(req)
    }
}
impl From<GetClientBearerRequest> for EmqxBearerRequest {
    fn from(req: GetClientBearerRequest) -> Self {
        Self::GetClient(req)
    }
}
impl From<DisconnectClientBearerRequest> for EmqxBearerRequest {
    fn from(req: DisconnectClientBearerRequest) -> Self {
        Self::DisconnectClient(req)
    }
}
impl From<SubscribeClientBearerRequest> for EmqxBearerRequest {
    fn from(req: SubscribeClientBearerRequest) -> Self {
        Self::SubscribeClient(req)
    }
}
impl From<UnsubscribeClientBearerRequest> for EmqxBearerRequest {
    fn from(req: UnsubscribeClientBearerRequest) -> Self {
        Self::UnsubscribeClient(req)
    }
}
impl From<ListSubscriptionsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListSubscriptionsBearerRequest) -> Self {
        Self::ListSubscriptions(req)
    }
}
impl From<PublishBearerRequest> for EmqxBearerRequest {
    fn from(req: PublishBearerRequest) -> Self {
        Self::Publish(req)
    }
}
impl From<PublishBulkBearerRequest> for EmqxBearerRequest {
    fn from(req: PublishBulkBearerRequest) -> Self {
        Self::PublishBulk(req)
    }
}
impl From<ListRulesBearerRequest> for EmqxBearerRequest {
    fn from(req: ListRulesBearerRequest) -> Self {
        Self::ListRules(req)
    }
}
impl From<CreateRuleBearerRequest> for EmqxBearerRequest {
    fn from(req: CreateRuleBearerRequest) -> Self {
        Self::CreateRule(req)
    }
}
impl From<GetRuleBearerRequest> for EmqxBearerRequest {
    fn from(req: GetRuleBearerRequest) -> Self {
        Self::GetRule(req)
    }
}
impl From<UpdateRuleBearerRequest> for EmqxBearerRequest {
    fn from(req: UpdateRuleBearerRequest) -> Self {
        Self::UpdateRule(req)
    }
}
impl From<DeleteRuleBearerRequest> for EmqxBearerRequest {
    fn from(req: DeleteRuleBearerRequest) -> Self {
        Self::DeleteRule(req)
    }
}
impl From<TestRuleBearerRequest> for EmqxBearerRequest {
    fn from(req: TestRuleBearerRequest) -> Self {
        Self::TestRule(req)
    }
}
impl From<ListAuthenticatorsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListAuthenticatorsBearerRequest) -> Self {
        Self::ListAuthenticators(req)
    }
}
impl From<GetAuthenticatorBearerRequest> for EmqxBearerRequest {
    fn from(req: GetAuthenticatorBearerRequest) -> Self {
        Self::GetAuthenticator(req)
    }
}
impl From<ListAuthUsersBearerRequest> for EmqxBearerRequest {
    fn from(req: ListAuthUsersBearerRequest) -> Self {
        Self::ListAuthUsers(req)
    }
}
impl From<CreateAuthUserBearerRequest> for EmqxBearerRequest {
    fn from(req: CreateAuthUserBearerRequest) -> Self {
        Self::CreateAuthUser(req)
    }
}
impl From<DeleteAuthUserBearerRequest> for EmqxBearerRequest {
    fn from(req: DeleteAuthUserBearerRequest) -> Self {
        Self::DeleteAuthUser(req)
    }
}
impl From<ListAuthzSourcesBearerRequest> for EmqxBearerRequest {
    fn from(req: ListAuthzSourcesBearerRequest) -> Self {
        Self::ListAuthzSources(req)
    }
}
impl From<ListListenersBearerRequest> for EmqxBearerRequest {
    fn from(req: ListListenersBearerRequest) -> Self {
        Self::ListListeners(req)
    }
}
impl From<GetListenerBearerRequest> for EmqxBearerRequest {
    fn from(req: GetListenerBearerRequest) -> Self {
        Self::GetListener(req)
    }
}
impl From<ListMetricsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListMetricsBearerRequest) -> Self {
        Self::ListMetrics(req)
    }
}
impl From<ListStatsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListStatsBearerRequest) -> Self {
        Self::ListStats(req)
    }
}
impl From<GetPrometheusBearerRequest> for EmqxBearerRequest {
    fn from(req: GetPrometheusBearerRequest) -> Self {
        Self::GetPrometheus(req)
    }
}
impl From<ListTopicsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListTopicsBearerRequest) -> Self {
        Self::ListTopics(req)
    }
}
impl From<ListRetainedBearerRequest> for EmqxBearerRequest {
    fn from(req: ListRetainedBearerRequest) -> Self {
        Self::ListRetained(req)
    }
}
impl From<GetRetainedBearerRequest> for EmqxBearerRequest {
    fn from(req: GetRetainedBearerRequest) -> Self {
        Self::GetRetained(req)
    }
}
impl From<DeleteRetainedBearerRequest> for EmqxBearerRequest {
    fn from(req: DeleteRetainedBearerRequest) -> Self {
        Self::DeleteRetained(req)
    }
}
impl From<ListAlarmsBearerRequest> for EmqxBearerRequest {
    fn from(req: ListAlarmsBearerRequest) -> Self {
        Self::ListAlarms(req)
    }
}
impl From<ListBannedBearerRequest> for EmqxBearerRequest {
    fn from(req: ListBannedBearerRequest) -> Self {
        Self::ListBanned(req)
    }
}
impl From<CreateBanBearerRequest> for EmqxBearerRequest {
    fn from(req: CreateBanBearerRequest) -> Self {
        Self::CreateBan(req)
    }
}
impl From<DeleteBanBearerRequest> for EmqxBearerRequest {
    fn from(req: DeleteBanBearerRequest) -> Self {
        Self::DeleteBan(req)
    }
}
/// EMQX Broker REST API with Bearer Token authentication (JWT) client.
pub struct EmqxBearer {
    client: reqwest::Client,
    base_url: String,
    /// Environment variable names for authentication credentials.
    env_auth: Vec<String>,
    /// Authentication strategy for this API client.
    auth_strategy: schematic_define::AuthStrategy,
    /// Environment variable for Basic auth username.
    env_username: Option<String>,
    /// Default HTTP headers to include with every request.
    headers: Vec<(String, String)>,
}
impl EmqxBearer {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "http://localhost:18083/api/v5";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec!["EMQX_TOKEN".to_string()],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
            env_auth: vec!["EMQX_TOKEN".to_string()],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec!["EMQX_TOKEN".to_string()],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
            env_auth: vec!["EMQX_TOKEN".to_string()],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a variant of this API client with different configuration.
    ///
    /// This method clones the underlying HTTP client and allows customizing:
    /// - Base URL (for proxies, mock servers, or different environments)
    /// - Authentication credentials (different env var names)
    /// - Authentication strategy (via `UpdateStrategy`)
    ///
    /// ## Arguments
    ///
    /// * `base_url` - New base URL for this variant
    /// * `env_auth` - New environment variable names for credentials
    /// * `strategy` - How to update the auth strategy:
    ///   - `UpdateStrategy::NoChange` - Keep current auth strategy
    ///   - `UpdateStrategy::ChangeTo(auth)` - Use specified auth strategy
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// use schematic_define::UpdateStrategy;
    ///
    /// let api = Api::new();
    ///
    /// // Create a variant pointing to a staging server
    /// let staging = api.variant(
    ///     "https://staging.api.com/v1",
    ///     vec!["STAGING_API_KEY".to_string()],
    ///     UpdateStrategy::NoChange,
    /// );
    ///
    /// // Create a variant with different auth
    /// let other = api.variant(
    ///     "https://other.api.com/v1",
    ///     vec!["OTHER_TOKEN".to_string()],
    ///     UpdateStrategy::ChangeTo(schematic_define::AuthStrategy::ApiKey {
    ///         header: "X-API-Key".to_string(),
    ///     }),
    /// );
    /// ```
    pub fn variant(
        &self,
        base_url: impl Into<String>,
        env_auth: Vec<String>,
        strategy: schematic_define::UpdateStrategy,
    ) -> Self {
        let auth_strategy = match strategy {
            schematic_define::UpdateStrategy::NoChange => self.auth_strategy.clone(),
            schematic_define::UpdateStrategy::ChangeTo(auth) => auth,
        };
        Self {
            client: self.client.clone(),
            base_url: base_url.into(),
            env_auth,
            auth_strategy,
            env_username: self.env_username.clone(),
            headers: self.headers.clone(),
        }
    }
}
impl Default for EmqxBearer {
    fn default() -> Self {
        Self::new()
    }
}
impl EmqxBearer {
    /// Builds and sends an HTTP request, returning the raw response.
    ///
    /// This is an internal helper method used by the public request methods.
    async fn build_and_send_request(
        &self,
        request: impl Into<EmqxBearerRequest>,
    ) -> Result<reqwest::Response, SchematicError> {
        let request = request.into();
        let (method, path, body, endpoint_headers) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        match &self.auth_strategy {
            schematic_define::AuthStrategy::None => {}
            schematic_define::AuthStrategy::BearerToken { header } => {
                let header_name = header.as_deref().unwrap_or("Authorization");
                let token = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder
                    .header(header_name, format!("Bearer {}", token));
            }
            schematic_define::AuthStrategy::ApiKey { header } => {
                let key = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder.header(header.as_str(), key);
            }
            schematic_define::AuthStrategy::Basic => {
                let username_env = self.env_username.as_deref().unwrap_or("USERNAME");
                let password_env = self
                    .env_auth
                    .first()
                    .map(String::as_str)
                    .unwrap_or("PASSWORD");
                let username = std::env::var(username_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![username_env.to_string()],
                    })?;
                let password = std::env::var(password_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![password_env.to_string()],
                    })?;
                req_builder = req_builder.basic_auth(username, Some(password));
            }
        }
        let merged_headers = Self::merge_headers(&self.headers, &endpoint_headers);
        for (key, value) in merged_headers {
            req_builder = req_builder.header(key.as_str(), value.as_str());
        }
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        Ok(response)
    }
    /// Merges API-level and endpoint-level headers.
    ///
    /// Endpoint headers override API headers for matching keys (case-insensitive).
    /// Returns a new Vec with the merged headers.
    fn merge_headers(
        api_headers: &[(String, String)],
        endpoint_headers: &[(String, String)],
    ) -> Vec<(String, String)> {
        let mut result: Vec<(String, String)> = Vec::new();
        for (api_key, api_value) in api_headers {
            let has_override = endpoint_headers
                .iter()
                .any(|(k, _)| k.eq_ignore_ascii_case(api_key));
            if !has_override {
                result.push((api_key.clone(), api_value.clone()));
            }
        }
        for (key, value) in endpoint_headers {
            result.push((key.clone(), value.clone()));
        }
        result
    }
    /// Executes an API request expecting a JSON response.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<EmqxBearerRequest>,
    ) -> Result<T, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let result = response.json::<T>().await?;
        Ok(result)
    }
    /// Executes an API request expecting a plain text response.
    ///
    /// Returns the response body as a String.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    pub async fn request_text(
        &self,
        request: impl Into<EmqxBearerRequest>,
    ) -> Result<String, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let text = response.text().await?;
        Ok(text)
    }
    /// Executes an API request expecting no response body.
    ///
    /// Use this for endpoints that return 204 No Content or where
    /// the response body should be ignored.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    pub async fn request_empty(
        &self,
        request: impl Into<EmqxBearerRequest>,
    ) -> Result<(), SchematicError> {
        let _response = self.build_and_send_request(request).await?;
        Ok(())
    }
    /// Convenience method for the `Logout` endpoint.
    ///
    /// Invalidate the current bearer token
    pub async fn logout(
        &self,
        request: LogoutBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `DisconnectClient` endpoint.
    ///
    /// Forcefully disconnect a client from the broker
    pub async fn disconnect_client(
        &self,
        request: DisconnectClientBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `SubscribeClient` endpoint.
    ///
    /// Create a subscription for a connected client
    pub async fn subscribe_client(
        &self,
        request: SubscribeClientBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `UnsubscribeClient` endpoint.
    ///
    /// Remove a subscription from a connected client
    pub async fn unsubscribe_client(
        &self,
        request: UnsubscribeClientBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `Publish` endpoint.
    ///
    /// Publish an MQTT message to a topic
    pub async fn publish(
        &self,
        request: PublishBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `PublishBulk` endpoint.
    ///
    /// Publish multiple MQTT messages in a single request
    pub async fn publish_bulk(
        &self,
        request: PublishBulkBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `DeleteRule` endpoint.
    ///
    /// Delete a rule from the rules engine
    pub async fn delete_rule(
        &self,
        request: DeleteRuleBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `DeleteAuthUser` endpoint.
    ///
    /// Delete a user from a built-in database authenticator
    pub async fn delete_auth_user(
        &self,
        request: DeleteAuthUserBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `GetPrometheus` endpoint.
    ///
    /// Get metrics in Prometheus format
    pub async fn get_prometheus(
        &self,
        request: GetPrometheusBearerRequest,
    ) -> Result<String, SchematicError> {
        self.request_text(request).await
    }
    /// Convenience method for the `DeleteRetained` endpoint.
    ///
    /// Delete a retained message
    pub async fn delete_retained(
        &self,
        request: DeleteRetainedBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
    /// Convenience method for the `DeleteBan` endpoint.
    ///
    /// Remove a ban by type (clientid, username, peerhost) and value
    pub async fn delete_ban(
        &self,
        request: DeleteBanBearerRequest,
    ) -> Result<(), SchematicError> {
        self.request_empty(request).await
    }
}
