// This code was automatically generated by schematic-gen. Do not edit manually.

/*! Generated API client for [HuggingFaceHub](https://huggingface.co/docs/hub/api).

 Hugging Face Hub API for model discovery, dataset management, spaces, and repository operations*/
//!
/*! ## Authentication

 Uses Bearer token authentication via the `Authorization` header. Set via environment variable: `HF_TOKEN` or `HUGGING_FACE_API_KEY` or `HF_API_KEY`.*/
//!
/*! ## Features

 **DELETE**:
 - `DeleteRepo` - Deletes a repository

 **GET**:
 - `ListModels` - Lists models with optional filtering. Query params: search, author, filter, sort, direction, limit, full, config
 - `GetModel` - Gets detailed information about a specific model
 - `ListModelFiles` - Lists files in a model repository at a specific revision
 - `GetModelFile` - Gets file metadata for a specific file in a model repository
 - `ListModelCommits` - Lists commits for a model repository
 - `GetModelReadme` - Gets the README file content for a model
 - `ListModelDiscussions` - Lists discussions for a model repository
 - `GetModelCard` - Gets the model card file content
 - `ListDatasets` - Lists datasets with optional filtering. Query params: search, author, filter, sort, direction, limit, full
 - `GetDataset` - Gets detailed information about a specific dataset
 - `ListDatasetFiles` - Lists files in a dataset repository at a specific revision
 - `GetDatasetFile` - Gets file metadata for a specific file in a dataset repository
 - `ListDatasetCommits` - Lists commits for a dataset repository
 - `GetDatasetReadme` - Gets the README file content for a dataset
 - `ListSpaces` - Lists spaces with optional filtering. Query params: search, author, filter, sort, direction, limit
 - `GetSpace` - Gets detailed information about a specific space
 - `ListSpaceFiles` - Lists files in a space repository at a specific revision
 - `GetSpaceFile` - Gets file metadata for a specific file in a space repository
 - `WhoAmI` - Gets information about the authenticated user
 - `GetUser` - Gets public information about a user
 - `ListUserRepos` - Lists repositories owned by a user
 - `GetUserCollections` - Gets collections created by a user

 **POST**:
 - `CreateRepo` - Creates a new repository (model, dataset, or space)
 - `MoveRepo` - Moves/renames a repository

 **PUT**:
 - `UpdateRepoSettings` - Updates repository settings (visibility, gated access, etc.)
*/
//!
/*! ## Example

 ```ignore
 use schematic_schema::prelude::*;

 #[tokio::main]
 async fn main() -> Result<(), SchematicError> {
     let client = HuggingFaceHub::new();
     let response = client.list_models().await?;
     println!("{:?}", response);
     Ok(())
 }
 ```*/
use serde::{Deserialize, Serialize};
pub use schematic_definitions::huggingface::*;
use crate::shared::{RequestParts, SchematicError};
/// Request for `ListModels` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListModelsRequest;
///
/// let request = ListModelsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelsRequest {}
impl ListModelsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/models".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetModelRequest;
///
/// let request = GetModelRequest::new("repo_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetModelRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
}
impl GetModelRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>) -> Self {
        Self { repo_id: repo_id.into() }
    }
}
impl GetModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/models/{}", self.repo_id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListModelFiles` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListModelFilesRequest;
///
/// let request = ListModelFilesRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelFilesRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl ListModelFilesRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl ListModelFilesRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/models/{}/tree/{}", self.repo_id, self.revision);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetModelFile` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetModelFileRequest;
///
/// let request = GetModelFileRequest::new("repo_id_value", "revision_value", "path_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetModelFileRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
    /// Path parameter: path
    pub path: String,
}
impl GetModelFileRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(
        repo_id: impl Into<String>,
        revision: impl Into<String>,
        path: impl Into<String>,
    ) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
            path: path.into(),
        }
    }
}
impl GetModelFileRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/models/{}/blob/{}/{}", self.repo_id, self.revision, self.path
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListModelCommits` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListModelCommitsRequest;
///
/// let request = ListModelCommitsRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelCommitsRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl ListModelCommitsRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl ListModelCommitsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/models/{}/commits/{}", self.repo_id, self.revision);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetModelReadme` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetModelReadmeRequest;
///
/// let request = GetModelReadmeRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetModelReadmeRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl GetModelReadmeRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl GetModelReadmeRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/models/{}/resolve/{}/README.md", self.repo_id, self.revision
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListModelDiscussions` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListModelDiscussionsRequest;
///
/// let request = ListModelDiscussionsRequest::new("repo_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelDiscussionsRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
}
impl ListModelDiscussionsRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>) -> Self {
        Self { repo_id: repo_id.into() }
    }
}
impl ListModelDiscussionsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/models/{}/discussions", self.repo_id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetModelCard` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetModelCardRequest;
///
/// let request = GetModelCardRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetModelCardRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl GetModelCardRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl GetModelCardRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/models/{}/resolve/{}/model_card.md", self.repo_id, self.revision
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListDatasets` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListDatasetsRequest;
///
/// let request = ListDatasetsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListDatasetsRequest {}
impl ListDatasetsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/datasets".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetDataset` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetDatasetRequest;
///
/// let request = GetDatasetRequest::new("repo_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetDatasetRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
}
impl GetDatasetRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>) -> Self {
        Self { repo_id: repo_id.into() }
    }
}
impl GetDatasetRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/datasets/{}", self.repo_id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListDatasetFiles` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListDatasetFilesRequest;
///
/// let request = ListDatasetFilesRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListDatasetFilesRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl ListDatasetFilesRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl ListDatasetFilesRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/datasets/{}/tree/{}", self.repo_id, self.revision);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetDatasetFile` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetDatasetFileRequest;
///
/// let request = GetDatasetFileRequest::new("repo_id_value", "revision_value", "path_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetDatasetFileRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
    /// Path parameter: path
    pub path: String,
}
impl GetDatasetFileRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(
        repo_id: impl Into<String>,
        revision: impl Into<String>,
        path: impl Into<String>,
    ) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
            path: path.into(),
        }
    }
}
impl GetDatasetFileRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/datasets/{}/blob/{}/{}", self.repo_id, self.revision, self.path
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListDatasetCommits` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListDatasetCommitsRequest;
///
/// let request = ListDatasetCommitsRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListDatasetCommitsRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl ListDatasetCommitsRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl ListDatasetCommitsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/datasets/{}/commits/{}", self.repo_id, self.revision);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetDatasetReadme` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetDatasetReadmeRequest;
///
/// let request = GetDatasetReadmeRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetDatasetReadmeRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl GetDatasetReadmeRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl GetDatasetReadmeRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/datasets/{}/resolve/{}/README.md", self.repo_id, self.revision
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListSpaces` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListSpacesRequest;
///
/// let request = ListSpacesRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListSpacesRequest {}
impl ListSpacesRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/spaces".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetSpace` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetSpaceRequest;
///
/// let request = GetSpaceRequest::new("repo_id_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetSpaceRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
}
impl GetSpaceRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>) -> Self {
        Self { repo_id: repo_id.into() }
    }
}
impl GetSpaceRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/spaces/{}", self.repo_id);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListSpaceFiles` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListSpaceFilesRequest;
///
/// let request = ListSpaceFilesRequest::new("repo_id_value", "revision_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListSpaceFilesRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
}
impl ListSpaceFilesRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(repo_id: impl Into<String>, revision: impl Into<String>) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
        }
    }
}
impl ListSpaceFilesRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/spaces/{}/tree/{}", self.repo_id, self.revision);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetSpaceFile` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetSpaceFileRequest;
///
/// let request = GetSpaceFileRequest::new("repo_id_value", "revision_value", "path_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetSpaceFileRequest {
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Path parameter: revision
    pub revision: String,
    /// Path parameter: path
    pub path: String,
}
impl GetSpaceFileRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(
        repo_id: impl Into<String>,
        revision: impl Into<String>,
        path: impl Into<String>,
    ) -> Self {
        Self {
            repo_id: repo_id.into(),
            revision: revision.into(),
            path: path.into(),
        }
    }
}
impl GetSpaceFileRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!(
            "/spaces/{}/blob/{}/{}", self.repo_id, self.revision, self.path
        );
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `CreateRepo` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::{CreateRepoRequest, CreateRepoBody};
///
/// let body = CreateRepoBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateRepoRequest::new(body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CreateRepoRequest {
    /// Request body
    pub body: CreateRepoBody,
}
impl CreateRepoRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CreateRepoBody) -> Self {
        Self { body }
    }
}
impl CreateRepoRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/repos/create".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `DeleteRepo` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::{DeleteRepoRequest, DeleteRepoBody};
///
/// let body = DeleteRepoBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = DeleteRepoRequest::new(body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DeleteRepoRequest {
    /// Request body
    pub body: DeleteRepoBody,
}
impl DeleteRepoRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: DeleteRepoBody) -> Self {
        Self { body }
    }
}
impl DeleteRepoRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/repos/delete".to_string();
        Ok((
            "DELETE",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `UpdateRepoSettings` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::{UpdateRepoSettingsRequest, UpdateRepoSettingsBody};
///
/// let body = UpdateRepoSettingsBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = UpdateRepoSettingsRequest::new("repo_type_value", "repo_id_value", body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UpdateRepoSettingsRequest {
    /// Path parameter: repo_type
    pub repo_type: String,
    /// Path parameter: repo_id
    pub repo_id: String,
    /// Request body
    pub body: UpdateRepoSettingsBody,
}
impl UpdateRepoSettingsRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(
        repo_type: impl Into<String>,
        repo_id: impl Into<String>,
        body: UpdateRepoSettingsBody,
    ) -> Self {
        Self {
            repo_type: repo_type.into(),
            repo_id: repo_id.into(),
            body,
        }
    }
}
impl UpdateRepoSettingsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/repos/{}/{}/settings", self.repo_type, self.repo_id);
        Ok((
            "PUT",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `MoveRepo` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::{MoveRepoRequest, MoveRepoBody};
///
/// let body = MoveRepoBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = MoveRepoRequest::new(body);
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MoveRepoRequest {
    /// Request body
    pub body: MoveRepoBody,
}
impl MoveRepoRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: MoveRepoBody) -> Self {
        Self { body }
    }
}
impl MoveRepoRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/repos/move".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `WhoAmI` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::WhoAmIRequest;
///
/// let request = WhoAmIRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct WhoAmIRequest {}
impl WhoAmIRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = "/whoami-v2".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetUser` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetUserRequest;
///
/// let request = GetUserRequest::new("username_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetUserRequest {
    /// Path parameter: username
    pub username: String,
}
impl GetUserRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(username: impl Into<String>) -> Self {
        Self { username: username.into() }
    }
}
impl GetUserRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/users/{}", self.username);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ListUserRepos` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::ListUserReposRequest;
///
/// let request = ListUserReposRequest::new("username_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListUserReposRequest {
    /// Path parameter: username
    pub username: String,
}
impl ListUserReposRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(username: impl Into<String>) -> Self {
        Self { username: username.into() }
    }
}
impl ListUserReposRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/users/{}/repos", self.username);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `GetUserCollections` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::huggingface::GetUserCollectionsRequest;
///
/// let request = GetUserCollectionsRequest::new("username_value");
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GetUserCollectionsRequest {
    /// Path parameter: username
    pub username: String,
}
impl GetUserCollectionsRequest {
    /// Creates a new request with the required path parameters.
    pub fn new(username: impl Into<String>) -> Self {
        Self { username: username.into() }
    }
}
impl GetUserCollectionsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        let path = format!("/users/{}/collections", self.username);
        Ok(("GET", path, None, vec![]))
    }
}
/// Request enum for HuggingFaceHub API.
///
/// Each variant wraps a strongly-typed request struct.
pub enum HuggingFaceHubRequest {
    /// Lists models with optional filtering. Query params: search, author, filter, sort, direction, limit, full, config
    ListModels(ListModelsRequest),
    /// Gets detailed information about a specific model
    GetModel(GetModelRequest),
    /// Lists files in a model repository at a specific revision
    ListModelFiles(ListModelFilesRequest),
    /// Gets file metadata for a specific file in a model repository
    GetModelFile(GetModelFileRequest),
    /// Lists commits for a model repository
    ListModelCommits(ListModelCommitsRequest),
    /// Gets the README file content for a model
    GetModelReadme(GetModelReadmeRequest),
    /// Lists discussions for a model repository
    ListModelDiscussions(ListModelDiscussionsRequest),
    /// Gets the model card file content
    GetModelCard(GetModelCardRequest),
    /// Lists datasets with optional filtering. Query params: search, author, filter, sort, direction, limit, full
    ListDatasets(ListDatasetsRequest),
    /// Gets detailed information about a specific dataset
    GetDataset(GetDatasetRequest),
    /// Lists files in a dataset repository at a specific revision
    ListDatasetFiles(ListDatasetFilesRequest),
    /// Gets file metadata for a specific file in a dataset repository
    GetDatasetFile(GetDatasetFileRequest),
    /// Lists commits for a dataset repository
    ListDatasetCommits(ListDatasetCommitsRequest),
    /// Gets the README file content for a dataset
    GetDatasetReadme(GetDatasetReadmeRequest),
    /// Lists spaces with optional filtering. Query params: search, author, filter, sort, direction, limit
    ListSpaces(ListSpacesRequest),
    /// Gets detailed information about a specific space
    GetSpace(GetSpaceRequest),
    /// Lists files in a space repository at a specific revision
    ListSpaceFiles(ListSpaceFilesRequest),
    /// Gets file metadata for a specific file in a space repository
    GetSpaceFile(GetSpaceFileRequest),
    /// Creates a new repository (model, dataset, or space)
    CreateRepo(CreateRepoRequest),
    /// Deletes a repository
    DeleteRepo(DeleteRepoRequest),
    /// Updates repository settings (visibility, gated access, etc.)
    UpdateRepoSettings(UpdateRepoSettingsRequest),
    /// Moves/renames a repository
    MoveRepo(MoveRepoRequest),
    /// Gets information about the authenticated user
    WhoAmI(WhoAmIRequest),
    /// Gets public information about a user
    GetUser(GetUserRequest),
    /// Lists repositories owned by a user
    ListUserRepos(ListUserReposRequest),
    /// Gets collections created by a user
    GetUserCollections(GetUserCollectionsRequest),
}
impl HuggingFaceHubRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(self) -> Result<RequestParts, SchematicError> {
        match self {
            Self::ListModels(req) => req.into_parts(),
            Self::GetModel(req) => req.into_parts(),
            Self::ListModelFiles(req) => req.into_parts(),
            Self::GetModelFile(req) => req.into_parts(),
            Self::ListModelCommits(req) => req.into_parts(),
            Self::GetModelReadme(req) => req.into_parts(),
            Self::ListModelDiscussions(req) => req.into_parts(),
            Self::GetModelCard(req) => req.into_parts(),
            Self::ListDatasets(req) => req.into_parts(),
            Self::GetDataset(req) => req.into_parts(),
            Self::ListDatasetFiles(req) => req.into_parts(),
            Self::GetDatasetFile(req) => req.into_parts(),
            Self::ListDatasetCommits(req) => req.into_parts(),
            Self::GetDatasetReadme(req) => req.into_parts(),
            Self::ListSpaces(req) => req.into_parts(),
            Self::GetSpace(req) => req.into_parts(),
            Self::ListSpaceFiles(req) => req.into_parts(),
            Self::GetSpaceFile(req) => req.into_parts(),
            Self::CreateRepo(req) => req.into_parts(),
            Self::DeleteRepo(req) => req.into_parts(),
            Self::UpdateRepoSettings(req) => req.into_parts(),
            Self::MoveRepo(req) => req.into_parts(),
            Self::WhoAmI(req) => req.into_parts(),
            Self::GetUser(req) => req.into_parts(),
            Self::ListUserRepos(req) => req.into_parts(),
            Self::GetUserCollections(req) => req.into_parts(),
        }
    }
}
impl From<ListModelsRequest> for HuggingFaceHubRequest {
    fn from(req: ListModelsRequest) -> Self {
        Self::ListModels(req)
    }
}
impl From<GetModelRequest> for HuggingFaceHubRequest {
    fn from(req: GetModelRequest) -> Self {
        Self::GetModel(req)
    }
}
impl From<ListModelFilesRequest> for HuggingFaceHubRequest {
    fn from(req: ListModelFilesRequest) -> Self {
        Self::ListModelFiles(req)
    }
}
impl From<GetModelFileRequest> for HuggingFaceHubRequest {
    fn from(req: GetModelFileRequest) -> Self {
        Self::GetModelFile(req)
    }
}
impl From<ListModelCommitsRequest> for HuggingFaceHubRequest {
    fn from(req: ListModelCommitsRequest) -> Self {
        Self::ListModelCommits(req)
    }
}
impl From<GetModelReadmeRequest> for HuggingFaceHubRequest {
    fn from(req: GetModelReadmeRequest) -> Self {
        Self::GetModelReadme(req)
    }
}
impl From<ListModelDiscussionsRequest> for HuggingFaceHubRequest {
    fn from(req: ListModelDiscussionsRequest) -> Self {
        Self::ListModelDiscussions(req)
    }
}
impl From<GetModelCardRequest> for HuggingFaceHubRequest {
    fn from(req: GetModelCardRequest) -> Self {
        Self::GetModelCard(req)
    }
}
impl From<ListDatasetsRequest> for HuggingFaceHubRequest {
    fn from(req: ListDatasetsRequest) -> Self {
        Self::ListDatasets(req)
    }
}
impl From<GetDatasetRequest> for HuggingFaceHubRequest {
    fn from(req: GetDatasetRequest) -> Self {
        Self::GetDataset(req)
    }
}
impl From<ListDatasetFilesRequest> for HuggingFaceHubRequest {
    fn from(req: ListDatasetFilesRequest) -> Self {
        Self::ListDatasetFiles(req)
    }
}
impl From<GetDatasetFileRequest> for HuggingFaceHubRequest {
    fn from(req: GetDatasetFileRequest) -> Self {
        Self::GetDatasetFile(req)
    }
}
impl From<ListDatasetCommitsRequest> for HuggingFaceHubRequest {
    fn from(req: ListDatasetCommitsRequest) -> Self {
        Self::ListDatasetCommits(req)
    }
}
impl From<GetDatasetReadmeRequest> for HuggingFaceHubRequest {
    fn from(req: GetDatasetReadmeRequest) -> Self {
        Self::GetDatasetReadme(req)
    }
}
impl From<ListSpacesRequest> for HuggingFaceHubRequest {
    fn from(req: ListSpacesRequest) -> Self {
        Self::ListSpaces(req)
    }
}
impl From<GetSpaceRequest> for HuggingFaceHubRequest {
    fn from(req: GetSpaceRequest) -> Self {
        Self::GetSpace(req)
    }
}
impl From<ListSpaceFilesRequest> for HuggingFaceHubRequest {
    fn from(req: ListSpaceFilesRequest) -> Self {
        Self::ListSpaceFiles(req)
    }
}
impl From<GetSpaceFileRequest> for HuggingFaceHubRequest {
    fn from(req: GetSpaceFileRequest) -> Self {
        Self::GetSpaceFile(req)
    }
}
impl From<CreateRepoRequest> for HuggingFaceHubRequest {
    fn from(req: CreateRepoRequest) -> Self {
        Self::CreateRepo(req)
    }
}
impl From<DeleteRepoRequest> for HuggingFaceHubRequest {
    fn from(req: DeleteRepoRequest) -> Self {
        Self::DeleteRepo(req)
    }
}
impl From<UpdateRepoSettingsRequest> for HuggingFaceHubRequest {
    fn from(req: UpdateRepoSettingsRequest) -> Self {
        Self::UpdateRepoSettings(req)
    }
}
impl From<MoveRepoRequest> for HuggingFaceHubRequest {
    fn from(req: MoveRepoRequest) -> Self {
        Self::MoveRepo(req)
    }
}
impl From<WhoAmIRequest> for HuggingFaceHubRequest {
    fn from(req: WhoAmIRequest) -> Self {
        Self::WhoAmI(req)
    }
}
impl From<GetUserRequest> for HuggingFaceHubRequest {
    fn from(req: GetUserRequest) -> Self {
        Self::GetUser(req)
    }
}
impl From<ListUserReposRequest> for HuggingFaceHubRequest {
    fn from(req: ListUserReposRequest) -> Self {
        Self::ListUserRepos(req)
    }
}
impl From<GetUserCollectionsRequest> for HuggingFaceHubRequest {
    fn from(req: GetUserCollectionsRequest) -> Self {
        Self::GetUserCollections(req)
    }
}
/// Hugging Face Hub API for model discovery, dataset management, spaces, and repository operations client.
pub struct HuggingFaceHub {
    client: reqwest::Client,
    base_url: String,
    /// Environment variable names for authentication credentials.
    env_auth: Vec<String>,
    /// Authentication strategy for this API client.
    auth_strategy: schematic_define::AuthStrategy,
    /// Environment variable for Basic auth username.
    env_username: Option<String>,
    /// Default HTTP headers to include with every request.
    headers: Vec<(String, String)>,
}
impl HuggingFaceHub {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "https://huggingface.co/api";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![
                "HF_TOKEN".to_string(), "HUGGING_FACE_API_KEY".to_string(), "HF_API_KEY"
                .to_string()
            ],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
            env_auth: vec![
                "HF_TOKEN".to_string(), "HUGGING_FACE_API_KEY".to_string(), "HF_API_KEY"
                .to_string()
            ],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![
                "HF_TOKEN".to_string(), "HUGGING_FACE_API_KEY".to_string(), "HF_API_KEY"
                .to_string()
            ],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
            env_auth: vec![
                "HF_TOKEN".to_string(), "HUGGING_FACE_API_KEY".to_string(), "HF_API_KEY"
                .to_string()
            ],
            auth_strategy: schematic_define::AuthStrategy::BearerToken {
                header: None,
            },
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a variant of this API client with different configuration.
    ///
    /// This method clones the underlying HTTP client and allows customizing:
    /// - Base URL (for proxies, mock servers, or different environments)
    /// - Authentication credentials (different env var names)
    /// - Authentication strategy (via `UpdateStrategy`)
    ///
    /// ## Arguments
    ///
    /// * `base_url` - New base URL for this variant
    /// * `env_auth` - New environment variable names for credentials
    /// * `strategy` - How to update the auth strategy:
    ///   - `UpdateStrategy::NoChange` - Keep current auth strategy
    ///   - `UpdateStrategy::ChangeTo(auth)` - Use specified auth strategy
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// use schematic_define::UpdateStrategy;
    ///
    /// let api = Api::new();
    ///
    /// // Create a variant pointing to a staging server
    /// let staging = api.variant(
    ///     "https://staging.api.com/v1",
    ///     vec!["STAGING_API_KEY".to_string()],
    ///     UpdateStrategy::NoChange,
    /// );
    ///
    /// // Create a variant with different auth
    /// let other = api.variant(
    ///     "https://other.api.com/v1",
    ///     vec!["OTHER_TOKEN".to_string()],
    ///     UpdateStrategy::ChangeTo(schematic_define::AuthStrategy::ApiKey {
    ///         header: "X-API-Key".to_string(),
    ///     }),
    /// );
    /// ```
    pub fn variant(
        &self,
        base_url: impl Into<String>,
        env_auth: Vec<String>,
        strategy: schematic_define::UpdateStrategy,
    ) -> Self {
        let auth_strategy = match strategy {
            schematic_define::UpdateStrategy::NoChange => self.auth_strategy.clone(),
            schematic_define::UpdateStrategy::ChangeTo(auth) => auth,
        };
        Self {
            client: self.client.clone(),
            base_url: base_url.into(),
            env_auth,
            auth_strategy,
            env_username: self.env_username.clone(),
            headers: self.headers.clone(),
        }
    }
}
impl Default for HuggingFaceHub {
    fn default() -> Self {
        Self::new()
    }
}
impl HuggingFaceHub {
    /// Builds and sends an HTTP request, returning the raw response.
    ///
    /// This is an internal helper method used by the public request methods.
    async fn build_and_send_request(
        &self,
        request: impl Into<HuggingFaceHubRequest>,
    ) -> Result<reqwest::Response, SchematicError> {
        let request = request.into();
        let (method, path, body, endpoint_headers) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        match &self.auth_strategy {
            schematic_define::AuthStrategy::None => {}
            schematic_define::AuthStrategy::BearerToken { header } => {
                let header_name = header.as_deref().unwrap_or("Authorization");
                let token = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder
                    .header(header_name, format!("Bearer {}", token));
            }
            schematic_define::AuthStrategy::ApiKey { header } => {
                let key = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder.header(header.as_str(), key);
            }
            schematic_define::AuthStrategy::Basic => {
                let username_env = self.env_username.as_deref().unwrap_or("USERNAME");
                let password_env = self
                    .env_auth
                    .first()
                    .map(String::as_str)
                    .unwrap_or("PASSWORD");
                let username = std::env::var(username_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![username_env.to_string()],
                    })?;
                let password = std::env::var(password_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![password_env.to_string()],
                    })?;
                req_builder = req_builder.basic_auth(username, Some(password));
            }
        }
        let merged_headers = Self::merge_headers(&self.headers, &endpoint_headers);
        for (key, value) in merged_headers {
            req_builder = req_builder.header(key.as_str(), value.as_str());
        }
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        Ok(response)
    }
    /// Merges API-level and endpoint-level headers.
    ///
    /// Endpoint headers override API headers for matching keys (case-insensitive).
    /// Returns a new Vec with the merged headers.
    fn merge_headers(
        api_headers: &[(String, String)],
        endpoint_headers: &[(String, String)],
    ) -> Vec<(String, String)> {
        let mut result: Vec<(String, String)> = Vec::new();
        for (api_key, api_value) in api_headers {
            let has_override = endpoint_headers
                .iter()
                .any(|(k, _)| k.eq_ignore_ascii_case(api_key));
            if !has_override {
                result.push((api_key.clone(), api_value.clone()));
            }
        }
        for (key, value) in endpoint_headers {
            result.push((key.clone(), value.clone()));
        }
        result
    }
    /// Executes an API request expecting a JSON response.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<HuggingFaceHubRequest>,
    ) -> Result<T, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let result = response.json::<T>().await?;
        Ok(result)
    }
    /// Executes an API request expecting a plain text response.
    ///
    /// Returns the response body as a String.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    pub async fn request_text(
        &self,
        request: impl Into<HuggingFaceHubRequest>,
    ) -> Result<String, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let text = response.text().await?;
        Ok(text)
    }
    /// Convenience method for the `GetModelReadme` endpoint.
    ///
    /// Gets the README file content for a model
    pub async fn get_model_readme(
        &self,
        request: GetModelReadmeRequest,
    ) -> Result<String, SchematicError> {
        self.request_text(request).await
    }
    /// Convenience method for the `GetModelCard` endpoint.
    ///
    /// Gets the model card file content
    pub async fn get_model_card(
        &self,
        request: GetModelCardRequest,
    ) -> Result<String, SchematicError> {
        self.request_text(request).await
    }
    /// Convenience method for the `GetDatasetReadme` endpoint.
    ///
    /// Gets the README file content for a dataset
    pub async fn get_dataset_readme(
        &self,
        request: GetDatasetReadmeRequest,
    ) -> Result<String, SchematicError> {
        self.request_text(request).await
    }
}
