//! Generated REST API clients.
//!
//!This code was automatically generated by schematic-gen. Do not edit manually.
//!
//! ## Available APIs
//!
//! Each API is available as a separate module with its client struct,
//! request types, and response types re-exported from definitions.
//!
//! ## Quick Start
//!
//! Use the prelude for convenient imports:
//!
//! ```ignore
//! use schematic_schema::prelude::*;
//! ```
#![allow(unused_imports)]
pub mod shared;
pub mod prelude;
pub mod elevenlabs;
pub mod openai;

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // OpenAI Schema Tests
    // ========================================================================

    #[test]
    fn openai_list_models_request_into_parts() {
        let req = openai::ListModelsRequest {};
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "GET");
        assert_eq!(path, "/models");
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn openai_retrieve_model_request_into_parts() {
        let req = openai::RetrieveModelRequest {
            model: "gpt-4".to_string(),
        };
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "GET");
        assert_eq!(path, "/models/gpt-4");
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn openai_delete_model_request_into_parts() {
        let req = openai::DeleteModelRequest {
            model: "ft-gpt-4".to_string(),
        };
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "DELETE");
        assert_eq!(path, "/models/ft-gpt-4");
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn openai_request_enum_from_impl() {
        let list_req = openai::ListModelsRequest {};
        let enum_req: openai::OpenAIRequest = list_req.into();

        matches!(enum_req, openai::OpenAIRequest::ListModels(_));
    }

    #[test]
    fn openai_client_creation() {
        let _client = openai::OpenAI::new();
        assert_eq!(openai::OpenAI::BASE_URL, "https://api.openai.com/v1");

        // Default impl should work
        let _default_client = openai::OpenAI::default();
    }

    #[test]
    fn openai_client_with_base_url() {
        let _client = openai::OpenAI::with_base_url("http://localhost:8080");
    }

    // ========================================================================
    // ElevenLabs Schema Tests
    // ========================================================================

    #[test]
    fn elevenlabs_client_creation() {
        let _client = elevenlabs::ElevenLabs::new();
        assert_eq!(elevenlabs::ElevenLabs::BASE_URL, "https://api.elevenlabs.io");

        // Default impl should work
        let _default_client = elevenlabs::ElevenLabs::default();
    }

    #[test]
    fn elevenlabs_create_speech_request_into_parts() {
        let req = elevenlabs::CreateSpeechRequest {
            voice_id: "voice123".to_string(),
            body: schematic_definitions::elevenlabs::CreateSpeechBody {
                text: "Hello world".to_string(),
                ..Default::default()
            },
        };
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "POST");
        assert_eq!(path, "/v1/text-to-speech/voice123");
        assert!(body.is_some());
        // Verify body contains the text
        let body_str = body.unwrap();
        assert!(body_str.contains("Hello world"));
        assert!(headers.is_empty());
    }

    #[test]
    fn elevenlabs_list_voices_request_into_parts() {
        let req = elevenlabs::ListVoicesRequest {};
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "GET");
        assert_eq!(path, "/v2/voices");  // ElevenLabs uses v2 for voices API
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn elevenlabs_get_voice_request_into_parts() {
        let req = elevenlabs::GetVoiceRequest {
            voice_id: "abc123".to_string(),
        };
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "GET");
        assert_eq!(path, "/v1/voices/abc123");  // ElevenLabs uses v1 for single voice endpoints
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn elevenlabs_delete_voice_request_into_parts() {
        let req = elevenlabs::DeleteVoiceRequest {
            voice_id: "voice_to_delete".to_string(),
        };
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "DELETE");
        assert_eq!(path, "/v1/voices/voice_to_delete");  // ElevenLabs uses v1 for single voice endpoints
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    #[test]
    fn elevenlabs_request_enum_from_impl() {
        let list_req = elevenlabs::ListVoicesRequest {};
        let enum_req: elevenlabs::ElevenLabsRequest = list_req.into();

        matches!(enum_req, elevenlabs::ElevenLabsRequest::ListVoices(_));
    }

    #[test]
    fn elevenlabs_get_user_request_into_parts() {
        let req = elevenlabs::GetUserRequest {};
        let (method, path, body, headers) = req.into_parts().unwrap();

        assert_eq!(method, "GET");
        assert_eq!(path, "/v1/user");
        assert!(body.is_none());
        assert!(headers.is_empty());
    }

    // ========================================================================
    // Regression Tests - Body type naming collision
    // ========================================================================

    /// Regression test: Verifies that body type names don't collide with
    /// request struct names. Previously, `CreateSpeechRequest` was used for both
    /// the request body type and the generated request struct, causing recursive
    /// type errors. Now body types use the `Body` suffix (e.g., `CreateSpeechBody`).
    #[test]
    fn body_types_have_correct_names_no_collision() {
        // This test verifies compilation succeeds - if there was a naming
        // collision between request structs and body types, this would fail
        // to compile with "recursive type has infinite size" error.

        let body = schematic_definitions::elevenlabs::CreateSpeechBody {
            text: "test".to_string(),
            ..Default::default()
        };

        let req = elevenlabs::CreateSpeechRequest {
            voice_id: "v1".to_string(),
            body,
        };

        // If we got here, the types are correctly named and don't collide
        assert!(!req.voice_id.is_empty());
    }

    /// Regression test: Verifies that all body types implement Default.
    #[test]
    fn all_body_types_implement_default() {
        let _: schematic_definitions::elevenlabs::CreateSpeechBody = Default::default();
        let _: schematic_definitions::elevenlabs::AddSharedVoiceBody = Default::default();
        let _: schematic_definitions::elevenlabs::CreatePvcVoiceBody = Default::default();
        let _: schematic_definitions::elevenlabs::TrainPvcVoiceBody = Default::default();
        let _: schematic_definitions::elevenlabs::DownloadHistoryBody = Default::default();
        let _: schematic_definitions::elevenlabs::CreateSoundEffectBody = Default::default();
        let _: schematic_definitions::elevenlabs::ShareResourceBody = Default::default();
        let _: schematic_definitions::elevenlabs::UnshareResourceBody = Default::default();
        let _: schematic_definitions::elevenlabs::CopyResourceBody = Default::default();
        let _: schematic_definitions::elevenlabs::CreateApiKeyBody = Default::default();
        let _: schematic_definitions::elevenlabs::UpdateApiKeyBody = Default::default();
        let _: schematic_definitions::elevenlabs::CreateWebhookBody = Default::default();
        let _: schematic_definitions::elevenlabs::UpdateWebhookBody = Default::default();
    }
}
