// This code was automatically generated by schematic-gen. Do not edit manually.

/*! Generated API client for [OllamaOpenAI](https://github.com/ollama/ollama/blob/main/docs/openai.md).

 Ollama OpenAI-compatible REST API for drop-in replacement of OpenAI clients*/
//!
/*! ## Authentication

 No authentication required.*/
//!
/*! ## Features

 **GET**:
 - `ListModels` - List available models in OpenAI format

 **POST**:
 - `ChatCompletions` - Create chat completion (SSE streaming when stream=true)
 - `Completions` - Create text completion (SSE streaming when stream=true)
 - `Embeddings` - Generate embeddings for text
*/
//!
/*! ## Example

 ```ignore
 use schematic_schema::prelude::*;

 #[tokio::main]
 async fn main() -> Result<(), SchematicError> {
     let client = OllamaOpenAI::new();
     let response = client.list_models().await?;
     println!("{:?}", response);
     Ok(())
 }
 ```*/
use serde::{Deserialize, Serialize};
pub use schematic_definitions::ollama::*;
use crate::shared::SchematicError;
/// Request for `ChatCompletions` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{ChatCompletionsRequest, OpenAIChatCompletionRequest};
///
/// let body = OpenAIChatCompletionRequest {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = ChatCompletionsRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionsRequest {
    /// Request body
    pub body: OpenAIChatCompletionRequest,
}
impl Default for ChatCompletionsRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl ChatCompletionsRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: OpenAIChatCompletionRequest) -> Self {
        Self { body }
    }
}
impl ChatCompletionsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/v1/chat/completions".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `Completions` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{CompletionsRequest, OpenAICompletionRequest};
///
/// let body = OpenAICompletionRequest {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CompletionsRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompletionsRequest {
    /// Request body
    pub body: OpenAICompletionRequest,
}
impl Default for CompletionsRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl CompletionsRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: OpenAICompletionRequest) -> Self {
        Self { body }
    }
}
impl CompletionsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/v1/completions".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `Embeddings` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{EmbeddingsRequest, OpenAIEmbeddingRequest};
///
/// let body = OpenAIEmbeddingRequest {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = EmbeddingsRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbeddingsRequest {
    /// Request body
    pub body: OpenAIEmbeddingRequest,
}
impl Default for EmbeddingsRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl EmbeddingsRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: OpenAIEmbeddingRequest) -> Self {
        Self { body }
    }
}
impl EmbeddingsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/v1/embeddings".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListModels` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::ListModelsRequest;
///
/// let request = ListModelsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelsRequest {}
impl ListModelsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/v1/models".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request enum for OllamaOpenAI API.
///
/// Each variant wraps a strongly-typed request struct.
pub enum OllamaOpenAIRequest {
    /// Create chat completion (SSE streaming when stream=true)
    ChatCompletions(ChatCompletionsRequest),
    /// Create text completion (SSE streaming when stream=true)
    Completions(CompletionsRequest),
    /// Generate embeddings for text
    Embeddings(EmbeddingsRequest),
    /// List available models in OpenAI format
    ListModels(ListModelsRequest),
}
impl OllamaOpenAIRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        match self {
            Self::ChatCompletions(req) => req.into_parts(),
            Self::Completions(req) => req.into_parts(),
            Self::Embeddings(req) => req.into_parts(),
            Self::ListModels(req) => req.into_parts(),
        }
    }
}
impl From<ChatCompletionsRequest> for OllamaOpenAIRequest {
    fn from(req: ChatCompletionsRequest) -> Self {
        Self::ChatCompletions(req)
    }
}
impl From<CompletionsRequest> for OllamaOpenAIRequest {
    fn from(req: CompletionsRequest) -> Self {
        Self::Completions(req)
    }
}
impl From<EmbeddingsRequest> for OllamaOpenAIRequest {
    fn from(req: EmbeddingsRequest) -> Self {
        Self::Embeddings(req)
    }
}
impl From<ListModelsRequest> for OllamaOpenAIRequest {
    fn from(req: ListModelsRequest) -> Self {
        Self::ListModels(req)
    }
}
/// Ollama OpenAI-compatible REST API for drop-in replacement of OpenAI clients client.
pub struct OllamaOpenAI {
    client: reqwest::Client,
    base_url: String,
    /// Environment variable names for authentication credentials.
    env_auth: Vec<String>,
    /// Authentication strategy for this API client.
    auth_strategy: schematic_define::AuthStrategy,
    /// Environment variable for Basic auth username.
    env_username: Option<String>,
    /// Default HTTP headers to include with every request.
    headers: Vec<(String, String)>,
}
impl OllamaOpenAI {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "http://localhost:11434";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a variant of this API client with different configuration.
    ///
    /// This method clones the underlying HTTP client and allows customizing:
    /// - Base URL (for proxies, mock servers, or different environments)
    /// - Authentication credentials (different env var names)
    /// - Authentication strategy (via `UpdateStrategy`)
    ///
    /// ## Arguments
    ///
    /// * `base_url` - New base URL for this variant
    /// * `env_auth` - New environment variable names for credentials
    /// * `strategy` - How to update the auth strategy:
    ///   - `UpdateStrategy::NoChange` - Keep current auth strategy
    ///   - `UpdateStrategy::ChangeTo(auth)` - Use specified auth strategy
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// use schematic_define::UpdateStrategy;
    ///
    /// let api = Api::new();
    ///
    /// // Create a variant pointing to a staging server
    /// let staging = api.variant(
    ///     "https://staging.api.com/v1",
    ///     vec!["STAGING_API_KEY".to_string()],
    ///     UpdateStrategy::NoChange,
    /// );
    ///
    /// // Create a variant with different auth
    /// let other = api.variant(
    ///     "https://other.api.com/v1",
    ///     vec!["OTHER_TOKEN".to_string()],
    ///     UpdateStrategy::ChangeTo(schematic_define::AuthStrategy::ApiKey {
    ///         header: "X-API-Key".to_string(),
    ///     }),
    /// );
    /// ```
    pub fn variant(
        &self,
        base_url: impl Into<String>,
        env_auth: Vec<String>,
        strategy: schematic_define::UpdateStrategy,
    ) -> Self {
        let auth_strategy = match strategy {
            schematic_define::UpdateStrategy::NoChange => self.auth_strategy.clone(),
            schematic_define::UpdateStrategy::ChangeTo(auth) => auth,
        };
        Self {
            client: self.client.clone(),
            base_url: base_url.into(),
            env_auth,
            auth_strategy,
            env_username: self.env_username.clone(),
            headers: self.headers.clone(),
        }
    }
}
impl Default for OllamaOpenAI {
    fn default() -> Self {
        Self::new()
    }
}
impl OllamaOpenAI {
    /// Builds and sends an HTTP request, returning the raw response.
    ///
    /// This is an internal helper method used by the public request methods.
    async fn build_and_send_request(
        &self,
        request: impl Into<OllamaOpenAIRequest>,
    ) -> Result<reqwest::Response, SchematicError> {
        let request = request.into();
        let (method, path, body, endpoint_headers) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        match &self.auth_strategy {
            schematic_define::AuthStrategy::None => {}
            schematic_define::AuthStrategy::BearerToken { header } => {
                let header_name = header.as_deref().unwrap_or("Authorization");
                let token = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder
                    .header(header_name, format!("Bearer {}", token));
            }
            schematic_define::AuthStrategy::ApiKey { header } => {
                let key = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder.header(header.as_str(), key);
            }
            schematic_define::AuthStrategy::Basic => {
                let username_env = self.env_username.as_deref().unwrap_or("USERNAME");
                let password_env = self
                    .env_auth
                    .first()
                    .map(String::as_str)
                    .unwrap_or("PASSWORD");
                let username = std::env::var(username_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![username_env.to_string()],
                    })?;
                let password = std::env::var(password_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![password_env.to_string()],
                    })?;
                req_builder = req_builder.basic_auth(username, Some(password));
            }
        }
        let merged_headers = Self::merge_headers(&self.headers, &endpoint_headers);
        for (key, value) in merged_headers {
            req_builder = req_builder.header(key.as_str(), value.as_str());
        }
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        Ok(response)
    }
    /// Merges API-level and endpoint-level headers.
    ///
    /// Endpoint headers override API headers for matching keys (case-insensitive).
    /// Returns a new Vec with the merged headers.
    fn merge_headers(
        api_headers: &[(String, String)],
        endpoint_headers: &[(String, String)],
    ) -> Vec<(String, String)> {
        let mut result: Vec<(String, String)> = Vec::new();
        for (api_key, api_value) in api_headers {
            let has_override = endpoint_headers
                .iter()
                .any(|(k, _)| k.eq_ignore_ascii_case(api_key));
            if !has_override {
                result.push((api_key.clone(), api_value.clone()));
            }
        }
        for (key, value) in endpoint_headers {
            result.push((key.clone(), value.clone()));
        }
        result
    }
    /// Executes an API request expecting a JSON response.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<OllamaOpenAIRequest>,
    ) -> Result<T, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let result = response.json::<T>().await?;
        Ok(result)
    }
    /// Executes an API request expecting a binary response.
    ///
    /// Returns the raw bytes of the response body. Use this for endpoints
    /// that return binary data like audio files, images, or ZIP archives.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    pub async fn request_bytes(
        &self,
        request: impl Into<OllamaOpenAIRequest>,
    ) -> Result<bytes::Bytes, SchematicError> {
        let response = self.build_and_send_request(request).await?;
        let bytes = response.bytes().await?;
        Ok(bytes)
    }
    /// Convenience method for the `ChatCompletions` endpoint.
    ///
    /// Create chat completion (SSE streaming when stream=true)
    pub async fn chat_completions(
        &self,
        request: ChatCompletionsRequest,
    ) -> Result<bytes::Bytes, SchematicError> {
        self.request_bytes(request).await
    }
    /// Convenience method for the `Completions` endpoint.
    ///
    /// Create text completion (SSE streaming when stream=true)
    pub async fn completions(
        &self,
        request: CompletionsRequest,
    ) -> Result<bytes::Bytes, SchematicError> {
        self.request_bytes(request).await
    }
}
