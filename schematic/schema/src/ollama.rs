// This code was automatically generated by schematic-gen. Do not edit manually.

/*! Generated API client for [OllamaNative](https://github.com/ollama/ollama/blob/main/docs/api.md).

 Ollama native REST API for local LLM inference and model management*/
//!
/*! ## Authentication

 No authentication required.*/
//!
/*! ## Features

 **DELETE**:
 - `DeleteModel` - Delete a model

 **GET**:
 - `ListModels` - List locally available models
 - `ListRunningModels` - List models currently loaded in memory

 **POST**:
 - `Generate` - Generate text completion from a prompt (streaming NDJSON by default)
 - `Chat` - Generate chat completion from messages (streaming NDJSON by default)
 - `Embeddings` - Generate embeddings for text
 - `ShowModel` - Show detailed information about a model
 - `PullModel` - Pull a model from the Ollama registry (streaming progress by default)
 - `PushModel` - Push a model to the Ollama registry (streaming progress by default)
 - `CopyModel` - Copy a model to a new name
 - `CreateModel` - Create a model from a Modelfile (streaming progress by default)
*/
//!
/*! ## Example

 ```ignore
 use schematic_schema::prelude::*;

 #[tokio::main]
 async fn main() -> Result<(), SchematicError> {
     let client = OllamaNative::new();
     let response = client.list_models().await?;
     println!("{:?}", response);
     Ok(())
 }
 ```*/
use serde::{Deserialize, Serialize};
pub use schematic_definitions::ollama::*;
use crate::shared::SchematicError;
/// Request for `Generate` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{GenerateRequest, GenerateBody};
///
/// let body = GenerateBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = GenerateRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateRequest {
    /// Request body
    pub body: GenerateBody,
}
impl Default for GenerateRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl GenerateRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: GenerateBody) -> Self {
        Self { body }
    }
}
impl GenerateRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/generate".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `Chat` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{ChatRequest, ChatBody};
///
/// let body = ChatBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = ChatRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatRequest {
    /// Request body
    pub body: ChatBody,
}
impl Default for ChatRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl ChatRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: ChatBody) -> Self {
        Self { body }
    }
}
impl ChatRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/chat".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `Embeddings` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{EmbeddingsRequest, EmbeddingsBody};
///
/// let body = EmbeddingsBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = EmbeddingsRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbeddingsRequest {
    /// Request body
    pub body: EmbeddingsBody,
}
impl Default for EmbeddingsRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl EmbeddingsRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: EmbeddingsBody) -> Self {
        Self { body }
    }
}
impl EmbeddingsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/embeddings".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListModels` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::ListModelsRequest;
///
/// let request = ListModelsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListModelsRequest {}
impl ListModelsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/tags".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request for `ShowModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{ShowModelRequest, ShowModelBody};
///
/// let body = ShowModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = ShowModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShowModelRequest {
    /// Request body
    pub body: ShowModelBody,
}
impl Default for ShowModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl ShowModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: ShowModelBody) -> Self {
        Self { body }
    }
}
impl ShowModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/show".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `PullModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{PullModelRequest, PullModelBody};
///
/// let body = PullModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = PullModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullModelRequest {
    /// Request body
    pub body: PullModelBody,
}
impl Default for PullModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl PullModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: PullModelBody) -> Self {
        Self { body }
    }
}
impl PullModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/pull".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `PushModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{PushModelRequest, PushModelBody};
///
/// let body = PushModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = PushModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushModelRequest {
    /// Request body
    pub body: PushModelBody,
}
impl Default for PushModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl PushModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: PushModelBody) -> Self {
        Self { body }
    }
}
impl PushModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/push".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `CopyModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{CopyModelRequest, CopyModelBody};
///
/// let body = CopyModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CopyModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopyModelRequest {
    /// Request body
    pub body: CopyModelBody,
}
impl Default for CopyModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl CopyModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CopyModelBody) -> Self {
        Self { body }
    }
}
impl CopyModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/copy".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `DeleteModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{DeleteModelRequest, DeleteModelBody};
///
/// let body = DeleteModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = DeleteModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteModelRequest {
    /// Request body
    pub body: DeleteModelBody,
}
impl Default for DeleteModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl DeleteModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: DeleteModelBody) -> Self {
        Self { body }
    }
}
impl DeleteModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/delete".to_string();
        Ok((
            "DELETE",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `CreateModel` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::{CreateModelRequest, CreateModelBody};
///
/// let body = CreateModelBody {
///     // ... set required fields ...
///     ..Default::default()
/// };
/// let request = CreateModelRequest::new(body);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateModelRequest {
    /// Request body
    pub body: CreateModelBody,
}
impl Default for CreateModelRequest {
    fn default() -> Self {
        Self { body: Default::default() }
    }
}
impl CreateModelRequest {
    /// Creates a new request with the required path parameters and body.
    pub fn new(body: CreateModelBody) -> Self {
        Self { body }
    }
}
impl CreateModelRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/create".to_string();
        Ok((
            "POST",
            path,
            Some(
                serde_json::to_string(&self.body)
                    .map_err(|e| { SchematicError::SerializationError(e.to_string()) })?,
            ),
            vec![],
        ))
    }
}
/// Request for `ListRunningModels` endpoint.
///
/// ## Example
///
/// ```ignore
/// use schematic_schema::ollama::ListRunningModelsRequest;
///
/// let request = ListRunningModelsRequest::default();
/// ```
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ListRunningModelsRequest {}
impl ListRunningModelsRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// ## Returns
    ///
    /// A tuple of:
    /// - HTTP method as a static string (e.g., "GET", "POST")
    /// - Fully substituted path string
    /// - Optional JSON body string
    /// - Endpoint-specific headers as key-value pairs
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        let path = "/api/ps".to_string();
        Ok(("GET", path, None, vec![]))
    }
}
/// Request enum for OllamaNative API.
///
/// Each variant wraps a strongly-typed request struct.
pub enum OllamaNativeRequest {
    /// Generate text completion from a prompt (streaming NDJSON by default)
    Generate(GenerateRequest),
    /// Generate chat completion from messages (streaming NDJSON by default)
    Chat(ChatRequest),
    /// Generate embeddings for text
    Embeddings(EmbeddingsRequest),
    /// List locally available models
    ListModels(ListModelsRequest),
    /// Show detailed information about a model
    ShowModel(ShowModelRequest),
    /// Pull a model from the Ollama registry (streaming progress by default)
    PullModel(PullModelRequest),
    /// Push a model to the Ollama registry (streaming progress by default)
    PushModel(PushModelRequest),
    /// Copy a model to a new name
    CopyModel(CopyModelRequest),
    /// Delete a model
    DeleteModel(DeleteModelRequest),
    /// Create a model from a Modelfile (streaming progress by default)
    CreateModel(CreateModelRequest),
    /// List models currently loaded in memory
    ListRunningModels(ListRunningModelsRequest),
}
impl OllamaNativeRequest {
    /// Converts the request into (method, path, body, headers) parts.
    ///
    /// Delegates to the inner request struct's `into_parts()` method.
    ///
    /// ## Errors
    ///
    /// Returns `SchematicError::SerializationError` if the request body
    /// fails to serialize to JSON.
    pub fn into_parts(
        self,
    ) -> Result<
        (&'static str, String, Option<String>, Vec<(String, String)>),
        SchematicError,
    > {
        match self {
            Self::Generate(req) => req.into_parts(),
            Self::Chat(req) => req.into_parts(),
            Self::Embeddings(req) => req.into_parts(),
            Self::ListModels(req) => req.into_parts(),
            Self::ShowModel(req) => req.into_parts(),
            Self::PullModel(req) => req.into_parts(),
            Self::PushModel(req) => req.into_parts(),
            Self::CopyModel(req) => req.into_parts(),
            Self::DeleteModel(req) => req.into_parts(),
            Self::CreateModel(req) => req.into_parts(),
            Self::ListRunningModels(req) => req.into_parts(),
        }
    }
}
impl From<GenerateRequest> for OllamaNativeRequest {
    fn from(req: GenerateRequest) -> Self {
        Self::Generate(req)
    }
}
impl From<ChatRequest> for OllamaNativeRequest {
    fn from(req: ChatRequest) -> Self {
        Self::Chat(req)
    }
}
impl From<EmbeddingsRequest> for OllamaNativeRequest {
    fn from(req: EmbeddingsRequest) -> Self {
        Self::Embeddings(req)
    }
}
impl From<ListModelsRequest> for OllamaNativeRequest {
    fn from(req: ListModelsRequest) -> Self {
        Self::ListModels(req)
    }
}
impl From<ShowModelRequest> for OllamaNativeRequest {
    fn from(req: ShowModelRequest) -> Self {
        Self::ShowModel(req)
    }
}
impl From<PullModelRequest> for OllamaNativeRequest {
    fn from(req: PullModelRequest) -> Self {
        Self::PullModel(req)
    }
}
impl From<PushModelRequest> for OllamaNativeRequest {
    fn from(req: PushModelRequest) -> Self {
        Self::PushModel(req)
    }
}
impl From<CopyModelRequest> for OllamaNativeRequest {
    fn from(req: CopyModelRequest) -> Self {
        Self::CopyModel(req)
    }
}
impl From<DeleteModelRequest> for OllamaNativeRequest {
    fn from(req: DeleteModelRequest) -> Self {
        Self::DeleteModel(req)
    }
}
impl From<CreateModelRequest> for OllamaNativeRequest {
    fn from(req: CreateModelRequest) -> Self {
        Self::CreateModel(req)
    }
}
impl From<ListRunningModelsRequest> for OllamaNativeRequest {
    fn from(req: ListRunningModelsRequest) -> Self {
        Self::ListRunningModels(req)
    }
}
/// Ollama native REST API for local LLM inference and model management client.
pub struct OllamaNative {
    client: reqwest::Client,
    base_url: String,
    /// Environment variable names for authentication credentials.
    env_auth: Vec<String>,
    /// Authentication strategy for this API client.
    auth_strategy: schematic_define::AuthStrategy,
    /// Environment variable for Basic auth username.
    env_username: Option<String>,
    /// Default HTTP headers to include with every request.
    headers: Vec<(String, String)>,
}
impl OllamaNative {
    /// Base URL for the API.
    pub const BASE_URL: &'static str = "http://localhost:11434";
    /// Creates a new API client with the default base URL.
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let client = Api::with_base_url("http://localhost:8080/v1");
    /// ```
    pub fn with_base_url(base_url: impl Into<String>) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: base_url.into(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client.
    ///
    /// Use this when you need custom timeouts, connection pools, or middleware.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client(custom_client);
    /// ```
    pub fn with_client(client: reqwest::Client) -> Self {
        Self {
            client,
            base_url: Self::BASE_URL.to_string(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a new API client with a pre-configured reqwest client and custom base URL.
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// let custom_client = reqwest::Client::builder()
    ///     .timeout(std::time::Duration::from_secs(60))
    ///     .build()
    ///     .unwrap();
    /// let api = Api::with_client_and_base_url(custom_client, "http://localhost:8080");
    /// ```
    pub fn with_client_and_base_url(
        client: reqwest::Client,
        base_url: impl Into<String>,
    ) -> Self {
        Self {
            client,
            base_url: base_url.into(),
            env_auth: vec![],
            auth_strategy: schematic_define::AuthStrategy::None,
            env_username: None,
            headers: vec![],
        }
    }
    /// Creates a variant of this API client with different configuration.
    ///
    /// This method clones the underlying HTTP client and allows customizing:
    /// - Base URL (for proxies, mock servers, or different environments)
    /// - Authentication credentials (different env var names)
    /// - Authentication strategy (via `UpdateStrategy`)
    ///
    /// ## Arguments
    ///
    /// * `base_url` - New base URL for this variant
    /// * `env_auth` - New environment variable names for credentials
    /// * `strategy` - How to update the auth strategy:
    ///   - `UpdateStrategy::NoChange` - Keep current auth strategy
    ///   - `UpdateStrategy::ChangeTo(auth)` - Use specified auth strategy
    ///
    /// ## Examples
    ///
    /// ```ignore
    /// use schematic_define::UpdateStrategy;
    ///
    /// let api = Api::new();
    ///
    /// // Create a variant pointing to a staging server
    /// let staging = api.variant(
    ///     "https://staging.api.com/v1",
    ///     vec!["STAGING_API_KEY".to_string()],
    ///     UpdateStrategy::NoChange,
    /// );
    ///
    /// // Create a variant with different auth
    /// let other = api.variant(
    ///     "https://other.api.com/v1",
    ///     vec!["OTHER_TOKEN".to_string()],
    ///     UpdateStrategy::ChangeTo(schematic_define::AuthStrategy::ApiKey {
    ///         header: "X-API-Key".to_string(),
    ///     }),
    /// );
    /// ```
    pub fn variant(
        &self,
        base_url: impl Into<String>,
        env_auth: Vec<String>,
        strategy: schematic_define::UpdateStrategy,
    ) -> Self {
        let auth_strategy = match strategy {
            schematic_define::UpdateStrategy::NoChange => self.auth_strategy.clone(),
            schematic_define::UpdateStrategy::ChangeTo(auth) => auth,
        };
        Self {
            client: self.client.clone(),
            base_url: base_url.into(),
            env_auth,
            auth_strategy,
            env_username: self.env_username.clone(),
            headers: self.headers.clone(),
        }
    }
}
impl Default for OllamaNative {
    fn default() -> Self {
        Self::new()
    }
}
impl OllamaNative {
    /// Executes an API request.
    ///
    /// Takes any request type that can be converted into the request enum
    /// and returns the deserialized response.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (network error, timeout, etc.)
    /// - The response indicates a non-success status code
    /// - The response body cannot be deserialized as JSON
    pub async fn request<T: serde::de::DeserializeOwned>(
        &self,
        request: impl Into<OllamaNativeRequest>,
    ) -> Result<T, SchematicError> {
        let request = request.into();
        let (method, path, body, endpoint_headers) = request.into_parts()?;
        let url = format!("{}{}", self.base_url, path);
        let mut req_builder = match method {
            "GET" => self.client.get(&url),
            "POST" => self.client.post(&url),
            "PUT" => self.client.put(&url),
            "PATCH" => self.client.patch(&url),
            "DELETE" => self.client.delete(&url),
            "HEAD" => self.client.head(&url),
            "OPTIONS" => self.client.request(reqwest::Method::OPTIONS, &url),
            _ => return Err(SchematicError::UnsupportedMethod(method.to_string())),
        };
        match &self.auth_strategy {
            schematic_define::AuthStrategy::None => {}
            schematic_define::AuthStrategy::BearerToken { header } => {
                let header_name = header.as_deref().unwrap_or("Authorization");
                let token = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder
                    .header(header_name, format!("Bearer {}", token));
            }
            schematic_define::AuthStrategy::ApiKey { header } => {
                let key = self
                    .env_auth
                    .iter()
                    .find_map(|var| std::env::var(var).ok())
                    .ok_or_else(|| SchematicError::MissingCredential {
                        env_vars: self.env_auth.clone(),
                    })?;
                req_builder = req_builder.header(header.as_str(), key);
            }
            schematic_define::AuthStrategy::Basic => {
                let username_env = self.env_username.as_deref().unwrap_or("USERNAME");
                let password_env = self
                    .env_auth
                    .first()
                    .map(String::as_str)
                    .unwrap_or("PASSWORD");
                let username = std::env::var(username_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![username_env.to_string()],
                    })?;
                let password = std::env::var(password_env)
                    .map_err(|_| SchematicError::MissingCredential {
                        env_vars: vec![password_env.to_string()],
                    })?;
                req_builder = req_builder.basic_auth(username, Some(password));
            }
        }
        let merged_headers = Self::merge_headers(&self.headers, &endpoint_headers);
        for (key, value) in merged_headers {
            req_builder = req_builder.header(key.as_str(), value.as_str());
        }
        if let Some(body) = body {
            req_builder = req_builder
                .header("Content-Type", "application/json")
                .body(body);
        }
        let response = req_builder.send().await?;
        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.unwrap_or_default();
            return Err(SchematicError::ApiError {
                status,
                body,
            });
        }
        let result = response.json::<T>().await?;
        Ok(result)
    }
    /// Merges API-level and endpoint-level headers.
    ///
    /// Endpoint headers override API headers for matching keys (case-insensitive).
    /// Returns a new Vec with the merged headers.
    fn merge_headers(
        api_headers: &[(String, String)],
        endpoint_headers: &[(String, String)],
    ) -> Vec<(String, String)> {
        let mut result: Vec<(String, String)> = Vec::new();
        for (api_key, api_value) in api_headers {
            let has_override = endpoint_headers
                .iter()
                .any(|(k, _)| k.eq_ignore_ascii_case(api_key));
            if !has_override {
                result.push((api_key.clone(), api_value.clone()));
            }
        }
        for (key, value) in endpoint_headers {
            result.push((key.clone(), value.clone()));
        }
        result
    }
}
