To do a deep dive into [nvim-treesitter](https://github.com/nvim-treesitter/nvim-treesitter), we must look at it not just as a plugin, but as an **abstraction layer** or "adapter" that bridges the gap between raw, language-specific syntax trees and Neovim's editor features.

### The Core Abstraction Mechanism

The primary challenge `nvim-treesitter` solves is that every language's grammar produces a completely different Abstract Syntax Tree (AST). For example, a function definition in C might be a `function_definition` node, while in Python it's a `function_definition` and in Go it might be a `func_decl`.

`nvim-treesitter` abstracts this by defining a **Protocol of Standard Captures**.

1. **The Input (Language Specific):** The raw CST (Concrete Syntax Tree) generated by the parser.
2. **The Adapter (Query Files):** Language-specific `.scm` (Scheme) files that match patterns in the CST.
3. **The Interface (Standard Captures):** A standardized set of names (e.g., `@function.outer`, `@conditional`, `@comment`) that all queries map to.
4. **The Output (Editor Behavior):** Neovim features (Highlighting, Folding, Text Objects) that only listen for the **Standard Captures**.

#### Example: How `vaf` (Visual Around Function) works across languages

This is the perfect example of cross-language abstraction. The `nvim-treesitter-textobjects` module implements the logic "Select the range of `@function.outer`". It doesn't know what C or Python code looks like.

* **In C (`queries/c/textobjects.scm`):**
```scheme
(function_definition) @function.outer

```


*Matches the C-specific `function_definition` node.*
* **In Lua (`queries/lua/textobjects.scm`):**
```scheme
(function_declaration) @function.outer
(function_definition) @function.outer

```


*Matches Lua's specific declaration nodes.*
* **The Consumer (Neovim):**
The editor simply asks: "Give me the range for capture `@function.outer`." It receives the correct byte offsets regardless of the underlying language structure.

---

### Key Functions, Structs, and Enums

The functionality relies heavily on Neovim's internal Lua API (which `nvim-treesitter` wraps and manages) and the Scheme-based query engine.

#### 1. Query Files (`.scm`) - The "Structs" of Logic

These are the data structures that drive the plugin. They are located in `queries/<language>/`.

* **`highlights.scm`**: Maps nodes to highlight groups (e.g., `@keyword.function`, `@type.builtin`).
* **`textobjects.scm`**: Defines abstract structural boundaries (`@function.inner`, `@class.outer`, `@loop.inner`) used for navigation and selection.
* **`folds.scm`**: Defines which nodes should be foldable (e.g., mapping `function_definition` to `@fold`).
* **`indents.scm`**: Defines which nodes trigger an indent or dedent.

#### 2. Key Lua Functions (The Engine)

These functions in the Neovim core (and wrapped by the plugin) handle the processing.

* **`vim.treesitter.query.get(lang, query_name)`**:
* **Role:** The loader.
* **Functionality:** It looks for all `.scm` files in the runtime path for the given `lang` and `query_name` (e.g., "highlights"). Crucially, it handles **Inheritance**. If a query file starts with `;; inherits: c`, it will first load the C queries and then merge the current language's queries on top. This allows C++ to reuse C's logic without duplication.


* **`Query:iter_captures(node, source, start, stop)`**:
* **Role:** The processor.
* **Functionality:** It iterates over the AST `node`, runs the compiled query patterns, and yields `(id, node, metadata)` for every match. This is the loop that runs every time you scroll the screen (for highlighting) or press a key (for text objects).


* **`vim.treesitter.start(buf, lang)`**:
* **Role:** The activator.
* **Functionality:** Attaches the parser to the current buffer, setting up the callbacks that trigger re-parsing on text changes.



#### 3. Predicates and Directives (The Logic Glue)

Since simple pattern matching isn't always enough to normalize differences between languages, `nvim-treesitter` uses custom predicates in the queries to refine matches.

* **`#eq?`, `#match?`, `#any-of?**`: Used to filter nodes based on their text content.
* *Usage:* "Only match this node as a `@constant` if it is all uppercase."


* **`#make-range!`**: A critical directive for abstraction. It forces a capture to span a specific range (e.g., forcing a text object to include/exclude comments or whitespace) to ensure the "feel" of a text object is consistent across languages.
* **`#set!`**: Attaches metadata to a specific node, often used for `priority` (to resolve conflicting highlights) or `conceal` behaviors.

### Summary of Abstraction

| Layer | Specificity | Component |
| --- | --- | --- |
| **User Action** | Universal | `vai` (Visual Around Indent), Syntax Highlighting |
| **Abstraction** | **Universal Interface** | Standard Captures (`@function.outer`, `@keyword`) |
| **Adapter** | **Language Specific** | `queries/<lang>/*.scm` (Pattern Matching) |
| **Raw Data** | Language Specific | AST Nodes (`func_def`, `impl_item`, `definition`) |

By standardizing the **Capture Names** and providing a robust engine (`query.lua`) to merge and prioritize these matches, `nvim-treesitter` allows a single color scheme or a single text-object plugin to work instantly with 100+ languages.

## Architecture

The architecture of `nvim-treesitter` is split between Lua (high-level logic, plugin configuration) and the core Vim/Neovim C API (which it wraps). Since `nvim-treesitter` itself is primarily a Lua plugin that orchestrates Neovim's built-in C-based Treesitter engine, most of the "structs" are actually Lua tables or C structs within Neovim core that are exposed via the Lua API.

Here is the map of the key components within the plugin's file structure:

### 1. The Core Orchestrator

**File:** `lua/nvim-treesitter/configs.lua`
This is the central nervous system of the plugin. It manages which modules (highlight, incremental_selection, indent) are enabled for which languages.

* **`Configs` (Lua Table/Object)**: The main object holding the state of all modules.
* *Function:* `setup(user_config)` - The entry point users call in their `init.lua`. It validates user config and initializes modules.
* *Function:* `get_module(name)` - Retrieves the configuration for a specific module (e.g., "highlight").



### 2. The Query & Parsing Engine

**File:** `lua/nvim-treesitter/query.lua`
This file wraps Neovim's native `vim.treesitter.query` to add extra functionality like caching and handling custom predicates.

* **`get_query(lang, query_name)`**:
* *Role:* Retrieves and compiles the `.scm` query files.
* *Key Logic:* Implements the "Inheritance" logic. It checks `;; inherits: <lang>` directives in query files to merge queries from different languages (e.g., C++ inheriting C).


* **`collect_group_results(buf, query_name)`**:
* *Role:* Runs the query on the buffer and aggregates the results, often used by status line components or contextual plugins.



### 3. Language & Parser Management

**File:** `lua/nvim-treesitter/parsers.lua`
This module manages the list of supported languages and the installation of their parsers (compiling `.c` files to `.so`).

* **`get_parser_configs()`**:
* *Returns:* A registry (table) of all known parsers.
* *Structure:* Each entry contains `install_info` (URL, files to compile) and `filetype` (mapping Neovim filetypes to Treesitter languages).


* **`ParserInfo` (Concept/Table)**:
* Defines where to download the grammar (usually Github) and which files are required for compilation.



### 4. The Installer (Lockfile & CLI)

**File:** `lua/nvim-treesitter/install.lua`
Handles the `:TSInstall` and `:TSUpdate` commands.

* **`install_lang(lang, ask_reinstall, force, on_finish)`**:
* *Role:* The heavy lifter that orchestrates downloading the repo, compiling the C/C++ code via `cc`, and placing the resulting dynamic library in the `parser/` directory.


* **`compilers` (Table)**:
* A list of valid compilers (gcc, clang, cl) the plugin attempts to use to build the parsers.



### 5. Module Implementation Examples

The "Features" (highlighting, indentation) are implemented as modules that subscribe to the parser updates.

**File:** `lua/nvim-treesitter/highlight.lua`

* **`attach(bufnr, lang)`**:
* *Role:* Hooks into the buffer. It creates a `namespace` for highlights and sets up the event loop to refresh highlights when the text changes.


* **`Query:iter_captures` (via core)**:
* Used here to loop over the syntax tree and apply highlight groups (like `TsKeyword`) to the standard captures (like `@keyword`).



**File:** `lua/nvim-treesitter/indent.lua`

* **`get_indent(lnum)`**:
* *Role:* Replaces Vim's standard `indentexpr`. It queries the syntax tree to see if the current line is inside a node that implies indentation (defined in `indents.scm`).



### 6. Health Checks

**File:** `lua/nvim-treesitter/health.lua`

* **`check()`**:
* Run when you type `:checkhealth nvim-treesitter`. It verifies that `cc` is installed, parsers are readable, and Neovim is a compatible version.



### Summary Map

| Component | Key Function/Table | File Location |
| --- | --- | --- |
| **Config Loader** | `Configs.setup` | `lua/nvim-treesitter/configs.lua` |
| **Parser Registry** | `get_parser_configs` | `lua/nvim-treesitter/parsers.lua` |
| **Compiler/Installer** | `install_lang` | `lua/nvim-treesitter/install.lua` |
| **Query Engine** | `get_query` | `lua/nvim-treesitter/query.lua` |
| **Highlighting** | `attach` | `lua/nvim-treesitter/highlight.lua` |
| **Info UI** | `print_install_info` | `lua/nvim-treesitter/info.lua` |

## SCM Query Files

It is impractical to list every single file because `nvim-treesitter` supports over 100 languages, and each language has its own folder containing these files.

However, the repository follows a strict convention. Every language supported by the plugin (located in `queries/<language>/`) uses the same set of **Standard Query Files**.

Here are the `.scm` files you will find for any given language, along with their specific purpose:

### 1. The Core UI Queries

These directly affect how the code looks and behaves in the editor.

* **`highlights.scm`**
* **Purpose:** The most important file. It maps syntax tree nodes to Neovim highlight groups.
* **Example:** Mapping `(function_definition)` to `@function`.


* **`injections.scm`**
* **Purpose:** Defines where other languages are "injected" into the current one.
* **Example:** Highlighting SQL inside a Python string, or CSS inside an HTML `<style>` tag.


* **`folds.scm`**
* **Purpose:** Defines which nodes can be folded (collapsed).
* **Example:** Marking a `class_definition` or `impl_item` as a fold region.


* **`indents.scm`**
* **Purpose:** Defines indentation logic. It marks nodes that should increase or decrease the indent level.
* **Example:** Entering a `{` block in C triggers an indent; `}` triggers a dedent.



### 2. Semantic & Navigation Queries

These are used for smarter editor features like "go to definition" or renaming.

* **`locals.scm`**
* **Purpose:** Tracks variable definitions, references, and scopes. It tells the editor "this `x` is the same as that `x` defined above."
* **Key Captures:** `@definition`, `@reference`, `@scope`.


* **`textobjects.scm`** (Often associated with `nvim-treesitter-textobjects`)
* **Purpose:** Defines "objects" for selection and movement.
* **Key Captures:** `@function.outer`, `@class.inner`, `@parameter.list`.



### 3. File Structure

The directory structure in the repo looks like this:

```text
queries/
├── c/
│   ├── highlights.scm
│   ├── injections.scm
│   └── ...
├── python/
│   ├── highlights.scm
│   ├── folds.scm
│   └── ...
├── rust/
│   ├── highlights.scm
│   └── ...
└── ... (repeated for 100+ languages)

```

### Which one should you look at?

* If you want to fix **wrong colors**, check `highlights.scm`.
* If your **indentation is broken** when pressing enter, check `indents.scm`.
* If `vaf` (visual around function) **selects too much or too little**, check `textobjects.scm`.

## Example: comparing Rust and Typescript `highlights.scm`

The architecture of `nvim-treesitter` is built on a "Adapter Pattern." The plugin doesn't try to force every language to look the same; instead, it forces every language to **output the same labels** (Captures).

Below is the deep dive into the **Rust** and **TypeScript** `highlights.scm` files to see this abstraction in action.

### 1. Side-by-Side Comparison

This table shows how two different "concrete" inputs are mapped to the exact same "abstract" output.

| Concept | Rust Node (Grammar) | TypeScript Node (Grammar) | **Shared Capture (The Abstraction)** |
| --- | --- | --- | --- |
| **Function Definition** | `(function_item name: (identifier))` | `(function_declaration name: (identifier))` | `@function` |
| **Function Call** | `(call_expression function: (identifier))` | `(call_expression function: (identifier))` | `@function.call` |
| **Parameters** | `(parameter pattern: (identifier))` | `(required_parameter (identifier))` | `@variable.parameter` |
| **Structs / Interfaces** | `(type_identifier)` | `(type_identifier)` | `@type` |
| **Fields / Properties** | `(field_identifier)` | `(property_identifier)` | `@property` |
| **Built-in Types** | `(primitive_type)` | `(predefined_type)` | `@type.builtin` |

---

### 2. Extract: Rust `highlights.scm`

Rust's grammar is heavy on "Items" (function items, impl items) and "Macros".

```scheme
;; references: https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/rust/highlights.scm

; 1. Standard Function Matching
(function_item
  name: (identifier) @function)

; 2. Handling Macros (Language Specific)
; Rust has a specific node for macros using "!"
(macro_invocation
  macro: (identifier) @function.macro
  "!" @function.macro)

; 3. Lifetimes (Language Specific)
; Mapped to "@label" because there is no standard "@lifetime" capture.
(lifetime (identifier) @label)

; 4. Predicate Matching for Constants
; Only match identifiers as constants if they are ALL_CAPS
((identifier) @constant
 (#match? @constant "^[A-Z][A-Z\\d_]+$"))

```

### 3. Extract: TypeScript `highlights.scm`

TypeScript's grammar must handle the complexity of "Declarations" vs "Expressions" and JSX (React).

```scheme
;; references: https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/typescript/highlights.scm

; 1. Standard Function Matching
(function_declaration
  name: (identifier) @function)

; 2. Method Definitions (Class context)
(method_definition
  name: (property_identifier) @function.method)

; 3. Decorators (Language Specific)
; TypeScript's version of attributes, mapped to @attribute
(decorator
  (identifier) @attribute)

; 4. JSX / React (Language Specific)
; Uses standard "@tag" captures so it looks like HTML
(jsx_opening_element
  name: (identifier) @tag)
(jsx_attribute
  (property_identifier) @tag.attribute)

```

### 4. Contrast & Abstraction Analysis

#### The Convergence (Abstraction)

Notice that both files contain this pattern:

* **Rust:** `(function_item ... @function)`
* **TS:** `(function_declaration ... @function)`

This is the abstraction. The Neovim highlighting engine only listens for `@function`. It does not know or care that Rust calls it an "Item" and TypeScript calls it a "Declaration." The `.scm` file bridges that gap.

#### The Divergence (Language Features)

* **Rust's Complexity:** The Rust query has to work harder to identify **Constants**. In TypeScript/JS, `const` is a keyword, but in Rust, `const` variable naming is merely a convention. The query uses the `#match?` predicate to enforce the ALL_CAPS rule strictly in the editor, even if the compiler doesn't strictly require it.
* **TypeScript's Complexity:** TypeScript has to handle **Contextual Keywords**. For example, `type` is a keyword in `type MyType = ...`, but it can be a variable name in `let type = 5`. The TS queries are heavily nested to ensure `@keyword` is only applied when `type` is actually acting as a keyword.

### 5. Key Takeaway

The "Deep Dive" reveals that `nvim-treesitter` is essentially a massive library of **Regex-on-Steroids** (S-Expressions).

1. **Enums/Structs** (The AST Nodes) are provided by the parser (C code).
2. **Logic** (The `.scm` files) maps those nodes to **Standard Captures**.
3. **Result:** You get a consistent editing experience (same colors for functions, same shortcuts for text objects) across languages that share nothing in common syntactically.
