# Markdown Struct Implementation Plan

**Created:** 2025-12-31
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2025-12-31

**Reviewers:**
- Rust Developer: Approve with Changes
- Rust Architect: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. **Error handling consistency**: All output methods now return `Result` types
2. **Theme API redesign**: `ThemePair` is now the primary interface with `Theme` as internal
3. **Frontmatter type safety**: Added `Frontmatter` wrapper type with typed accessors
4. **DSL validation**: Added `ValidLineRange` with constructor validation
5. **Test infrastructure**: Added integration tests phase and cargo-nextest recommendation
6. **Dependency corrections**: Updated pulldown-cmark-to-cmark version, added html-escape
7. **Documentation**: Added Architecture Decision Records section

**Resolved Concerns:**
- ScopeStack manipulation → Use Vec<Scope> with manual slice creation
- TryFrom<&Url> async issue → Separate async `from_url()` method
- TestTerminal design → Simplified to strip_ansi_codes + manual capture
- Benchmark planning → Explicit benchmarks added to Phase 12
- Integration tests → Added Phase 2.5 for test structure

## Executive Summary

This plan implements the `Markdown` struct for the shared crate, providing a comprehensive Markdown processing pipeline with support for cleanup/normalization, frontmatter management, syntax-highlighted output to HTML and terminal, and MDAST AST export. It also includes terminal color detection utilities, terminal testing infrastructure, and the `mat` CLI for interactive testing.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | `Markdown` struct with `frontmatter: HashMap` and `content: String` fields | High | Rust Developer |
| FR-2 | `From<String>` and `From<&str>` trait implementations for markdown content | High | Rust Developer |
| FR-3 | `TryFrom` for file paths and URLs to load markdown from external sources | High | Rust Developer |
| FR-4 | `cleanup()` method using pulldown-cmark-to-cmark for normalization | High | Rust Developer |
| FR-5 | Blank line injection between block elements (headers, code, lists) | High | Rust Developer |
| FR-6 | Table column alignment with padding for human readability | Medium | Rust Developer |
| FR-7 | `fm_merge_with<T>()` - merge frontmatter with external values taking precedence | High | Schema Architect |
| FR-8 | `fm_defaults<T>()` - merge frontmatter with external defaults (document takes precedence) | High | Schema Architect |
| FR-9 | `as_string()` - export as text with merged frontmatter and content | High | Rust Developer |
| FR-10 | `as_ast()` - export MDAST representation using markdown-rs | Medium | Rust Developer |
| FR-11 | `as_html()` - export to HTML with syntax highlighting (code + prose) | High | Rust Developer |
| FR-12 | `for_terminal()` - export with ANSI escape codes for terminal display | High | Rust Developer |
| FR-13 | Theme enumeration for syntect/two-face themes (light/dark pairings) | High | Schema Architect |
| FR-14 | Grammar loading from syntect and two-face for code highlighting | High | Rust Developer |
| FR-15 | Code Block DSL: `title="..."`, `line-numbering=true`, `highlight=4-6,8` | Medium | Rust Developer |
| FR-16 | Line numbering support for code blocks (HTML table-based, terminal with gutter) | Medium | Rust Developer |
| FR-17 | Prose highlighting using scope-mapping approach (not double-parsing) | High | Rust Developer |
| FR-18 | `color_depth()` utility function using termini crate | High | Rust Developer |
| FR-19 | `supports_setting_foreground()` utility function | High | Rust Developer |
| FR-20 | `mat` CLI binary for interactive Markdown testing | Medium | Rust Developer |
| FR-21 | Image support via Kitty graphics protocol (viuer crate) | Low | Rust Developer |
| FR-22 | Mermaid diagram rendering (placeholder/future) | Low | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Parsing performance | < 10ms for 10KB markdown file | Rust Developer |
| NFR-2 | Memory efficiency | No unnecessary allocations in hot paths | Rust Developer |
| NFR-3 | Type safety | Compile-time guarantees for theme/grammar selection | Schema Architect |
| NFR-4 | HTML output security | XSS prevention via proper escaping | Rust Developer |
| NFR-5 | Terminal testing coverage | Snapshot tests + ANSI parsing tests | Feature Tester |
| NFR-6 | Documentation | Rustdoc for all public APIs | Rust Developer |
| NFR-7 | Error handling | thiserror for library, color-eyre for CLI | Rust Developer |

## Architecture Overview

The Markdown module will be added to the shared crate as a new top-level module `markdown/`.

### Component Diagram

```
shared/
├── markdown/
│   ├── mod.rs              # Public exports, Markdown struct
│   ├── types.rs            # Frontmatter type aliases, Theme/Grammar enums
│   ├── cleanup.rs          # Event stream manipulation for normalization
│   ├── frontmatter.rs      # YAML frontmatter parsing and merging
│   ├── output/
│   │   ├── mod.rs          # OutputFormatter trait, common utilities
│   │   ├── string.rs       # as_string() implementation
│   │   ├── ast.rs          # as_ast() MDAST export
│   │   ├── html.rs         # as_html() with syntax highlighting
│   │   └── terminal.rs     # for_terminal() with ANSI codes
│   ├── highlighting/
│   │   ├── mod.rs          # CodeHighlighter struct, lazy asset loading
│   │   ├── themes.rs       # Theme enum, ThemePair, loader
│   │   ├── grammars.rs     # Grammar loading from syntect/two-face
│   │   ├── scope_cache.rs  # Pre-parsed scopes for prose highlighting
│   │   └── code_block.rs   # Code block DSL parsing (title, line numbers, highlight)
│   └── dsl/
│       ├── mod.rs          # Code block DSL types
│       └── parser.rs       # DSL parsing logic (regex-based key=value)
├── terminal/
│   ├── mod.rs              # Terminal utilities
│   └── color.rs            # color_depth(), supports_setting_foreground()
└── testing/
    ├── mod.rs              # Test utilities module
    └── terminal.rs         # TestTerminal, ANSI stripping, snapshot helpers
```

### Data Flow

```
Input: String/File/URL
        │
        ▼
┌───────────────────┐
│  Markdown::from() │  ◄── Frontmatter extraction (YAML)
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│   Markdown {      │
│     frontmatter,  │
│     content       │
│   }               │
└─────────┬─────────┘
          │
    ┌─────┴─────┬───────────┬───────────┐
    ▼           ▼           ▼           ▼
cleanup()   as_string()  as_html()  for_terminal()
    │           │           │           │
    ▼           ▼           ▼           ▼
pulldown-   Merge FM    pulldown-   pulldown-
cmark +     + content   cmark +     cmark +
to-cmark                syntect     syntect +
                        HTML        ANSI codes
```

## Phases

### Phase 1: Terminal Color Utilities

**Principal Owner:** Rust Developer

**Goal:** Implement terminal color detection utilities for callers needing terminal capability information.

**Dependencies:** None

**Blast Radius:** `cargo test --lib terminal`

**Files to create:**
- `shared/src/terminal/mod.rs` - Module exports (15 lines)
- `shared/src/terminal/color.rs` - color_depth() and supports_setting_foreground() functions (60 lines)

**Dependencies to add to Cargo.toml:**
- `termini = "1.0"` - Terminal capability detection

**Technical Details:**
- `color_depth() -> u32`: Check COLORTERM env var first (truecolor/24bit → 16,777,216), fallback to termini for terminfo colors
- `supports_setting_foreground() -> bool`: Check termini for setaf/setf capabilities
- Both functions are non-async, pure utilities

**Acceptance Criteria:**
- [ ] File `shared/src/terminal/mod.rs` exists with public exports
- [ ] File `shared/src/terminal/color.rs` exists with >50 lines
- [ ] `grep "pub fn color_depth" shared/src/terminal/color.rs` succeeds
- [ ] `grep "pub fn supports_setting_foreground" shared/src/terminal/color.rs` succeeds
- [ ] `cargo test --lib terminal` runs 4+ tests
- [ ] All tests pass

---

### Phase 2: Testing Infrastructure for Terminal Output

**Principal Owner:** Feature Tester (Rust)

**Goal:** Establish testing utilities for terminal output verification before implementing terminal rendering.

**Dependencies:** None (can run in parallel with Phase 1)

**Blast Radius:** `cargo test --lib testing`

**Files to create:**
- `shared/src/testing/mod.rs` - Module exports and documentation (30 lines)
- `shared/src/testing/terminal.rs` - TestTerminal struct, ANSI utilities (150 lines)

**Dependencies to add to Cargo.toml:**
- `insta = "1.41"` - Snapshot testing framework (dev-dependency)

**Technical Details:**
- `strip_ansi_codes(input: &str) -> String`: Remove all ANSI escape sequences
- `TestTerminal` struct with methods:
  - `new() -> Self`
  - `run<F>(&self, test_code: F)` where F: FnOnce()
  - `assert_output(&self, expected: &str)` - Text comparison with stripped ANSI
  - `assert_has_color(&self, ansi_code: &str)` - Verify specific escape codes present
- Integration with `insta` for snapshot testing patterns
- Document testing strategies in module-level docs

**Acceptance Criteria:**
- [ ] File `shared/src/testing/mod.rs` exists
- [ ] File `shared/src/testing/terminal.rs` exists with >120 lines
- [ ] `grep "pub fn strip_ansi_codes" shared/src/testing/terminal.rs` succeeds
- [ ] `grep "pub struct TestTerminal" shared/src/testing/terminal.rs` succeeds
- [ ] `cargo test --lib testing` runs 6+ tests
- [ ] All tests pass

---

### Phase 2.5: Integration Test Structure

**Principal Owner:** Feature Tester (Rust)

**Goal:** Establish integration test directory structure and fixtures before implementation phases.

**Dependencies:** None (can run in parallel with Phases 1-2)

**Blast Radius:** N/A (structure only)

**Files to create:**
- `shared/tests/markdown_integration.rs` - Integration test scaffold (50 lines)
- `shared/tests/common/mod.rs` - Shared test utilities (30 lines)
- `shared/tests/fixtures/valid/simple.md` - Basic markdown fixture
- `shared/tests/fixtures/valid/complex.md` - Complex markdown with all features
- `shared/tests/fixtures/valid/frontmatter.md` - Frontmatter examples
- `shared/tests/fixtures/invalid/bad_frontmatter.md` - Malformed YAML
- `shared/tests/fixtures/invalid/unclosed_code.md` - Edge cases

**Technical Details:**
- Integration tests use `#[test]` in `tests/` directory (not `#[cfg(test)]`)
- Common utilities provide fixture loading helpers
- Fixtures cover: headers, code blocks, tables, lists, frontmatter, links, images

**Acceptance Criteria:**
- [ ] `shared/tests/` directory exists
- [ ] `shared/tests/markdown_integration.rs` exists with scaffold
- [ ] `shared/tests/common/mod.rs` exists with `load_fixture()` helper
- [ ] `shared/tests/fixtures/valid/` contains at least 3 fixtures
- [ ] `shared/tests/fixtures/invalid/` contains at least 2 edge cases
- [ ] `cargo test --test markdown_integration` compiles (may have no tests yet)

---

### Phase 3: Markdown Struct Core

**Principal Owner:** Rust Developer
**Secondary Owner:** Schema Architect

**Goal:** Implement the core Markdown struct with frontmatter extraction and basic trait implementations.

**Dependencies:** None (can run in parallel with Phases 1-2)

**Blast Radius:** `cargo test --lib markdown`

**Files to create:**
- `shared/src/markdown/mod.rs` - Module exports, Markdown struct definition (80 lines)
- `shared/src/markdown/types.rs` - Type aliases, error types (50 lines)
- `shared/src/markdown/frontmatter.rs` - YAML parsing, fm_merge_with, fm_defaults (150 lines)

**Dependencies to add to Cargo.toml:**
- `serde_yaml = "0.9"` - YAML frontmatter parsing

**Technical Details:**
```rust
/// Wrapper type for frontmatter with typed accessors
pub struct Frontmatter(HashMap<String, serde_json::Value>);

impl Frontmatter {
    pub fn get<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>, MarkdownError>
    pub fn merge_with<T: Serialize>(&mut self, other: T, strategy: MergeStrategy) -> Result<(), MarkdownError>
    pub fn set_defaults<T: Serialize>(&mut self, defaults: T) -> Result<(), MarkdownError>
}

pub enum MergeStrategy {
    ErrorOnConflict,
    PreferExternal,
    PreferDocument,
}

pub struct Markdown {
    frontmatter: Frontmatter,
    content: String,
}

impl From<String> for Markdown { ... }
impl From<&str> for Markdown { ... }
impl TryFrom<&Path> for Markdown { ... }  // File loading

// For URL loading, use separate async method (TryFrom is sync)
impl Markdown {
    pub async fn from_url(url: &Url) -> Result<Self, MarkdownError> { ... }
}
```

- Frontmatter detection: Lines between `---` delimiters at document start
- Merge strategies handle collision resolution explicitly
- Use `thiserror` for `MarkdownError` enum with comprehensive variants:
  ```rust
  #[derive(Debug, thiserror::Error)]
  pub enum MarkdownError {
      #[error("Failed to parse frontmatter: {0}")]
      FrontmatterParse(#[from] serde_yaml::Error),
      #[error("Failed to merge frontmatter: {reason}")]
      FrontmatterMerge { reason: String },
      #[error("Failed to load file: {0}")]
      FileLoad(#[from] std::io::Error),
      #[error("Failed to fetch URL: {0}")]
      UrlFetch(String),
      #[error("Failed to load theme: {0}")]
      ThemeLoad(String),
      #[error("Failed to parse AST: {0}")]
      AstParse(String),
      #[error("Invalid line range: start={start}, end={end}")]
      InvalidLineRange { start: usize, end: usize },
  }
  ```

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/mod.rs` exists with >60 lines
- [ ] File `shared/src/markdown/types.rs` exists with >40 lines
- [ ] File `shared/src/markdown/frontmatter.rs` exists with >120 lines
- [ ] `grep "pub struct Markdown" shared/src/markdown/mod.rs` succeeds
- [ ] `grep "impl From<String> for Markdown" shared/src/markdown/mod.rs` succeeds
- [ ] `grep "pub fn fm_merge_with" shared/src/markdown/mod.rs` succeeds
- [ ] `cargo test --lib markdown::frontmatter` runs 8+ tests
- [ ] All tests pass

---

### Phase 4: Markdown Cleanup Implementation

**Principal Owner:** Rust Developer

**Goal:** Implement the cleanup() method for Markdown normalization using pulldown-cmark event stream manipulation.

**Dependencies:** Phase 3 (Markdown struct must exist)

**Blast Radius:** `cargo test --lib markdown::cleanup`

**Files to create:**
- `shared/src/markdown/cleanup.rs` - Event stream manipulation, table alignment (250 lines)

**Dependencies to add to Cargo.toml:**
- `pulldown-cmark = "0.13"` - Markdown parsing
- `pulldown-cmark-to-cmark = "13"` - Markdown rendering from events (verify latest at implementation)

**Technical Details:**
- `cleanup(&mut self) -> &mut Self`: Mutate content in place, return self for chaining
- Event stream processing:
  1. Parse with `Parser::new_ext(content, Options::all())`
  2. Inject `Event::BlankLine` between block elements (headers, code blocks, lists, block quotes)
  3. Buffer and process table events for column alignment
  4. Render back with `pulldown_cmark_to_cmark::cmark()`
- Helper functions:
  - `is_block_tag(tag: &Tag) -> bool`
  - `is_block_end_tag(tag: &TagEnd) -> bool`
  - `align_tables_in_stream(events: Vec<Event>) -> Vec<Event>`
  - `process_single_table(events: Vec<Event>) -> Vec<Event>`

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/cleanup.rs` exists with >200 lines
- [ ] `grep "pub fn cleanup" shared/src/markdown/mod.rs` succeeds
- [ ] `grep "fn align_tables_in_stream" shared/src/markdown/cleanup.rs` succeeds
- [ ] `cargo test --lib markdown::cleanup` runs 10+ tests
- [ ] Tests verify blank line injection
- [ ] Tests verify table column alignment
- [ ] All tests pass

---

### Phase 5: Theme and Grammar Infrastructure

**Principal Owner:** Schema Architect
**Secondary Owner:** Rust Developer

**Goal:** Implement theme enumeration, theme pairing (light/dark), and grammar loading infrastructure.

**Dependencies:** None (can run in parallel with Phases 3-4)

**Blast Radius:** `cargo test --lib markdown::highlighting`

**Files to create:**
- `shared/src/markdown/highlighting/mod.rs` - Module exports, CodeHighlighter struct (100 lines)
- `shared/src/markdown/highlighting/themes.rs` - Theme enum, ThemePair enum, descriptions, loader (250 lines)
- `shared/src/markdown/highlighting/grammars.rs` - Grammar loading utilities (80 lines)
- `shared/src/markdown/highlighting/scope_cache.rs` - Pre-parsed scopes for prose (60 lines)

**Dependencies to add to Cargo.toml:**
- `syntect = "5.2"` - Syntax highlighting engine
- `two-face = "0.4"` - Extended themes and grammars

**Technical Details:**
```rust
/// Color mode for theme resolution
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColorMode { Light, Dark }

/// Primary API surface - theme pairs that adapt to light/dark
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[serde(rename_all = "kebab-case")]
#[non_exhaustive]
pub enum ThemePair {
    Base16Ocean,
    Github,
    Gruvbox,
    OneHalf,
    Solarized,
    Nord,
    Dracula,
    Monokai,
    VisualStudioDark,
    // ... (all pairs from docs)
}

impl ThemePair {
    pub fn resolve(&self, mode: ColorMode) -> Theme { ... }
    pub fn description(&self, mode: ColorMode) -> &'static str { ... }
}

/// Internal theme enum - individual theme variants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub(crate) enum Theme {
    Base16OceanDark,
    Base16OceanLight,
    GithubDark,
    GithubLight,
    // ... (all individual themes)
}

pub struct CodeHighlighter {
    syntax_set: SyntaxSet,
    theme: syntect::highlighting::Theme,
}
```

- Theme loader using `lazy_static` for static lookup table
- `ThemeSource` enum: `Syntect(String)` or `TwoFace(EmbeddedThemeName)`
- `get_theme_description(theme: Theme) -> &'static str`
- `ScopeCache` for pre-parsed scopes (heading, bold, italic, quote, link, code_inline, list, base)

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/highlighting/mod.rs` exists with >80 lines
- [ ] File `shared/src/markdown/highlighting/themes.rs` exists with >200 lines
- [ ] File `shared/src/markdown/highlighting/grammars.rs` exists with >60 lines
- [ ] File `shared/src/markdown/highlighting/scope_cache.rs` exists with >50 lines
- [ ] `grep "pub enum Theme" shared/src/markdown/highlighting/themes.rs` succeeds
- [ ] `grep "pub enum ThemePair" shared/src/markdown/highlighting/themes.rs` succeeds
- [ ] `grep "pub struct CodeHighlighter" shared/src/markdown/highlighting/mod.rs` succeeds
- [ ] `cargo test --lib markdown::highlighting` runs 12+ tests
- [ ] All tests pass

---

### Phase 6: Code Block DSL

**Principal Owner:** Rust Developer

**Goal:** Implement the code block DSL for title, line numbering, and line highlighting.

**Dependencies:** Phase 5 (highlighting infrastructure needed)

**Blast Radius:** `cargo test --lib markdown::dsl`

**Files to create:**
- `shared/src/markdown/dsl/mod.rs` - Module exports, CodeBlockMeta struct (50 lines)
- `shared/src/markdown/dsl/parser.rs` - DSL parsing with regex (120 lines)

**Technical Details:**
```rust
#[derive(Debug, Default)]
pub struct CodeBlockMeta {
    pub language: String,
    pub title: Option<String>,
    pub line_numbering: bool,
    pub highlight: HighlightSpec,
    pub custom: HashMap<String, String>,  // Extension point for future DSL additions
}

/// Validated highlight specification
#[derive(Debug, Clone, Default)]
pub struct HighlightSpec(Vec<ValidLineRange>);

/// Validated line range with enforced invariants
#[derive(Debug, Clone, Copy)]
pub struct ValidLineRange {
    start: usize,  // Private - ensures start <= end
    end: usize,
}

impl ValidLineRange {
    pub fn single(line: usize) -> Self {
        Self { start: line, end: line }
    }

    pub fn range(start: usize, end: usize) -> Result<Self, MarkdownError> {
        if start > end {
            Err(MarkdownError::InvalidLineRange { start, end })
        } else {
            Ok(Self { start, end })
        }
    }

    pub fn contains(&self, line: usize) -> bool {
        line >= self.start && line <= self.end
    }
}

// Parsing: "ts title=\"Greet\" line-numbering=true highlight=1,4-6"
pub fn parse_code_info(info_string: &str) -> Result<CodeBlockMeta, MarkdownError>
```

- Use `lazy_static` for pre-compiled regex
- Pattern: `(\w+)=(?:"([^"]*)"|'([^']*)'|(\S+))`
- First whitespace-delimited token is language
- Remainder parsed as key=value pairs
- `highlight` parser: handle single numbers, ranges (4-6), comma-separated lists
- **Known Limitation**: Escaped quotes inside quoted strings not supported (e.g., `title="foo\"bar"`)
  - Document this limitation; migrate to nom parser if needed in future

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/dsl/mod.rs` exists with >40 lines
- [ ] File `shared/src/markdown/dsl/parser.rs` exists with >100 lines
- [ ] `grep "pub struct CodeBlockMeta" shared/src/markdown/dsl/mod.rs` succeeds
- [ ] `grep "pub fn parse_code_info" shared/src/markdown/dsl/parser.rs` succeeds
- [ ] `cargo test --lib markdown::dsl` runs 15+ tests
- [ ] Tests cover: language-only, title, line-numbering, highlight single, highlight range, highlight list
- [ ] All tests pass

---

### Phase 7: Output - String and AST

**Principal Owner:** Rust Developer

**Goal:** Implement as_string() and as_ast() output methods.

**Dependencies:** Phase 3 (Markdown struct core)

**Blast Radius:** `cargo test --lib markdown::output`

**Files to create:**
- `shared/src/markdown/output/mod.rs` - OutputFormatter trait, module exports (40 lines)
- `shared/src/markdown/output/string.rs` - as_string() implementation (50 lines)
- `shared/src/markdown/output/ast.rs` - as_ast() MDAST export (80 lines)

**Dependencies to add to Cargo.toml:**
- `markdown = "1.0.0-alpha.22"` - MDAST support (use latest 1.x alpha/beta)

**Technical Details:**
```rust
impl Markdown {
    pub fn as_string(&self) -> String {
        // Reconstruct frontmatter as YAML block
        // Append content
    }

    pub fn as_ast(&self) -> Result<markdown::mdast::Node, MarkdownError> {
        markdown::to_mdast(&self.content, &ParseOptions::gfm())
    }
}
```

- `as_string()`: Serialize frontmatter back to YAML between `---` delimiters if non-empty
- `as_ast()`: Use `markdown::to_mdast()` with GFM options enabled
- AST is serializable via serde

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/mod.rs` exists with >30 lines
- [ ] File `shared/src/markdown/output/string.rs` exists with >40 lines
- [ ] File `shared/src/markdown/output/ast.rs` exists with >60 lines
- [ ] `grep "pub fn as_string" shared/src/markdown/output/string.rs` succeeds
- [ ] `grep "pub fn as_ast" shared/src/markdown/output/ast.rs` succeeds
- [ ] `cargo test --lib markdown::output` runs 8+ tests
- [ ] AST output is valid JSON when serialized
- [ ] All tests pass

---

### Phase 8: Output - HTML with Syntax Highlighting

**Principal Owner:** Rust Developer

**Goal:** Implement as_html() with full syntax highlighting for code blocks and prose.

**Dependencies:** Phase 5 (themes), Phase 6 (code block DSL)

**Blast Radius:** `cargo test --lib markdown::output::html`

**Files to create:**
- `shared/src/markdown/output/html.rs` - as_html() implementation with highlighting (350 lines)

**Technical Details:**
```rust
/// Options for HTML output with sensible defaults
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct HtmlOptions {
    pub code_theme: ThemePair,
    pub prose_theme: ThemePair,
    pub color_mode: ColorMode,
    pub include_line_numbers: bool, // Global default
    pub include_styles: bool,       // Inline CSS
}

impl Default for HtmlOptions {
    fn default() -> Self {
        Self {
            code_theme: ThemePair::Github,
            prose_theme: ThemePair::Github,
            color_mode: ColorMode::Dark,
            include_line_numbers: false,
            include_styles: true,
        }
    }
}

impl Markdown {
    /// Export to HTML with syntax highlighting
    /// Returns Result to handle theme loading and highlighting errors
    pub fn as_html(&self, options: HtmlOptions) -> Result<String, MarkdownError>
}
```

- Event loop processing:
  1. Iterate pulldown-cmark events
  2. For code blocks: buffer content, extract DSL metadata, highlight with syntect
  3. For prose: use scope-mapping approach with ScopeCache
- Line numbering: HTML table with `.ln-gutter` and `.code-content` cells
- Highlight lines: Add `.highlighted` class to specific table rows
- Title rendering: `<div class="code-block-title">...</div>` before code
- Escape HTML entities in all user content using `html_escape` crate (XSS prevention)
- Include embedded CSS if `include_styles: true`

**Dependencies to add to Cargo.toml:**
- `html-escape = "0.2"` - For XSS prevention

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/html.rs` exists with >300 lines
- [ ] `grep "pub fn as_html" shared/src/markdown/output/html.rs` succeeds
- [ ] `grep "pub struct HtmlOptions" shared/src/markdown/output/html.rs` succeeds
- [ ] `cargo test --lib markdown::output::html` runs 15+ tests
- [ ] Tests verify code block highlighting
- [ ] Tests verify prose highlighting
- [ ] Tests verify line numbering HTML structure
- [ ] Tests verify title rendering
- [ ] Tests verify HTML escaping (XSS prevention)
- [ ] All tests pass

---

### Phase 9: Output - Terminal with ANSI Codes

**Principal Owner:** Rust Developer

**Goal:** Implement for_terminal() with ANSI escape code output.

**Dependencies:** Phase 1 (terminal color), Phase 2 (testing), Phase 5 (themes), Phase 6 (DSL)

**Blast Radius:** `cargo test --lib markdown::output::terminal`

**Files to create:**
- `shared/src/markdown/output/terminal.rs` - for_terminal() implementation (300 lines)

**Technical Details:**
```rust
/// Color depth capability for terminal
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColorDepth {
    TrueColor,   // 24-bit (16.7M colors)
    Colors256,   // 8-bit
    Colors16,    // Basic ANSI
    None,        // No color support
}

/// Options for terminal output with sensible defaults
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct TerminalOptions {
    pub code_theme: ThemePair,
    pub prose_theme: ThemePair,
    pub color_mode: ColorMode,
    pub include_line_numbers: bool,
    pub color_depth: Option<ColorDepth>, // None = auto-detect
}

impl Default for TerminalOptions {
    fn default() -> Self {
        Self {
            code_theme: ThemePair::Github,
            prose_theme: ThemePair::Github,
            color_mode: ColorMode::Dark,
            include_line_numbers: false,
            color_depth: None,  // Auto-detect
        }
    }
}

impl Markdown {
    /// Export with ANSI escape codes for terminal display
    /// Returns Result to handle theme loading errors
    pub fn for_terminal(&self, options: TerminalOptions) -> Result<String, MarkdownError>
}
```

- Auto-detect color depth using `color_depth()` from Phase 1
- ANSI escape sequences:
  - Foreground: `\x1b[38;2;{r};{g};{b}m` (24-bit)
  - Background: `\x1b[48;2;{r};{g};{b}m`
  - Reset: `\x1b[0m`
- Line numbers: Gray gutter with `│` separator
- Base background for code blocks from theme settings
- Code block title: Bold text with `▌ ` prefix
- Use `syntect::util::as_24_bit_terminal_escaped()` for code

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/terminal.rs` exists with >250 lines
- [ ] `grep "pub fn for_terminal" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `grep "pub struct TerminalOptions" shared/src/markdown/output/terminal.rs` succeeds
- [ ] `cargo test --lib markdown::output::terminal` runs 12+ tests
- [ ] Tests use TestTerminal from Phase 2
- [ ] Tests verify ANSI codes present
- [ ] Tests verify content matches after stripping ANSI
- [ ] Snapshot tests for complex output
- [ ] All tests pass

---

### Phase 10: mat CLI Implementation

**Principal Owner:** Rust Developer

**Goal:** Implement the `mat` CLI binary for interactive Markdown testing.

**Dependencies:** Phase 4 (cleanup), Phase 8 (HTML), Phase 9 (terminal)

**Blast Radius:** `cargo test --bin mat`

**Files to create:**
- `mat/src/main.rs` - CLI entry point with clap (150 lines)

**Dependencies to add to mat/Cargo.toml:**
- `shared = { path = "../shared" }`
- `clap = { version = "4.5", features = ["derive"] }`
- `color-eyre = "0.6"`

**Technical Details:**
```rust
#[derive(Parser)]
#[command(name = "mat", about = "Markdown Awesome Tool")]
struct Cli {
    /// Input file path or "-" for stdin
    input: PathBuf,

    #[command(subcommand)]
    command: Commands,
}

enum Commands {
    /// Cleanup and normalize markdown
    Clean {
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
    /// Render to HTML
    Html {
        #[arg(long, default_value = "dark-github")]
        theme: String,
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
    /// Render to terminal
    View {
        #[arg(long, default_value = "dark-github")]
        theme: String,
    },
    /// Export AST as JSON
    Ast {
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
}
```

- Read from file or stdin
- Support piping: `cat README.md | mat view`
- Pretty error reporting with color-eyre

**Acceptance Criteria:**
- [ ] File `mat/src/main.rs` exists with >120 lines
- [ ] `grep "struct Cli" mat/src/main.rs` succeeds
- [ ] `grep "enum Commands" mat/src/main.rs` succeeds
- [ ] `cargo build -p mat` succeeds
- [ ] `cargo run -p mat -- --help` shows help text
- [ ] `echo "# Test" | cargo run -p mat -- - view` renders output
- [ ] All tests pass

---

### Phase 11: Image Support (Optional/Future)

**Principal Owner:** Rust Developer

**Goal:** Add Kitty graphics protocol support for inline images.

**Dependencies:** Phase 9 (terminal output)

**Blast Radius:** `cargo test --lib markdown::output::terminal::images`

**Files to create:**
- `shared/src/markdown/output/images.rs` - Image rendering utilities (100 lines)

**Dependencies to add to Cargo.toml:**
- `viuer = "0.7"` - Terminal image rendering

**Technical Details:**
- Detect `Event::Start(Tag::Image(...))` during terminal rendering
- Use viuer with Kitty protocol for supported terminals
- Fallback to `[Image: alt text]` for unsupported terminals
- Check TERM env var for Kitty support

**Acceptance Criteria:**
- [ ] File `shared/src/markdown/output/images.rs` exists with >80 lines
- [ ] `grep "fn render_image" shared/src/markdown/output/images.rs` succeeds
- [ ] Graceful fallback for non-Kitty terminals
- [ ] Tests pass (may need to be conditional on terminal support)

---

### Phase 12: Documentation and Polish

**Principal Owner:** Rust Developer
**Secondary Owner:** Feature Tester (Rust)

**Goal:** Finalize documentation, update READMEs, ensure consistency.

**Dependencies:** All previous phases

**Blast Radius:** `cargo test` (full suite)

**Tasks:**
- [ ] Update `shared/README.md` with markdown module documentation
- [ ] Update `shared/docs/markdown-struct.md` to reflect actual implementation
- [ ] Verify all public APIs have rustdoc comments
- [ ] Review and update `docs/md/*.md` for accuracy
- [ ] Add examples to rustdoc comments
- [ ] Ensure all tests pass: `cargo test --workspace`
- [ ] Run clippy: `cargo clippy --workspace`
- [ ] Verify mat CLI documentation: `cargo run -p mat -- --help`

**Acceptance Criteria:**
- [ ] All rustdoc comments have examples
- [ ] `cargo doc --no-deps` generates clean documentation
- [ ] `cargo clippy --workspace` has no warnings
- [ ] `cargo test --workspace` passes
- [ ] README updated with usage examples

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests**: `#[cfg(test)] mod tests` blocks in each module
- **Integration tests**: `tests/markdown_integration.rs` for end-to-end workflows
- **Property-based tests**: proptest for:
  - Markdown cleanup roundtrips: `cleanup(cleanup(md)) == cleanup(md)` (idempotence)
  - Cleanup content preservation: Original text preserved after cleanup
  - Frontmatter merge operations: `merge_with(a, merge_with(b, md)) == merge_with(merged(a,b), md)`
  - DSL parsing: Valid input always parses successfully
- **Snapshot tests**: insta for HTML and terminal output verification
- **Doc tests**: Examples in rustdoc that are executed
- **Test runner**: Use `cargo-nextest` for better performance and output
  - Install: `cargo install cargo-nextest`
  - Run: `cargo nextest run` instead of `cargo test`

### Error Testing Coverage

Each phase must include error path testing:
- Phase 3: Invalid frontmatter YAML, missing file, network timeout
- Phase 4: Malformed markdown edge cases
- Phase 6: Invalid DSL syntax, invalid highlight ranges
- Phase 8/9: Missing themes, highlighting failures (graceful fallback)

### Security Considerations

- **XSS Prevention**: All user content escaped via `html_escape::encode_text()` before HTML output
- **URL validation**: Remote Markdown loading must validate URLs
- **Resource limits**: Timeout on remote fetches, size limits on content

### Performance Considerations

- **Lazy loading**: SyntaxSet and ThemeSet loaded once via `lazy_static`
- **Scope caching**: Pre-parsed Scope objects in ScopeCache (not in render loop)
- **Event streaming**: Process pulldown-cmark events without full collection where possible
- **String allocation**: Use `String::with_capacity()` for known-size outputs

### Error Handling

- **Library errors**: `thiserror` for `MarkdownError` enum
- **CLI errors**: `color-eyre` for pretty error reports
- **No panics**: All fallible operations return `Result`

## Parallelization Opportunities

### Parallel Execution Groups

| Group | Phases | Can Start After | Assignees |
|-------|--------|-----------------|-----------|
| A | 1, 2, 2.5, 3, 5 | Plan approval | Rust Dev, Feature Tester, Schema Architect |
| B | 4, 6 | Phase 3 complete | Rust Developer |
| C | 7 | Phase 3 complete | Rust Developer |
| D | 8 | Phases 5, 6 complete | Rust Developer |
| E | 9 | Phases 1, 2, 5, 6 complete | Rust Developer |
| F | 10 | Phases 4, 8, 9 complete | Rust Developer |
| G | 11 | Phase 9 complete | Rust Developer |
| H | 12 | All phases complete | All |

**Critical Path:** Phase 3 → Phase 5 → Phase 6 → Phases 8-9 → Phase 10

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────────────────────►

Group A: ████████████████ (Phases 1, 2, 3, 5 in parallel)
                │
         ┌──────┴──────┐
         ▼             ▼
Group B: ████████      Group C: ████
(Phases 4, 6)          (Phase 7)
         │
         ▼
Group D: ████████████ (Phase 8)
         │
Group E: ████████████ (Phase 9)
         │
         ▼
Group F: ████████ (Phase 10)
         │
         ▼
Group G: ████ (Phase 11 - Optional)
         │
         ▼
Group H: ████ (Phase 12 - Documentation)
```

### Synchronization Points

1. **After Group A:** Core types and theme infrastructure must be finalized
2. **After Groups B+C:** All output methods can begin
3. **After Groups D+E:** CLI can be implemented
4. **Final:** Full integration testing

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| syntect/two-face compatibility issues | Medium | Test theme loading early in Phase 5 |
| pulldown-cmark-to-cmark API changes | Low | Pin version, check changelogs |
| markdown-rs 1.0 not stable | Medium | Use latest alpha, prepare for minor API changes |
| Terminal testing flakiness | Medium | Use snapshot tests, avoid timing-dependent tests |
| Performance regression on large files | Low | Add benchmarks in Phase 12, profile hot paths |

## Open Questions

- [x] **Q1:** Should Theme enum use PascalCase variants (`DarkGitHub`) or snake_case (`dark_github`) for serde serialization?
  - **RESOLVED:** Use PascalCase for enum variants (`Base16OceanDark`) with `#[serde(rename_all = "kebab-case")]` for serialization
- [x] **Q2:** For URL loading in TryFrom, should we use blocking reqwest or require async context?
  - **RESOLVED:** Use separate `async fn from_url()` method since `TryFrom` is a sync trait
- [x] **Q3:** Should the `mat` CLI support watching files for changes (live preview)?
  - **RESOLVED:** No, keep CLI simple. Users can use external tools like `entr` if needed.
- [x] **Q4:** For Mermaid support (Phase 11/future), prefer Mermaid.js integration or pre-render to images?
  - **RESOLVED:** Skip for now. Document as future enhancement. Phase 11 will focus on image support only.
- [x] **Q5:** Should terminal output support 256-color fallback or require truecolor terminals?
  - **RESOLVED:** Add `ColorDepth` enum with auto-detection as default but manual override possible

---

## Architecture Decision Records

### ADR-1: Why pulldown-cmark over markdown-rs for primary parsing

**Context:** Need to parse Markdown and manipulate the event stream for cleanup.

**Decision:** Use `pulldown-cmark` for parsing and event stream manipulation; use `markdown-rs` only for MDAST export.

**Rationale:**
- pulldown-cmark has mature event stream API ideal for cleanup transformations
- pulldown-cmark-to-cmark provides roundtrip capability
- markdown-rs is used only for `as_ast()` since it produces spec-compliant MDAST
- No need to double-parse; each crate serves a distinct purpose

### ADR-2: Why scope-mapping over double-parsing for prose highlighting

**Context:** Need to syntax-highlight both code blocks and prose content.

**Decision:** Map pulldown-cmark events to syntect scopes instead of running syntect's Markdown grammar.

**Rationale:**
- Avoids double-parsing (once for structure, once for highlighting)
- More performant since we're already processing the event stream
- Highlights content (text inside bold) not syntax markers (the `**` asterisks)
- This is preferred for reading prose anyway

### ADR-3: Why table-based HTML over CSS grid for line numbers

**Context:** Need to render code blocks with non-copyable line numbers.

**Decision:** Use HTML tables with separate `<td>` cells for line numbers and code.

**Rationale:**
- `user-select: none` on line number cells prevents copying
- Perfect vertical alignment between line numbers and code
- Works consistently across browsers
- Simpler than CSS grid for this use case

### ADR-4: Why ThemePair as primary API over individual Theme enum

**Context:** Users need to specify themes that work in both light and dark modes.

**Decision:** Make `ThemePair` the primary public API with `Theme` as internal.

**Rationale:**
- Users specify "github" and get appropriate light/dark variant automatically
- Reduces API surface area
- Prevents invalid combinations (e.g., light theme for dark mode)
- Extensible for future themes

### ADR-5: ScopeStack manipulation approach

**Context:** syntect's `ScopeStack::pop()` is not a public API.

**Decision:** Maintain a `Vec<Scope>` manually and create slices for `style_for_stack()`.

**Rationale:**
- Works around syntect API limitation
- Scope stacks are small (typically <10 elements)
- Simple and predictable behavior
