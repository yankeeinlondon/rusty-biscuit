# HTML Generation

Syntect can generate HTML output for static sites, documentation, and web-based code viewers. It offers two approaches: **inline styles** (self-contained) and **CSS classes** (better for performance and theme switching).

## Approach A: Inline Styles

Use `highlighted_html_for_string()` to generate HTML with inline `style` attributes. This produces self-contained HTML that works without external CSS.

```rust
use syntect::html::highlighted_html_for_string;
use syntect::parsing::SyntaxSet;
use syntect::highlighting::ThemeSet;

fn main() {
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension("rs").unwrap();
    let theme = &ts.themes["base16-ocean.dark"];

    let code = "let x = 5;";

    // Generates a <pre style="..."> with nested <span> tags containing inline colors
    let html = highlighted_html_for_string(code, &ps, syntax, theme).unwrap();

    println!("{}", html);
}
```

**Output Example:**

```html
<pre style="background-color:#2b303b;color:#c0c5ce;">
<span style="color:#b48ead;">let</span> x = <span style="color:#d08770;">5</span>;
</pre>
```

**When to use:**
- Single code snippets
- Email HTML (no external CSS allowed)
- Quick prototypes
- Self-contained documents

**Tradeoffs:**
- Larger HTML size (colors repeated in every `<span>`)
- Can't change themes without regenerating HTML
- Harder to customize styling

## Approach B: CSS Classes

Use `ClassedHTMLGenerator` to generate HTML with CSS classes instead of inline styles. You provide the CSS separately (Syntect can help generate it).

```rust
use syntect::html::{ClassedHTMLGenerator, ClassStyle};
use syntect::parsing::SyntaxSet;
use syntect::util::LinesWithEndings;

fn main() {
    let ps = SyntaxSet::load_defaults_newlines();
    let syntax = ps.find_syntax_by_extension("rs").unwrap();
    let mut html_generator = ClassedHTMLGenerator::new_with_class_style(
        syntax, &ps, ClassStyle::Spaced
    );

    let code = "fn main() {}";
    for line in LinesWithEndings::from(code) {
        html_generator.parse_html_for_line_which_includes_newline(line).unwrap();
    }

    let html = html_generator.finalize();
    println!("{}", html);
}
```

**Output Example:**

```html
<span class="source rust"><span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span></span> <span class="meta function rust"><span class="entity name function rust">main</span></span><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span></span><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span> <span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span><span class="punctuation section block end rust">}</span></span></span></span></span>
```

**When to use:**
- Static site generators
- Documentation sites
- Multiple code blocks on the same page
- Theme switching support needed
- Performance matters (smaller HTML)

**Tradeoffs:**
- Requires separate CSS file
- More setup complexity
- Need to generate or provide CSS for themes

### ClassStyle Options

`ClassStyle` determines how CSS classes are named:

- **`ClassStyle::Spaced`**: Classes include full scope hierarchy with spaces (e.g., `"source rust meta function rust"`)
- **`ClassStyle::SpacedPrefixed { prefix: "syntax-" }`**: Same as Spaced but with a prefix (e.g., `"syntax-source syntax-rust"`)

## Generating CSS for Themes

To generate CSS for use with `ClassedHTMLGenerator`:

```rust
use syntect::html::css_for_theme_with_class_style;
use syntect::highlighting::{ThemeSet, ClassStyle};

let ts = ThemeSet::load_defaults();
let theme = &ts.themes["base16-ocean.dark"];

let css = css_for_theme_with_class_style(theme, ClassStyle::Spaced).unwrap();
println!("{}", css);
```

This outputs CSS rules that match the classes generated by `ClassedHTMLGenerator`.

## Common Patterns

### Multi-line Code Block (Inline)

```rust
let code = r#"
fn hello() {
    println!("Hello!");
}
"#;

let html = highlighted_html_for_string(code, &ps, syntax, theme).unwrap();
```

### Multi-line Code Block (Classes)

```rust
let mut html_gen = ClassedHTMLGenerator::new_with_class_style(
    syntax, &ps, ClassStyle::Spaced
);

for line in LinesWithEndings::from(code) {
    html_gen.parse_html_for_line_which_includes_newline(line).unwrap();
}

let html = html_gen.finalize();
```

### Wrapping HTML

Both approaches generate only the core highlighted HTML. You typically wrap it:

```rust
let highlighted = highlighted_html_for_string(code, &ps, syntax, theme).unwrap();
let full_html = format!(
    r#"<div class="code-block">{}</div>"#,
    highlighted
);
```

## Gotchas

- **Inline styles produce `<pre>`**: The output already includes a `<pre>` tag
- **Classes don't include container**: `ClassedHTMLGenerator` outputs only `<span>` elements; wrap in `<pre>` yourself
- **CSS scope specificity**: When using classes, ensure your CSS selectors match the generated class patterns
- **Line endings matter**: Always use `LinesWithEndings::from()` for multi-line content

## Related

- [Terminal Output](./terminal-output.md) - ANSI escape codes for CLI
- [Binary Dumps](./binary-dumps.md) - Optimizing load times
